<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
    <link rel="icon" type="image/png" href="/img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="Programming">
    <meta name="author" content="Haojen Lau">
    <meta name="keywords" content>
    <title>Introduction_of_Cryptology - buki</title>
    <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css?v=5.7.2">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/bootstrap.min.css?v=4.3.1">
    <link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css?v=4.8.7">
    <link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
    <link rel="stylesheet" href="/lib/nprogress/nprogress.css?v=0.2.0">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">
    
        <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">
    
    <link rel="stylesheet" href="/css/main.css">

    
</head>


<body>
<header style="height: 30vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
<div class="container">
    <a class="navbar-brand" href="/">&nbsp;<strong>buki</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav ml-auto text-center">
            
            <li class="nav-item">
                <a class="nav-link" href="/">Home</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/archives/">Archives</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/categories/">Categories</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/tags/">Tags</a>
            </li>
            
            <li class="nav-item">
                <a class="nav-link" href="/about/">About</a>
            </li>
            
        </ul>
    </div>
</div>


</nav>
    <div class="view intro-2"
         style="background: url('/img/post.jpg')no-repeat center center;background-size: cover;">
        <div class="full-bg-img">
            <div class="mask rgba-black-light flex-center">
                <div class="container text-center white-text wow fadeInUp">
                    <span class="h2" id="subtitle">
                        
                    </span>
                    
                        <br>
                        <p>星期四, 四月 2日 2020, 2:16 下午</p>
                    
                </div>
            </div>
        </div>
    </div>
</header>

<main>
    
        

<div class="container-fluid">
    <div class="row">
        <div class="d-none d-lg-block col-lg-2"></div>
            <div class="col-lg-8 nopadding-md">
                <div class="py-5 z-depth-3 board">
                    <div class="post-content mx-auto">
                        <div class="markdown-body">
                            <p>​        Lately I have made up my mind to focus on learning Cryptology, just for my own interests. I have been exposed to CTF for almost one year, learning both Web and Crypto. Though it‘s too late, I think it is still a proper time for me to have a deeper study in Cryptology.</p>
<p>Now watching Christof Paar’s lecture, I am trying to note everything helpful here.</p>
<h1 id="Section-One"><a href="#Section-One" class="headerlink" title="Section One"></a>Section One</h1><p>​        Cryptology can be classified into Cryptography and Cryptanalysis, just as the image shows below.</p>
<img src="../images/Introduction_of_Cryptology/Cryptology.png" style="zoom: 67%;">



<p>​        <strong>Publicity means secure, and never use an untested cryptography algorithm.</strong> One of the most famous principle is Kerckhoff’s Principle.</p>
<img src="../images/Introduction_of_Cryptology/Kerckhoff's principle.jpg" style="zoom:67%;">

<p>​        </p>
<p>​        There are also some basic concepts:</p>
<blockquote>
<p>​            x = plain text<br>​            y = cipher text<br>​            e = encryption<br>​            d = decryption<br>​            K = key<br>​            |K| = Key space(number of Keys) </p>
</blockquote>
<h1 id="Section-Two"><a href="#Section-Two" class="headerlink" title="Section Two"></a>Section Two</h1><h2 id="Modulo-Operation"><a href="#Modulo-Operation" class="headerlink" title="Modulo Operation"></a>Modulo Operation</h2><p>​        Definition of modulo operation:</p>
<p>​<br>$$<br>let\quad a,;r,;m \in\mathbb{Z},;and;m&gt;0,;we;write:\<br> \begin{equation}<br>{a;\equiv; r}\mod{r}<br>\end{equation}\<br>;\<br>and\quad if;m;divides;(a;-;r),;i,e\<br>m;|;(a;-;r)<br>$$</p>
<p>​        1. r represents remainders, m represents modulus.</p>
<p>​        2. m | (a - r) can be used to check the equation.</p>
<p>​        </p>
<p>​        Equivalent classes:</p>
<p>​<br>$$<br>if\quad a;=;12, m;=;5,;then:\<br>;\<br>12;\equiv;2;\mod;5\<br>12;\equiv;7;\mod;5\<br>12;\equiv;-3;\mod;5\<br>…<br>$$<br>​            Then we can define a set:<br>$$<br>{…,;-8,;-3,;2,;7,;12,;17,;…}<br>$$<br>​            This set forms an <strong>equivalent class</strong> modulo 5. All members of the class behave equivalent modulo 5.</p>
<p>​            Write down all modulo 5 equivalent classes:</p>
<p>​<br>$$<br>Class A:\quad {…,;-10,;-5,;0,;5,;10,;15,;…}<br>$$</p>
<p>$$<br>Class B:\quad {…,;-9,;-4,;1,;6,;11,;16,;…}<br>$$</p>
<p>$$<br>Class D:\quad {…,;-7,;-2,;3,;8,;13,;18,;…}<br>$$</p>
<p>$$<br>Class E:\quad {…,;-6,;-1,;4,;9,;14,;19,;…}<br>$$</p>
<p>​            Usually we choose the smallest positive integer as the result, for convenience. We can always find a substitution in the equivalent classes aiming to simplify the modulo operation(including ‘+’ and ‘*’).</p>
<h2 id="Rings"><a href="#Rings" class="headerlink" title="Rings"></a>Rings</h2><p>​        Rings is an algebraic view on modular arithmetic.</p>
<p>​        Definition of the <strong>integer ring Z</strong> consists of:</p>
<p>​        1. The set<br>$$<br>\mathbb{Z_m};=;{0,;1,;2,;…,;m;-;1}<br>$$</p>
<p>​        2. Two operators: plus(“+”) and times(“*”), so that for all<br>$$<br>a,;b,;c,;d,;\in;\mathbb{Z_m}:<br>$$</p>
<p>$$<br>(i) a;+;b;\equiv;c\mod;m\<br>(ii)a;*;b;\equiv;d\mod;m<br>$$</p>
<h2 id="Shift-Caesar-Cipher"><a href="#Shift-Caesar-Cipher" class="headerlink" title="Shift (Caesar) Cipher"></a>Shift (Caesar) Cipher</h2><p>​        Definition:<br>$$<br>Let;x,;y,;k,\in\mathbb{Z_{26}},;k;as;the;key,<br>$$</p>
<p>$$<br>Encryption:;\mathbb{e_k}(x);\equiv;x;+;k\mod;26\<br>Decryption:;\mathbb{d_k}(y);\equiv;y;-;k\mod;26<br>$$</p>
<blockquote>
<ul>
<li><p>Key space: #K = 26</p>
</li>
<li><p>Attack method: </p>
<ol>
<li>Brute-force Attack</li>
</ol>
</li>
</ul>
<p>​          2. Frequency Analysis</p>
</blockquote>
<h2 id="Affine-Cipher"><a href="#Affine-Cipher" class="headerlink" title="Affine Cipher"></a>Affine Cipher</h2><p>​        Definition:<br>$$<br>Let;x,;y,;a,;b\in;\mathbb{Z_{26}},;gcd(a,;26)=;1,;Key;=;(a,;b);\<br>$$</p>
<p>$$<br>Encryption:;\mathbb{e_k}(x);\equiv;a;<em>;x;+;b\mod;26\<br>Decryption:;\mathbb{d_k}(y);\equiv;a^{-1};</em>;(y;-;b)\mod;26<br>$$</p>
<blockquote>
<ul>
<li><p>Key space: </p>
<p>Because: </p>
<p>#a = {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25} ==&gt; size = 12</p>
<p>#b = {0….25} ==&gt; size = 26</p>
<p>So:</p>
<p>#K = 12 * 26 = 312</p>
</li>
<li><p>Attack method:</p>
<ol>
<li>Brute-force Attack(seem to be easier…)</li>
<li>Frequency Analysis</li>
</ol>
</li>
<li><p>Alternatives: If a equals one, affine cipher will degenerate to shift cipher.</p>
</li>
</ul>
</blockquote>
<h1 id="Section-Three"><a href="#Section-Three" class="headerlink" title="Section Three"></a>Section Three</h1><h2 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h2><p>​        Stream Cipher is often used in safe communications in mobile.</p>
<p>​        Definition:    A stream cipher encrypts bits individually(bits by bits).<br>$$<br>Let;x_i,;y_i;S_i;\in;\mathbb{Z_2}={0,;1},<br>$$</p>
<p>$$<br>Encryption: e(x_i);\equiv;x_i;+;S_i\mod;2\<br>Decryption: d(y_i);\equiv;y_i;+;S_i\mod;2<br>$$<br>​        </p>
<p>​        Actually, it is an XOR process. Modulo 2 addition is the same as XOR operation(0 means unchanged, 1 means changed)</p>
<p>​        Additionally, we use RNG to generate a S key.    </p>
<p>​        <strong>Why the decryption process is the same as encryption?</strong> </p>
<p>​        <strong>Prove:</strong><br>$$<br>d(y_i);\equiv;y_i;+S_i\equiv;(x_i;+;S_i);+S_i\equiv;x_i;+2S_i\equiv;x_i\mod;2<br>$$<br>​        <strong>Conclusion: mod 2 addition and subtraction are the same operation.</strong></p>
<p>​        </p>
<p>​            </p>
<h2 id="Random-Number-Generators-RNG"><a href="#Random-Number-Generators-RNG" class="headerlink" title="Random Number Generators(RNG)"></a>Random Number Generators(RNG)</h2><p>We distinguish between three types of RNGs.</p>
<ul>
<li><p><strong>True Random Number Generators(TRNG)</strong></p>
<p>True random numbers stem from random physical process. (coin flipping, lottery, noise, mouse movement, key stroke timing, …)</p>
<p>*<em>A true random number generating process can hardly be recreated. *</em></p>
</li>
<li><p><strong>Pseudo Random Number Generators(PRNG)</strong></p>
<p>PRNGs, are computed, i.e,  they are deterministic. Often, they are computed with the following function:</p>
</li>
</ul>
<p>$$<br>S_0=seed<br>$$</p>
<p>$$<br>S_{i+1}=F(s_i)<br>$$</p>
<ul>
<li><p><strong>Cryptographically Secure PRNGs(CPRNG)</strong></p>
<p>CPRNGs are PRNG with an additional property: the numbers are unpredictable.</p>
<p>Informal definition:<br>$$<br>Given;n;output;bits:\quad S_i,;S_{i+1},;…,;S_{i+n-1},;it;is;computationally;infeasible;to;construct;S_n.<br>$$</p>
</li>
</ul>
<p>  PRNG is the most popular in modern applications.</p>
<h2 id="One-Time-Pad-OTP"><a href="#One-Time-Pad-OTP" class="headerlink" title="One Time Pad(OTP)"></a>One Time Pad(OTP)</h2><p>​        Definition: The One Time Pad(OTP) is a stream cipher where:</p>
<p>​        1. the key stream bits :<br>$$<br>S_i<br>$$<br>​             stem from a TRNG.</p>
<p>​        2. each key stream bit is used only once.</p>
<p>​        <strong>Drawback: key is at least as long as the message.</strong></p>
<h2 id="Linear-Congruential-Generator-LCG"><a href="#Linear-Congruential-Generator-LCG" class="headerlink" title="Linear Congruential Generator(LCG)"></a>Linear Congruential Generator(LCG)</h2><p><img src="../images/Introduction_of_Cryptology/transfer.png" alt></p>
<p>​        Definition:<br>$$<br>S_0=seed\<br>S_{i+1}=A;*;S_i;+;B\mod;m,;;A,;B,;S_i\in\mathbb{Z_m}\<br>Key;=k(A,;B)<br>$$</p>
<p>$$<br>Remember:;A,;B,;S_i;are;[log_2m];bits;long<br>$$</p>
<blockquote>
<p>A is multiplier</p>
<p>B is increment</p>
<p>m is modulus</p>
</blockquote>
<p>​        LCG is a kind of PRNG. And LCG is not safe enough in cryptography applications.</p>
<h1 id="Section-Four"><a href="#Section-Four" class="headerlink" title="Section Four"></a>Section Four</h1><h2 id="Linear-Feedback-Shift-Registers-LFSR"><a href="#Linear-Feedback-Shift-Registers-LFSR" class="headerlink" title="Linear Feedback Shift Registers(LFSR)"></a>Linear Feedback Shift Registers(LFSR)</h2><p>​        LFSR is used in stream cipher that is small(low power) in hardware, it is a kind of PRNG. One of the example is A5/1 in GSM, which consists of three LFSRs.</p>
<p>​        Atomic element: Flip-Flop, which means stores 1 bit.</p>
<img src="../images/Introduction_of_Cryptology/flip_flop.jpg" style="zoom:20%;">

<p>​        </p>
<p>​        An example of LFSR: </p>
<p>​                                             <img src="../images/Introduction_of_Cryptology/LFSR.jpg" style="zoom:30%;"></p>
<p>​        Mathematic description:<br>$$<br>S_{i+3};\equiv;S_{i+1};+;S_{i}\mod;2<br>$$<br>​        </p>
<p>​        A general LFSR is like that:</p>
<p>​                                                <img src="../images/Introduction_of_Cryptology/LFSR2.jpg" style="zoom:20%;"></p>
<p>​        We can get the pattern below:<br>$$<br>S_m;\equiv;S_{m-1}P_{m-1};+;S_{m-2}P_{m-2};+;…;+S_1P_1;+;S_0P_0\mod;2\<br>S_{m+1};\equiv;S_{m}P_{m-1};+;S_{m-1}P_{m-2};+;…;+S_2P_1;+;S_1P_0\mod;2\<br>…\<br>…<br>$$</p>
<p>$$<br>S_{m+i};\equiv;\sum_{j=0}^{m-1};S_{i+j}P_j\mod;2,;i;=;0,;1,;2,;…<br>$$</p>
<p>​        <strong>Theorem one:</strong> </p>
<p>​                        The maximum period generated by an LFSR of degree m(the numbers of flip-flops) is:<br>$$<br>2^m;-;1<br>$$<br>​        <strong>Theorem two:</strong></p>
<p>​                        Only certain feedback configurations(p sequences) yield maximum length sequences(2 ^ 1 -1).</p>
<p>​        We can specify feedback configuration by:<br>$$<br>P(x);=;x^m;+;p_{m-1}x^{m-1};+;…;+;p_1x;+;p_0<br>$$<br>​        <strong>Theorem three:</strong></p>
<p>​                        Only LFSRs with <strong>“primitive polynomials”</strong> yield maximum length sequences.</p>
<p>​        </p>
<p>​        Here is the primitive polynomials table: <a href="https://www.partow.net/programming/polynomials/index.html" target="_blank" rel="noopener">https://www.partow.net/programming/polynomials/index.html</a>.</p>
<p>​        </p>
<p>​        LFSR is also not secure enough for cryptography.</p>
<h2 id="Attack-in-Single-LFSR"><a href="#Attack-in-Single-LFSR" class="headerlink" title="Attack in Single LFSR"></a>Attack in Single LFSR</h2><p>​        Given:<br>$$<br>-;;All;;y_i<br>$$</p>
<p>$$<br>-;Degree;m<br>$$</p>
<p>$$<br>-;x_0,;…,;x_{2m-1}<br>$$</p>
<p>​            </p>
<p>​        <strong>Step one:</strong> Recover partial S stream<br>$$<br>y_i\equiv;x_i;+;S_i\mod;2\<br>S_i\equiv;y_i;+;x_i\mod;2\<br>i;=;0,;1,;2,;…,;{2m-1}<br>$$<br>​        <strong>Step two:</strong> Recover the whole LFSR configuration(p sequence)<br>$$<br>S_m;\equiv;S_{m-1}P_{m-1};+;…;+;S_0P_0\mod;2\<br>S_{m+1};\equiv;S_{m}P_{m-1};+;…;+;S_1P_0\mod;2\<br>…\<br>…\<br>…\<br>S_{2m-1};\equiv;S_{2m-2}P_{m-1};+;…;+;S_{m-1}P_0\mod;2<br>$$<br>​            We obtain system of m linear equations with m unknowns, and it can be solved easily by <strong>Gaussian Elimination or matrix inversion</strong>. Then, we get the whole p sequence.</p>
<p>​            Here we have <strong>another conclusion</strong>: If an attacker knows(at least) 2m output values of an LFSR, he can recover the entire LFSR configuration(p sequence).</p>
<p>​        <strong>Step three:</strong></p>
<p>​            Using p sequence to build LFSR and compute the whole s stream. Finally we can use the whole s stream to decipher all yi.<br>$$<br>x_i;\equiv;y_i;+;S_i\mod;2<br>$$</p>
<h1 id="Section-Five"><a href="#Section-Five" class="headerlink" title="Section Five"></a>Section Five</h1><h2 id="Shannon-Two-Atomic-Operations"><a href="#Shannon-Two-Atomic-Operations" class="headerlink" title="Shannon Two Atomic Operations"></a>Shannon Two Atomic Operations</h2><ul>
<li>Confusion<ul>
<li>Relationship between plain and cipher is obscured.</li>
<li>Example: Substitution table</li>
</ul>
</li>
<li>Diffusion<ul>
<li>The influence of one each plain bit is spread over many cipher bits</li>
<li>Example: Permutation table</li>
</ul>
</li>
</ul>
<p><strong>Combine confusion and diffusion (many times)to build a strong block cipher.</strong></p>
<h2 id="Feistel-Network"><a href="#Feistel-Network" class="headerlink" title="Feistel Network"></a>Feistel Network</h2><p>​    DES encryption and decryption process is a kind of feistel(like fine) network. This structure is used in many other ciphers.</p>
<h1 id="Section-Six"><a href="#Section-Six" class="headerlink" title="Section Six"></a>Section Six</h1><p>DES is designed by IBM.</p>
<h2 id="Security-of-DES"><a href="#Security-of-DES" class="headerlink" title="Security of DES"></a>Security of DES</h2><p>Two families of attack</p>
<ul>
<li>Analytic Attacks<ul>
<li>Differential Cryptanalysis<ul>
<li>requires 2^47 (x, y) pairs</li>
<li>hardly works in practice</li>
</ul>
</li>
<li>Linear Cryptanalysis<ul>
<li>requires 2^43 (x,y)pairs</li>
</ul>
</li>
</ul>
</li>
<li>Brute-force Attack<ul>
<li>given: (x_0, y_0), check DES^{-1}(y_0) == x_0</li>
<li>requires 2^56 times to try at most</li>
<li>Example in real world: EFF DES cracker (deepcracker)</li>
</ul>
</li>
</ul>
<p>Nowadays DES can be easily broken in a few days. DES is not safe any more. Instead, we use 3-DES, AES or even AES-Finalists(4 ciphers lost in the final AES competition but very secure)</p>
<h1 id="Section-Seven"><a href="#Section-Seven" class="headerlink" title="Section Seven"></a>Section Seven</h1><h2 id="Introduction-of-AES"><a href="#Introduction-of-AES" class="headerlink" title="Introduction of AES"></a>Introduction of AES</h2><p>All internal operations of AES are based on finite fields(Galois Field).</p>
<h2 id="Finite-Field-Galois-Field"><a href="#Finite-Field-Galois-Field" class="headerlink" title="Finite Field(Galois Field)"></a>Finite Field(Galois Field)</h2><p>In Crypto we almost always need finite sets. Finite field only exists if they have:</p>
<p>$$<br>p^m,;(p;is;a;positive;prime;and;m;is;a;positive;integer)<br>$$<br>elements.</p>
<p>Therefore, all the finite field should be written like this:<br>$$<br>GF(p^m)<br>$$<br>Two kinds of fields can be remarked:</p>
<ul>
<li>If m = 1, it is called prime fields.</li>
<li>If m &gt; 1, it is called extension fields.</li>
</ul>
<p>AES field is:<br>$$<br>GF(2^8)<br>$$</p>
<h2 id="Prime-Field-GF-p"><a href="#Prime-Field-GF-p" class="headerlink" title="Prime Field GF(p)"></a>Prime Field GF(p)</h2><p>The element of a prime field GF(p) are the integers:<br>$$<br>{0,;1,;…;,(p-1)}<br>$$<br>Operations we can do:</p>
<ul>
<li>add</li>
<li>subtract</li>
<li>multiply</li>
<li>Inversion</li>
</ul>
<p>in modulo p:<br>$$<br>\mod{p}<br>$$<br>Note that all conditions of field are satisfied with these computations.</p>
<h2 id="Extension-Field-GF-p-m"><a href="#Extension-Field-GF-p-m" class="headerlink" title="Extension Field GF(p^m)"></a>Extension Field GF(p^m)</h2><ul>
<li><p>Element representation</p>
<ul>
<li>The elements of GF(2^m) are polynomials:<br>$$<br>a_{m-1}x^{m-1};+;…+;a_1x;+a_0;=;A(x);\in;GF(p^m),\quad{a_i};\in;GF(p)<br>$$</li>
</ul>
</li>
</ul>
<pre><code>Therefore, we can rewrite it in AES:
$$
a_{7}x^{7}\;+\;...+\;a_1x\;+a_0\;=\;A(x)\;\in\;GF(2^8),\quad{a_i}\;\in\;GF(2)\;=\;\{0,\;1\}
$$</code></pre><p>Operations we can do:</p>
<ul>
<li><p>add and subtract</p>
<ul>
<li>use regular polynomial addition and subtraction, where the coefficients   are computed in GF(p).</li>
<li>Note: add and subtract in GF(2^m) are the same operations.(they are the same as XOR)</li>
</ul>
</li>
<li><p>multiplication</p>
<ul>
<li>Reduce the regular polynomial multiply result, modulo a polynomial that “behaves like a prime”. These are called “irreducible polynomial”.</li>
</ul>
<p>One Calculation Example:</p>
<img src="../images/Introduction_of_Cryptology/GF(x)_calculate.jpg" style="zoom: 25%;">

<ul>
<li><p>For every Field GF(2^m) there are several irreducible polynomials(check it on the Internet)</p>
</li>
<li><p>Use different irreducible polynomials may produce different result. </p>
</li>
<li><p>Therefore, we use the “AES irreducible polynomial”:<br>$$<br>P(x);=;{x^8}+{x^4}+{x^3}+{x}+1<br>$$</p>
</li>
</ul>
</li>
<li><p>inversion</p>
<ul>
<li><p>Again, the inverse A^{-1}(x) of an element A(x) \in GF(2^m) must satisfy.<br>$$<br>{A(x)};*;A^{-1}(x)\mod{P(x)}<br>$$<br>P(x) is irreducible polynomials.</p>
<p>Use extended Euclidean methods to calculate A^{-1}(x). </p>
</li>
</ul>
</li>
</ul>
<h1 id="Section-Eight"><a href="#Section-Eight" class="headerlink" title="Section Eight"></a>Section Eight</h1><h2 id="Introduction-of-AES-1"><a href="#Introduction-of-AES-1" class="headerlink" title="Introduction of AES"></a>Introduction of AES</h2><p>AES is by now is the most important symmetric algorithm in the world.</p>
<p>Numbers of rounds depend on the key length.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>rounds</th>
</tr>
</thead>
<tbody><tr>
<td>128</td>
<td>10</td>
</tr>
<tr>
<td>192</td>
<td>12</td>
</tr>
<tr>
<td>256</td>
<td>14</td>
</tr>
</tbody></table>
<p>AES is not a Feistel cipher. AES encrypts all 128 bits of the data path in one round.</p>
<p>Each round consists of 4 layers:</p>
<ul>
<li>ByteSub(with S-box)  –&gt; confusion</li>
<li>ShiftRow  –&gt; diffusion</li>
<li>MixCol –&gt; diffusion</li>
<li>Key addition</li>
</ul>
<p><strong>Last round does not have the MixCol layer</strong></p>
<h2 id="Internal-AES"><a href="#Internal-AES" class="headerlink" title="Internal AES"></a>Internal AES</h2><p>The 128 bits data path is split into 16 bytes.</p>
<p>…</p>
<h1 id="Section-Nine"><a href="#Section-Nine" class="headerlink" title="Section Nine"></a>Section Nine</h1><p>Block Cipher can be used for many other tasks:</p>
<ul>
<li>different encryption schemes</li>
<li>stream cipher</li>
<li>PRNG</li>
<li>hash function</li>
<li>MACs</li>
</ul>
<h2 id="Modes-in-Block-Ciphers-Encryption"><a href="#Modes-in-Block-Ciphers-Encryption" class="headerlink" title="Modes in Block Ciphers Encryption"></a>Modes in Block Ciphers Encryption</h2><p>There are mainly modes in block ciphers:</p>
<ul>
<li>deterministic encryption<ul>
<li>ECB (Electronic Code Book)</li>
</ul>
</li>
<li>probabilistic encryption<ul>
<li>block cipher<ul>
<li>CBC(Cipher Block Chaining)</li>
<li>PCBC(Propagating Cipher Block Chaining)</li>
</ul>
</li>
<li>stream cipher<ul>
<li>OFB(Output Feedback)</li>
<li>CFB(Cipher Feedback)</li>
<li>CTR(Counter)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Def of deterministic:</strong></p>
<p>An encryption scheme is “deterministic” if a particular plaintext is mapped to a fixed ciphertext if the key is unchanged.</p>
<h2 id="ECB-Mode"><a href="#ECB-Mode" class="headerlink" title="ECB Mode"></a>ECB Mode</h2><p>Electronic Code Book Mode provides a deterministic encryption result. It is the simplest encryption mode, which is also unsafe. The disadvantage of this method is a lack of <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion" target="_blank" rel="noopener">diffusion</a>. Because ECB encrypts identical <a href="https://en.wikipedia.org/wiki/Plaintext" target="_blank" rel="noopener">plaintext</a> blocks into identical <a href="https://en.wikipedia.org/wiki/Ciphertext" target="_blank" rel="noopener">ciphertext</a> blocks(this is why it is called codebook), it does not hide data patterns well. ECB is not recommended for use in cryptographic protocols. </p>
<img src="../images/Introduction_of_Cryptology/Ecb_encryption.png" style="zoom:80%;">



<img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200516101057994.png" alt="image-20200516101057994" style="zoom:200%;">



<h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><h4 id="Redirect-Attack"><a href="#Redirect-Attack" class="headerlink" title="Redirect  Attack"></a>Redirect  Attack</h4><p>There is no need to break AES in this attack. Just wiretap the cipher, reuse the  partial specific block cipher and realize the attack.</p>
<h2 id="CBC-Mode"><a href="#CBC-Mode" class="headerlink" title="CBC Mode"></a>CBC Mode</h2><p>We want to solve two problems:</p>
<ul>
<li>Cipher block chaining mode makes the encryption probabilistic</li>
<li>Combine encryption of all blocks</li>
</ul>
<p><strong>Def of probabilistic:</strong></p>
<p>A “probabilistic” encryption scheme uses randomness to achieve a non-deterministic generation of y_i.</p>
<p><strong>Encryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CBC_encryption.svg.png" alt><br>$$<br>C_i;=;E_k(P_i;\oplus;C_{i-1})\<br>C_0;=;IV\<br>$$</p>
<p><strong>Decryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CBC_decryption.svg.png" alt></p>
<p>$$<br>P_i;=;D_K(C_i);\oplus;C_{i-1}\<br>C_0;=;IV<br>$$<br><strong>Attention</strong></p>
<p>IV does not have to be secret, and it should be “nonce” - “number used only once”</p>
<h2 id="OFB-Mode"><a href="#OFB-Mode" class="headerlink" title="OFB Mode"></a>OFB Mode</h2><p>Idea: Use the block cipher as a Keystream generator. The <em>output feedback</em> (OFB) mode makes a block cipher into a synchronous <a href="https://en.wikipedia.org/wiki/Stream_cipher" target="_blank" rel="noopener">stream cipher</a>. It generates <a href="https://en.wikipedia.org/wiki/Keystream" target="_blank" rel="noopener">keystream</a> blocks, which are then <a href="https://en.wikipedia.org/wiki/XOR" target="_blank" rel="noopener">XORed</a> with the plaintext blocks to get the ciphertext. Because of the symmetry of the XOR operation, encryption and decryption are exactly the same. Write the encryption and decryption together:<br>$$<br>C_j;=;P_j;\oplus;O_j\<br>P_j;=;C_j;\oplus;O_j\<br>O_j;=;E_K(I_j)\<br>I_j;=;O_{j-1}\<br>I_0;=;IV\<br>i,;j=;0,;1,;…<br>$$</p>
<p><strong>Encryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/OFB_encryption.svg.png" alt></p>
<p><strong>Decryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/OFB_decryption.svg.png" alt></p>
<h2 id="CFB-Mode"><a href="#CFB-Mode" class="headerlink" title="CFB Mode"></a>CFB Mode</h2><p>The <em>cipher feedback</em> (CFB) mode, a close relative of CBC, makes a block cipher into a self-synchronizing <a href="https://en.wikipedia.org/wiki/Stream_cipher" target="_blank" rel="noopener">stream cipher</a>. Operation is very similar; in particular, CFB decryption is almost identical to CBC encryption performed in reverse.</p>
<p><strong>Encryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CFB_encryption.svg.png" alt><br>$$<br>C_i;=;E_K(C_{i-1});\oplus;P_i\<br>C_0;=;IV<br>$$<br><strong>Decryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CFB_decryption.svg.png" alt></p>
<p>$$<br>P_i;=;E_K(C_{i-1});\oplus;C_i\<br>C_0;=;IV<br>$$</p>
<h2 id="CTR-Mode-ICM-Mode"><a href="#CTR-Mode-ICM-Mode" class="headerlink" title="CTR Mode/ICM Mode"></a>CTR Mode/ICM Mode</h2><p>CTR mode (CM) is also known as <em>integer counter mode</em> (ICM) and <em>segmented integer counter</em> (SIC) mode. Like OFB, counter mode turns a <a href="https://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="noopener">block cipher</a> into a <a href="https://en.wikipedia.org/wiki/Stream_cipher" target="_blank" rel="noopener">stream cipher</a>. It generates the next <a href="https://en.wikipedia.org/wiki/Keystream" target="_blank" rel="noopener">keystream</a> block by encrypting successive values of a “counter”. In case of a non-random nonce (such as a packet counter), the nonce and counter should be concatenated (e.g., storing the nonce in the upper 64 bits and the counter in the lower 64 bits of a 128-bit counter block).</p>
<p><strong>Encryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CTR_encryption_2.svg.png" alt></p>
<p><strong>Decryption Process:</strong></p>
<p><img src="../images/Introduction_of_Cryptology/CTR_decryption_2.svg.png" alt></p>
<p>Remember it is also important to think about the efficiency of each modes in aspects like, encryption parallelization and decryption parallelization.</p>
<h1 id="Section-Ten"><a href="#Section-Ten" class="headerlink" title="Section Ten"></a>Section Ten</h1><p>Double encryption, triple encryption, brute-force attack and meet-in-the-middle attack.</p>
<p>We note here that when using AES,we already have three different security levels given by the key lengths of 128, 192 and 256 bits. Given that there are no realistic attacks known against AES with any of those key lengths, there appears no reason to perform multiple encryption with AES for practical systems. However, for some selected older ciphers, especially for DES, multiple encryption can be a useful tool.</p>
<h2 id="Meet-in-the-middle-attack"><a href="#Meet-in-the-middle-attack" class="headerlink" title="Meet in the middle attack"></a>Meet in the middle attack</h2><p>Use meet in the middle attack to lower the complexity of the attack in double DES.<br>$$<br>O(2^{k}+2^{k})=O(2^{k+1}),;k;is;the;length;of;each;key<br>$$</p>
<h2 id="3-DES"><a href="#3-DES" class="headerlink" title="3-DES"></a>3-DES</h2><p>3-DES have three keys, it has three options:</p>
<p>Keying option 1</p>
<p>All three keys are independent. Sometimes known as 3TDEA<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-NIST57r4-13" target="_blank" rel="noopener">[13]</a> or triple-length keys.<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-cryptography_world-14" target="_blank" rel="noopener">[14]</a></p>
<p>This is the strongest, with 3 × 56 = 168 independent key bits. It is still vulnerable to <a href="https://en.wikipedia.org/wiki/Meet-in-the-middle_attack" target="_blank" rel="noopener">meet-in-the-middle attack</a>, but the attack requires 22 × 56 steps.</p>
<p>Keying option 2(abandon)</p>
<p>K1 and K2 are independent, and K3 = K1. Sometimes known as 2TDEA<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-NIST57r4-13" target="_blank" rel="noopener">[13]</a> or double-length keys.<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-cryptography_world-14" target="_blank" rel="noopener">[14]</a></p>
<p>This provides a shorter key length of 112 bits and a reasonable compromise between DES and Keying option 1, with the same caveat as above.<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-15" target="_blank" rel="noopener">[15]</a> This is an improvement over “double DES” which only requires 256 steps to attack. NIST has deprecated this option.<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-NIST57r4-13" target="_blank" rel="noopener">[13]</a></p>
<p>Keying option 3(abandon)</p>
<p>All three keys are identical, i.e. K1 = K2 = K3.</p>
<p>This is backward compatible with DES, since two operations cancel out. ISO/IEC 18033-3 never allowed this option, and NIST no longer allows K1 = K2 or K2 = K3.<a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-NIST57r4-13" target="_blank" rel="noopener">[13]</a><a href="https://en.wikipedia.org/wiki/Triple_DES#cite_note-NIST67r2-11" target="_blank" rel="noopener">[11]</a></p>
<p>We can also use meet-in-the-middle-attack in 3-DES, and its complexity is:<br>$$<br>O(2^{k}+2^{2k})=O(2^{2k}),;k;is;the;length;of;each;key<br>$$</p>
<h1 id="Section-Eleven"><a href="#Section-Eleven" class="headerlink" title="Section Eleven"></a>Section Eleven</h1><p>Euclidean Algorithm, Euler Phi and Euler theorem.</p>
<h1 id="Section-Twelve"><a href="#Section-Twelve" class="headerlink" title="Section Twelve"></a>Section Twelve</h1><h2 id="Introduction-to-Public-Key"><a href="#Introduction-to-Public-Key" class="headerlink" title="Introduction to Public Key"></a>Introduction to Public Key</h2><p>some fact:</p>
<ul>
<li>Invented in 1977</li>
<li>the most popular Public Key Cryptosystem</li>
</ul>
<h2 id="RSA-Algorithm"><a href="#RSA-Algorithm" class="headerlink" title="RSA Algorithm"></a>RSA Algorithm</h2><h3 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h3><p>Unlike symmetric algorithm, public key require the computation of the pair:<br>$$<br>(K_{pub},;K_{pr})<br>$$</p>
<p>Step:</p>
<ul>
<li>Choose two large prime number p, q</li>
<li>n = p * q</li>
<li>phi(n) = (p - 1) * (q - 1)</li>
<li>choose K_pub = e in {1, 2, …, phi(n)}, and gcd(e, phi(n)) = 1</li>
<li>d = inverse(e, phi(n))</li>
</ul>
<p>Then we got:<br>$$<br>K_{pub}=(n,;e),;K_{pr}=(d)<br>$$</p>
<h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><h2 id="Decryption"><a href="#Decryption" class="headerlink" title="Decryption"></a>Decryption</h2><h2 id="Fast-Exponential-Methods"><a href="#Fast-Exponential-Methods" class="headerlink" title="Fast Exponential Methods"></a>Fast Exponential Methods</h2><h3 id="Square-and-Multiply-Algorithm-快速幂算法"><a href="#Square-and-Multiply-Algorithm-快速幂算法" class="headerlink" title="Square-and-Multiply Algorithm(快速幂算法)"></a>Square-and-Multiply Algorithm(快速幂算法)</h3><p>step:</p>
<ul>
<li>scan the exponent bits left-to-right, in every iteration we SQUARE</li>
<li>if current bit is one, we MULTIPLY by x</li>
</ul>
<h1 id="Section-Thirteen"><a href="#Section-Thirteen" class="headerlink" title="Section Thirteen"></a>Section Thirteen</h1><h2 id="Diffle-Hellman-Exchange-Key"><a href="#Diffle-Hellman-Exchange-Key" class="headerlink" title="Diffle-Hellman Exchange Key"></a>Diffle-Hellman Exchange Key</h2><p><a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#General_overview" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#General_overview</a></p>
<h2 id="Finite-Group"><a href="#Finite-Group" class="headerlink" title="Finite Group"></a>Finite Group</h2><p>…<br>$$<br>Z_9={0,;1,;…,;8}<br>$$<br>Is Z_9 a group?</p>
<p>operation: a = a ^ b mod 9</p>
<p>Due to the inverse, we need to kick out the integer that is not coprime with 9. So now we have:<br>$$<br>Z_{9}^{*};=;{1,;2,;4,;5,;7,;8}<br>$$<br>as a multiplicative group.</p>
<h2 id="Cyclic-Group"><a href="#Cyclic-Group" class="headerlink" title="Cyclic Group"></a>Cyclic Group</h2><ul>
<li>Element of group is called “Cardinality” or “order” of the group, which can be written as:</li>
</ul>
<p>$$<br>|G|<br>$$</p>
<ul>
<li>An order of an element in the group is:</li>
</ul>
<p><strong>Deﬁnition 8.2.3 Order of Elements</strong> </p>
<p>Order of an element The order ord(a) of an element a of a group (G,◦) is the smallest positive integer k such that:<br>$$<br>a^k=a;\circ;a;\circ;…;\circ;a;=1,;k;times<br>$$<br><strong>Deﬁnition 8.2.4 Cyclic Group</strong> </p>
<p>A group G which contains an element α with maximum order ord( α )=|G| is said to be cyclic. Elements with maximum order are called <strong>primitive elements or generators</strong>. where 1 is the identity element of G.</p>
<p><em>One of the parameters in diffle hellman exchange key theory α comes from Cyclic group ‘s α .</em></p>
<p>*<em>Cyclic groups are the basis of the discrete logarithm cryptology systems. *</em></p>
<p><strong>Theorem 8.2.2</strong></p>
<p>For every prime p:<br>$$<br>(Z_{p}^{*},;·)<br>$$<br>is an abelian finite cyclic group.</p>
<p><strong>Important properties of cyclic groups:</strong></p>
<p>$$<br>Let;a\in;G,;G;is;a;cyclic;group:\<br>1.;a^{|G|};=1\<br>2.;ord(a);divides;|G|<br>$$<br>The first properties can be related to fermat’s little theorem.</p>
<p><em>Discrete Logarithm difficult problem(DLP) is that:</em><br>$$<br>Calculate;c,;in;;(a\equiv;b^{c}\mod;n),;if;a,;b;is;known<br>$$</p>
<h1 id="Section-Fourteen"><a href="#Section-Fourteen" class="headerlink" title="Section Fourteen"></a>Section Fourteen</h1><h2 id="DLP-Discrete-Logarithm-Problem"><a href="#DLP-Discrete-Logarithm-Problem" class="headerlink" title="DLP(Discrete Logarithm Problem)"></a>DLP(Discrete Logarithm Problem)</h2><p><strong>Definition of DLP</strong><br>$$<br>Given;p,;\beta\in\Z_{p}^{<em>},;primitive;element;\alpha,\<br>find;x,s.t:\<br>\alpha^{x}\equiv;\beta\mod;p<br>$$<br>*It is really difficult to find x, if p is pretty large.</em></p>
<h2 id="GDLP-Generalized-Discrete-Logarithm-Problem"><a href="#GDLP-Generalized-Discrete-Logarithm-Problem" class="headerlink" title="GDLP(Generalized Discrete Logarithm Problem)"></a>GDLP(Generalized Discrete Logarithm Problem)</h2><p>One powerful feature of the DL: Not restricted to Z_{p}^{*} but other cyclic groups can also be used for building DL crypto system.</p>
<p><strong>Note that</strong></p>
<p>A cyclic group can be expressed like:<br>$$<br>G;={\alpha,;\alpha^{2},;\alpha^{3},;…,;\alpha^{|G|}=1}\<br>\alpha;is;a;primitive;element<br>$$</p>
<p>GDLP is the generalized DLP problem(the operation).</p>
<p><strong>Which cyclic groups make good DL problems?</strong> </p>
<ul>
<li>Multiplicative group of  a prime field (GF)</li>
<li>extension field  (GF)</li>
<li>Elliptic Curves: The group consists of points on a curve</li>
<li>Generalizations of 37, e.g, hyper-elliptic curve</li>
</ul>
<h2 id="Attack-Methods"><a href="#Attack-Methods" class="headerlink" title="Attack Methods"></a>Attack Methods</h2><h3 id="Brute-force-Attack"><a href="#Brute-force-Attack" class="headerlink" title="Brute-force Attack"></a>Brute-force Attack</h3><p>condition:</p>
<p>the exponent is pretty small</p>
<p>step:</p>
<ul>
<li>search from (1 - |G|) </li>
</ul>
<p>complexity:<br>$$<br>O(|G|)<br>$$</p>
<h3 id="Square-Root-Attack"><a href="#Square-Root-Attack" class="headerlink" title="Square-Root Attack"></a>Square-Root Attack</h3><p>The methods below all are called <strong>square-root attack</strong>. Square-root attacks work in any group. For elliptic curves, they are the best known attack. We can break 80 bits |G| on our laptop.</p>
<p>In practice, |G| is large than 160 bits in groups of Elliptic Curves.</p>
<h3 id="Baby-Step-Giant-Step-Algorithm-Generic-Method-For-all-DLP"><a href="#Baby-Step-Giant-Step-Algorithm-Generic-Method-For-all-DLP" class="headerlink" title="Baby-Step Giant-Step Algorithm(Generic Method For all DLP)"></a>Baby-Step Giant-Step Algorithm(Generic Method For all DLP)</h3><p>#### </p>
<h3 id="Pollard’s-rho-Method-Generic-Method-For-all-DLP"><a href="#Pollard’s-rho-Method-Generic-Method-For-all-DLP" class="headerlink" title="Pollard’s-rho Method(Generic Method For all DLP)"></a>Pollard’s-rho Method(Generic Method For all DLP)</h3><p>#### </p>
<h3 id="Pohlig-Hellman-Algorithm"><a href="#Pohlig-Hellman-Algorithm" class="headerlink" title="Pohlig-Hellman Algorithm"></a>Pohlig-Hellman Algorithm</h3><p>#### </p>
<h3 id="Index-Calculus-Attack"><a href="#Index-Calculus-Attack" class="headerlink" title="Index-Calculus Attack"></a>Index-Calculus Attack</h3><p>For certain groups the more powerful index-calculus attack exists in particular, the attack works in the <strong>prime field and extension field</strong>. We can break 160 bits p on our laptop.</p>
<p>In practice, p is large than 1024 bits in groups of prime fields.</p>
<p><strong>Attack above remain to be realised</strong></p>
<h1 id="Section-Fifteen"><a href="#Section-Fifteen" class="headerlink" title="Section Fifteen"></a>Section Fifteen</h1><p>What can we do with public key algorithm?</p>
<table>
<thead>
<tr>
<th>service</th>
<th>Integer factor</th>
<th>DL</th>
<th>Elliptic Curve</th>
</tr>
</thead>
<tbody><tr>
<td>key exchange</td>
<td>RSA</td>
<td>D-H</td>
<td>ECDH</td>
</tr>
<tr>
<td>digital sign</td>
<td>RSA</td>
<td>Elgamal/DSA</td>
<td>ECDSA</td>
</tr>
<tr>
<td>encryption</td>
<td>RSA</td>
<td>Elgamal</td>
<td>ECElgamal</td>
</tr>
</tbody></table>
<h2 id="Elgamal-Encryption"><a href="#Elgamal-Encryption" class="headerlink" title="Elgamal Encryption"></a>Elgamal Encryption</h2><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200602160043475.png" alt="image-20200602160043475"></p>
<p>Note that:</p>
<ul>
<li><strong>The cipher text consists of two parts,the ephemeral key, k_E,and the masked plaintext, y. Since in general all parameters have a bit length of [log2 p], the cipher text (kE,y) is twice as long as the message.</strong></li>
<li><strong>Elgamal is a probabilistic encryption scheme.  Encrypting two identical messages x1 and x2, using the same public key results in two different cipher texts y1 != y2. This is because i is chosen at random from {2,3,···,p−2} for each encryption, and thus also the session key k_M = β^i used for encryption is chosen at random for each encryption. In this way a brute-force search for x is avoided a priori.</strong></li>
</ul>
<h2 id="Attacks"><a href="#Attacks" class="headerlink" title="Attacks"></a>Attacks</h2><h3 id="Compute-DLP"><a href="#Compute-DLP" class="headerlink" title="Compute DLP"></a>Compute DLP</h3><p>Try to compute i or d.</p>
<p>However, DLP problem is usually difficult problem is p is very large(p~=2^1024).</p>
<h3 id="Re-use-of-secret-exponent-i"><a href="#Re-use-of-secret-exponent-i" class="headerlink" title="Re-use of secret exponent i"></a>Re-use of secret exponent i</h3><p>If the same i is used in many times, and one of  the plaintext i known, we can use re-use of secret exponent i attack.</p>
<p><em>It can be observed from k_E if i has been re-used.</em></p>
<h1 id="Section-Sixteen"><a href="#Section-Sixteen" class="headerlink" title="Section Sixteen"></a>Section Sixteen</h1><h2 id="Introduction-to-Elliptic-Curve"><a href="#Introduction-to-Elliptic-Curve" class="headerlink" title="Introduction to Elliptic Curve"></a>Introduction to Elliptic Curve</h2><p>ECC is based on the generalized discrete logarithm problem, and thus DL-protocols such as the Difﬁe–Hellman key exchange  can also be realized using elliptic curves. ECC provides the same level of security as RSA or discrete logarithm systems with considerably shorter operands (approximately 160–256 bit vs. 1024–3072 bit).</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702203258501.png" alt="image-20200702203258501"></p>
<h2 id="Group-Operations"><a href="#Group-Operations" class="headerlink" title="Group Operations"></a>Group Operations</h2><p>For this geometric interpretation, we have to distinguish two cases: <strong>the addition of two distinct points</strong> (named point addition) and <strong>the addition of one point to itself</strong> (named point doubling). </p>
<h3 id="Point-Addition-P-Q"><a href="#Point-Addition-P-Q" class="headerlink" title="Point Addition P+Q"></a>Point Addition P+Q</h3><p><strong>Draw a line through P and Q</strong> and obtain a third point of intersection between the elliptic curve and the line. <strong>Mirror</strong> this third intersection point along the x-axis. This mirrored point is, by deﬁnition, the point R. </p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702204925433.png" alt="image-20200702204925433"></p>
<h3 id="PointDoubling-P-P"><a href="#PointDoubling-P-P" class="headerlink" title="PointDoubling P+P"></a>PointDoubling P+P</h3><p><strong>Draw the tangent line through P</strong> and obtain a second point of intersection between this line and the elliptic curve. We <strong>mirror</strong> the point of the second intersection along the x-axis. This mirrored point is the result R of the doubling.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702205145737.png" alt="image-20200702205145737"></p>
<h3 id="Formula"><a href="#Formula" class="headerlink" title="Formula"></a>Formula</h3><p>However, by applying simple coordinate geometry, we can express both of the geometric constructions from above through analytic expressions, i.e., formula.</p>
<p>As stated above, these formula only involve the four basic algebraic operations.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702205705651.png" alt="image-20200702205705651"></p>
<p>Note that the parameter s is the slope of the line through P and Q in the case of point addition, or the slope of the tangent through P in the case of point doubling.</p>
<h3 id="Inverse-of-p"><a href="#Inverse-of-p" class="headerlink" title="Inverse of p"></a>Inverse of p</h3><p>The question is how do we ﬁnd −P? If we apply the <strong>tangent-and-chord*</strong>(confused) method from above, it turns out that the inverse of the point P =( xp,yp) is the point−P=( xp,−yp), i.e., the point that is reﬂected along the x-axis. </p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702211453433.png" alt="image-20200702211453433"></p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200702212332120.png" alt="image-20200702212332120"></p>
<h1 id="Section-Seventeen"><a href="#Section-Seventeen" class="headerlink" title="Section Seventeen"></a>Section Seventeen</h1><h2 id="ECDLP"><a href="#ECDLP" class="headerlink" title="ECDLP"></a>ECDLP</h2><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703071739813.png" alt="image-20200703071739813"></p>
<p> In particular, we know that by deﬁnition a primitive element must exist such that its powers generate the entire group. Moreover, we know quite well how to build cryptosystems from cyclic groups.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703071550092.png" alt="image-20200703071550092"></p>
<p>We obtain immediately a discrete logarithm problem.</p>
<h3 id="Hasse’s-Theorem"><a href="#Hasse’s-Theorem" class="headerlink" title="Hasse’s Theorem"></a>Hasse’s Theorem</h3><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703072338111.png" alt="image-20200703072338111"></p>
<p>Hasse’s theorem, which is also known as Hasse’s bound, states that the number of points is <strong>roughly</strong> in the range of the prime p. #E is called the <strong>cardinality</strong> of the group.</p>
<p><em>In practice, one needs the exact number of points in order to apply certain attack. and finding #E exactly is computationally difficult.</em></p>
<h3 id="Definition-of-ECDLP"><a href="#Definition-of-ECDLP" class="headerlink" title="Definition of ECDLP"></a>Definition of ECDLP</h3><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703072638234.png" alt="image-20200703072638234"></p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703163058470.png" alt="image-20200703163058470"></p>
<p>how hard is ECDLP?</p>
<p>If the EC is chosen carefully, the best known algorithm for computing the ECDLP requires:<br>$$<br>\sqrt{p}<br>$$<br>steps.</p>
<h2 id="ECDH"><a href="#ECDH" class="headerlink" title="ECDH"></a>ECDH</h2><h3 id="Domain-Parameters"><a href="#Domain-Parameters" class="headerlink" title="Domain Parameters"></a>Domain Parameters</h3><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703172346801.png" alt="image-20200703172346801"></p>
<p>Domain parameters should be shared to each other safely before key exchange. </p>
<h3 id="Exchange-Process"><a href="#Exchange-Process" class="headerlink" title="Exchange Process"></a>Exchange Process</h3><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703193129129.png" alt="image-20200703193129129"></p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200703193323136.png" alt="image-20200703193323136"></p>
<h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>If the elliptic curve is chosen with care, the best known attacks against the ECDLP are considerably weaker than the best algorithms for solving the DL problem modulo p, and the best factoring algorithms which are used for RSA attacks. In particular, the <strong>index-calculus algorithms</strong>, which are powerful attacks against the DLP modulo p, <strong>are not applicable</strong> against elliptic curves. For carefully selected elliptic curves, the only remaining attacks are generic DL algorithms, that is <strong>Shanks’ baby-step giant-step method</strong> and <strong>Pollard’s rho method</strong>.</p>
<h1 id="Section-Eighteen"><a href="#Section-Eighteen" class="headerlink" title="Section Eighteen"></a>Section Eighteen</h1><h2 id="Introduction-of-Digital-Signature"><a href="#Introduction-of-Digital-Signature" class="headerlink" title="Introduction of Digital Signature"></a>Introduction of Digital Signature</h2><p>A generic digital signature protocol is below, consisting two function: <strong>signing function</strong> and <strong>verifying function</strong>.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707094056911.png" alt="image-20200707094056911"></p>
<p>Each of the three popular public-key algorithm families, namely integer factorization, discrete logarithms and elliptic curves, allows us to construct digital signatures. </p>
<h2 id="Security-Services"><a href="#Security-Services" class="headerlink" title="Security Services"></a>Security Services</h2><p>The objectives of a security systems are called security services.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707094447258.png" alt="image-20200707094447258"></p>
<p><strong>Remember:</strong></p>
<ul>
<li>Different applications call for different sets of security services. </li>
</ul>
<p>Below are additional security services.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707095144887.png" alt="image-20200707095144887"></p>
<h2 id="RSA-Digital-Signature"><a href="#RSA-Digital-Signature" class="headerlink" title="RSA Digital Signature"></a>RSA Digital Signature</h2><h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><p>Key prepare:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707101738465.png" alt="image-20200707101738465"></p>
<p>The process of RSA digital signature:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707101800924.png" alt="image-20200707101800924"></p>
<p>If x’ == x, two things are confirmed:</p>
<ul>
<li>Message Authentication(It’s Bob who signed the signature)</li>
<li>Message Integrity(Message hasn’t been modified in transit)</li>
</ul>
<p><strong>Attention:</strong></p>
<p>e is supposed to be small.  Since in many practical scenarios, a message is signed only once but veriﬁed many times, the fact that veriﬁcation is very fast is helpful.</p>
<p>An example is that  certiﬁcates are signed only once but are veriﬁed over and over again every time a user uses his asymmetric keys .</p>
<h3 id="Security-1"><a href="#Security-1" class="headerlink" title="Security"></a>Security</h3><p>If an attacker succeeds in providing the veriﬁer with an incorrect public key that supposedly belongs to the signer, the attacker can obviously sign messages.</p>
<h4 id="Algorithmic-Attacks"><a href="#Algorithmic-Attacks" class="headerlink" title="Algorithmic Attacks"></a>Algorithmic Attacks</h4><p>Factorize the modulus n.</p>
<h4 id="Existential-Forgery"><a href="#Existential-Forgery" class="headerlink" title="Existential Forgery"></a>Existential Forgery</h4><p> The attacker chooses the signature ﬁrst and then computes the message. As a consequence, he <strong>cannot control</strong> the semantics of the message x.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707142931905.png" alt="image-20200707142931905"></p>
<p>Nevertheless, the fact that an automated veriﬁcation process does not recognize the forgery is certainly not a desirable feature. For this reason, schoolbook RSA signature is <strong>rarely used in practice</strong>, and <strong>padding schemes</strong> are applied in order to prevent this and other attacks.</p>
<h3 id="Padding-Scheme"><a href="#Padding-Scheme" class="headerlink" title="Padding Scheme"></a>Padding Scheme</h3><p>Roughly speaking, formatting imposes a rule which allows the veriﬁer, Alice in our examples, to distinguish between valid and invalid messages; this is called padding. </p>
<h4 id="The-Probabilistic-Signature-Standard-PSS"><a href="#The-Probabilistic-Signature-Standard-PSS" class="headerlink" title="The Probabilistic Signature Standard (PSS)"></a>The Probabilistic Signature Standard (PSS)</h4><p>Almost always in practice, the message itself is not signed directly but rather the hashed version of it. Hash functions compute a digital ﬁngerprint of messages. The ﬁngerprint has a ﬁxed length, say 160 or 256 bit, but accepts messages as inputs of arbitrary lengths. </p>
<p>The encoding procedure in PSS is known as <strong>Encoding Method for Signature with Appendix (EMSA)</strong> Probabilistic Signature Scheme (PSS).</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707144348273.png" alt="image-20200707144348273"></p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707145725646.png" alt="image-20200707145725646"></p>
<p>The entire padding/encoding procedure:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707145200665.png" alt="image-20200707145200665"></p>
<h1 id="Section-Nineteen"><a href="#Section-Nineteen" class="headerlink" title="Section Nineteen"></a>Section Nineteen</h1><h2 id="Elgamal-Digital-Signature"><a href="#Elgamal-Digital-Signature" class="headerlink" title="Elgamal Digital Signature"></a>Elgamal Digital Signature</h2><h3 id="Scheme-1"><a href="#Scheme-1" class="headerlink" title="Scheme"></a>Scheme</h3><p>Key prepare:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707162423222.png" alt="image-20200707162423222"></p>
<p>Signature Generation:</p>
<p>There are two necessary inputs in signature function: private key d and ephemeral key k_E.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707163458056.png" alt="image-20200707163458056"></p>
<p>Signature Verification:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707165158860.png" alt="image-20200707165158860"></p>
<h3 id="Security-2"><a href="#Security-2" class="headerlink" title="Security"></a>Security</h3><h4 id="Computing-Discrete-Logarithms"><a href="#Computing-Discrete-Logarithms" class="headerlink" title="Computing Discrete Logarithms"></a>Computing Discrete Logarithms</h4><p>####</p>
<h4 id="Reuse-of-the-Ephemeral-Key"><a href="#Reuse-of-the-Ephemeral-Key" class="headerlink" title="Reuse of the Ephemeral Key"></a>Reuse of the Ephemeral Key</h4><p>If the signer reuses the ephemeral key k_E, an attacker can easily compute the private key a.</p>
<p>First, we can get two equations below since K_E has been reused:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707202010523.png" alt="image-20200707202010523"></p>
<p>Next:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707202029216.png" alt="image-20200707202029216"></p>
<p>Then we can retrieve K_E:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707202126423.png" alt="image-20200707202126423"></p>
<p>Finally:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707202220122.png" alt="image-20200707202220122"></p>
<p>With the knowledge of the private key d and the public key parameters, Oscar can now freely sign any documents on Bob’s behalf. </p>
<p><strong>Attention:</strong></p>
<ul>
<li>In order to avoid the attack, fresh ephemeral keys stemming from a random number generator should be used for every digital signature. </li>
</ul>
<h4 id="Existential-Forgery-Attack"><a href="#Existential-Forgery-Attack" class="headerlink" title="Existential Forgery Attack"></a>Existential Forgery Attack</h4><p>Similar to the case of RSA digital signatures, it is also possible that an attacker generates a valid signature for a random message x.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707214755708.png" alt="image-20200707214755708"></p>
<p>The attacker computes in Step 3 the message x, the semantics of which he cannot control. Thus, Oscar can only compute valid signatures for pseudo-random messages. </p>
<p>Attention:</p>
<ul>
<li>The attack is not possible if the message is hashed, which is, in practice, very often the case.</li>
<li>In practice, one applies a hash function to the message prior to signing. Because hash function is irreversible,  it is  difficult to forge a fake x.</li>
</ul>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200707215309859.png" alt="image-20200707215309859"></p>
<h2 id="Digital-Signature-Algorithm-DSA-—-Federal-Standard"><a href="#Digital-Signature-Algorithm-DSA-—-Federal-Standard" class="headerlink" title="Digital Signature Algorithm(DSA) —- Federal Standard"></a>Digital Signature Algorithm(DSA) —- Federal Standard</h2><p>The native Elgamal signature algorithm described in this section is rarely used in practice. Instead, a much more popular variant is used, known as the Digital Signature Algorithm (DSA).  </p>
<h3 id="DSA-Procedure"><a href="#DSA-Procedure" class="headerlink" title="DSA Procedure"></a>DSA Procedure</h3><p>Key prepare:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709054858219.png" alt="image-20200709054858219"></p>
<p><strong>Attention:</strong></p>
<ul>
<li>Beta is public key</li>
</ul>
<p>Signature Generation:</p>
<p>As in the Elgamal signature scheme, the DSA signature consists of a pair of integers (r,s).</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709055512361.png" alt="image-20200709055512361"></p>
<p>According to the standard,the message x has to be hashed using the hash function SHA-1, for example, in order to compute s.</p>
<p>Signature Verification:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709060156220.png" alt="image-20200709060156220"></p>
<p>Proof:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709062247396.png" alt="image-20200709062247396"></p>
<h3 id="Computational-Aspects"><a href="#Computational-Aspects" class="headerlink" title="Computational Aspects"></a>Computational Aspects</h3><p>Key generation method:</p>
<p>Note that NIST is slightly different.</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709063302846.png" alt="image-20200709063302846"></p>
<h3 id="Security-3"><a href="#Security-3" class="headerlink" title="Security"></a>Security</h3><h4 id="DLP"><a href="#DLP" class="headerlink" title="DLP"></a>DLP</h4><p>An interesting aspect of DSA is that we have to protect against two different discrete logarithm attacks. </p>
<p>If an attacker wants to break DSA, he could attempt to compute the private key d by solving the discrete logarithm in the large cyclic group modulo p. The most powerful method for this is the index calculus attack.</p>
<p>The second discrete logarithm attack on DSA is to exploit the fact that α generates only a small subgroup of order q.  .The best he can do is to perform one of the generic DLP attacks, i.e., either the baby-step giant-step method or Pollard’s rho method.</p>
<h4 id="Reuse-ephemeral-key-k"><a href="#Reuse-ephemeral-key-k" class="headerlink" title="Reuse ephemeral key k"></a>Reuse ephemeral key k</h4><p>In addition to discrete logarithm attacks, DSA becomes vulnerable if the ephemeral key is reused. This attack is completely analogues to the case of Elgamal digital signature. Hence, it must be assured that a fresh randomly-genererated key kE is used in every signing operation.</p>
<p>Standardized parameter bit lengths and security levels for DSA</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>Hash output</th>
<th>Security levels</th>
</tr>
</thead>
<tbody><tr>
<td>1024</td>
<td>160</td>
<td>160</td>
<td>80</td>
</tr>
<tr>
<td>2048</td>
<td>224</td>
<td>224</td>
<td>112</td>
</tr>
<tr>
<td>3072</td>
<td>256</td>
<td>256</td>
<td>128</td>
</tr>
</tbody></table>
<h2 id="The-Elliptic-Curve-Digital-Signature-Algorithm-ECDSA"><a href="#The-Elliptic-Curve-Digital-Signature-Algorithm-ECDSA" class="headerlink" title="The Elliptic Curve Digital Signature Algorithm (ECDSA)"></a>The Elliptic Curve Digital Signature Algorithm (ECDSA)</h2><p>In particular, in absence of strong attacks against elliptic curve cryptosystems (ECC), bit lengths in the range of 160–256 bit can be chosen which provide security equivalent to 1024–3072-bit RSA and DL schemes. The shorter bit length of ECC often results in shorter processing time and in shorter signatures.</p>
<p>The ECDSA standard is deﬁned for elliptic curves over prime ﬁelds Zp and Galois ﬁelds GF(2m). </p>
<h3 id="ECDSA-Procedure"><a href="#ECDSA-Procedure" class="headerlink" title="ECDSA Procedure"></a>ECDSA Procedure</h3><p>Key preparation:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709072746163.png" alt="image-20200709072746163"></p>
<p><strong>Attention:</strong></p>
<ul>
<li>Similar to DSA, the cyclic group has an order q which should have a size of at least 160 bit or more for higher security levels.</li>
</ul>
<p>Signature generation</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709091510748.png" alt="image-20200709091510748"></p>
<p>In step 3 the x-coordinate of the point R is assigned to the variable r.</p>
<p>Signature verification:</p>
<p><img src="C:/Users/Buki/AppData/Roaming/Typora/typora-user-images/image-20200709105543951.png" alt="image-20200709105543951"></p>
<h3 id="Security-4"><a href="#Security-4" class="headerlink" title="Security"></a>Security</h3><h4 id="DLP-1"><a href="#DLP-1" class="headerlink" title="DLP"></a>DLP</h4><p>Given that the elliptic curve parameters are chosen correctly, the main analytical attack against ECDSA attempts to solve the elliptic curve discrete logarithm problem. If an attacker were capable of doing this, he could compute the private key d and/or the ephemeral key.</p>
<p>The most effective way is square-root method.</p>
<h4 id="Reuse-ephemeral-key-K-E"><a href="#Reuse-ephemeral-key-K-E" class="headerlink" title="Reuse ephemeral key K_E"></a>Reuse ephemeral key K_E</h4><p>####</p>
<p>Bit lengths and security levels of ECDSA.</p>
<table>
<thead>
<tr>
<th>q</th>
<th>Hash input</th>
<th>Security levels</th>
</tr>
</thead>
<tbody><tr>
<td>192</td>
<td>192</td>
<td>96</td>
</tr>
<tr>
<td>224</td>
<td>224</td>
<td>112</td>
</tr>
<tr>
<td>256</td>
<td>256</td>
<td>128</td>
</tr>
<tr>
<td>384</td>
<td>384</td>
<td>192</td>
</tr>
<tr>
<td>512</td>
<td>512</td>
<td>256</td>
</tr>
</tbody></table>
<p>In addition to the algorithms discussed in this chapter, there exist several other schemes for digital signatures. These include, e.g., the Rabin signature, the Fiat–Shamir signature the Pointcheval–Stern signature and the Schnorr signature. </p>
<h1 id="Lesson-Twenty"><a href="#Lesson-Twenty" class="headerlink" title="Lesson Twenty"></a>Lesson Twenty</h1><p>References:</p>
<ul>
<li><a href="https://www.partow.net/programming/polynomials/index.html" target="_blank" rel="noopener">https://www.partow.net/programming/polynomials/index.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Digital_Signature_Algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Digital_Signature_Algorithm</a></li>
<li>&lt;<understanding of cryptography>&gt;</understanding></li>
<li><a href="https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg" target="_blank" rel="noopener">https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg</a></li>
</ul>

                            <hr>
                        </div>
                        <br>
                        <div>
                            
                            <p>
                                <i class="iconfont icon-tag"></i>
                                
                                    <a class="hover-with-bg" href="/tags/Crypto">Crypto</a>
                                
                            </p>
                            
                                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
                            
                        </div>
                    </div>
                </div>
            </div>
        <div class="d-none d-lg-block col-lg-2 toc-container">
            
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i> Toc:</p> 
    <div id="tocbot"></div>
  </div>

        </div>
    </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
    <div class="container comments mx-auto" id="comments">
        
    </div>
</div>
    
</main>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/0x2e/Material-T" target="_blank" rel="nofollow noopener"> <b>Material-T</b></a>
    <br><br>
    <span id="busuanzi_container_site_pv">
    <b>Reads: </b><span id="busuanzi_value_site_pv"></span><b> times</b><b> | </b><b>Visits: </b><span id="busuanzi_value_site_uv"></span><b> people</b>
    </span><br>
    
  </div>
</footer>

  <!-- SCRIPTS -->
  <script src="/lib/mdbootstrap/js/jquery-3.4.1.min.js"></script>
  <script src="/lib/mdbootstrap/js/popper.min.js"></script>
  <script src="/lib/mdbootstrap/js/bootstrap.min.js?v=4.3.1"></script>
  <script src="/lib/mdbootstrap/js/mdb.min.js?v=4.8.7"></script>
  <script src="/lib/nprogress/nprogress.min.js?v=0.2.0"></script>
  <script src="/js/main.js"></script>
  
    
      <script src="/lib/tocbot/tocbot.min.js?v=4.7.0"></script>
    
    <script src="/js/post.js"></script>
  
  
    <script src="/lib/prettify/prettify.min.js?v=0.1.0"></script>
    <script>
      $(document).ready(function(){
        $('pre').addClass('prettyprint linenums');
        prettyPrint();
      })
    </script>
  
  
    <script src="/lib/typed/typed.min.js?v=2.0.9"></script>
    <script>
        var typed = new Typed('#subtitle', {
          strings: [
            '  ',
            "Introduction_of_Cryptology&nbsp;",
        ],
        cursorChar: "|",
        typeSpeed: 90,
        startDelay: 300, //开始之前延迟300毫秒
        loop: false,
        });
        $(".typed-cursor").addClass("h2");
    </script>
  
  
    <script src="/lib/anchor/anchor.min.js?v=4.2.0"></script>
    <script>
      anchors.options = {
        placement: "left",
        visible: "true",
        
      };
      anchors.add(".post-content > h1,h2,h3");
    </script>
  
</body>
</html>