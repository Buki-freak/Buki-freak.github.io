{"meta":{"title":"buk1","subtitle":"Every day is my last day.","description":"Programming","author":"buki","url":"https://buki-freak.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":true,"path":"links/index.html","permalink":"https://buki-freak.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"tags/index.html","permalink":"https://buki-freak.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-03T03:02:58.465Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"repository/index.html","permalink":"https://buki-freak.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"differential attack learning","slug":"differential-attack-learning","date":"2020-09-10T12:48:14.000Z","updated":"2020-09-11T14:23:56.199Z","comments":true,"path":"2020/09/10/differential-attack-learning/","link":"","permalink":"https://buki-freak.github.io/2020/09/10/differential-attack-learning/","excerpt":"","text":"学习一下差分攻击，最近比赛出现得有点多。 ​ 原理剖析先花个 30 分钟看个视频，看一下差分攻击到底是个啥。英语有点撇脚，勉强听一下。 顺便记录一下 non-generic attack 的分类： ​ linear attack differential attack slide-channel attack related key attack &nbsp; &nbsp; 借个图，虽然有点糊。差分攻击基于选择明文攻击，并且前提是 $\\alpha\\;-\\;\\beta$ 具有 high-probability。解释一下，$\\alpha$ 是一对 明文，或者进入 F function 前中间值的异或值（差值），$\\beta$ 是经过 $r-1$ round F Function 之后的对应的密文对的异或 值。​​ 对于 $\\alpha$， \\alpha\\;=\\;x_1\\;\\oplus\\;x_2​ 对于 $\\beta$， y_1\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_1)\\\\ y_2\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_2)\\\\ \\beta\\;=\\;y_1\\;\\;\\oplus\\;y_2​ ​ 那么 $\\alpha$，$\\beta$ 怎么用呢？我们先假设 $\\alpha$ 和 $\\beta$ 是确定的并具有 high-probability，那么对于一个 n bits 的 key，对于所有可能 的值，我们建立一个表： ​ Potential r-th round Key K0 K1 … Ki Kn-2 Kn-1 Kn Count 0 0 0 0 0 0 0 ​ ​ 对于所有差值为 $\\alpha$ 的明文对，我们用 $K_i$ 计算对应的 $\\beta’$。对于每一个 $K_i$ ，如果产生的差值为 $\\beta$ ，那么 count 自增。最 后 count 为 maximum 的 potential r-th round key 很可能为 real key。 ​ 那么如何找出最佳的 $\\alpha$，$\\beta$ 呢？这里先抛开 potential r-th key，对于每一个可能的 $\\alpha$，$\\beta$，建立一个表格（假设这里取值范围为 0x04）: ​ B/A 0x01 0x02 0x03 0x04 0x01 0 0 0 0 0x02 0 0 0 0 0x03 0 0 0 0 0x04 0 0 0 0 ​ 设 $\\alpha$ 的值为 $\\alpha_i$，对应表格上的每一列，对所有差值为 $\\alpha_i$ 的明文对，计算其 $\\beta$ 值并且在表格上记录出现频率，频率最高的 $\\alpha-\\beta$ 为最佳 characteristic。 ​ ​ 看懂原理之后，跟着 soreatu 大佬复现一波题目。 ​ ​ WMCTF- idiot box​ ​ 题目给出的远程文件。 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import itertoolsfrom binascii import hexlify, unhexlifyimport Crypto.Random.random as randomfrom Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomNBitIntegerfrom secret import flagbanner = '''__ __ _ _ __ ____ __ ____ _____ _____\\ \\ / /__| | ___ ___ _ __ ___ ___ | |_ ___ \\ \\ / / \\/ |/ ___|_ _| ___| \\ \\ /\\ / / _ \\ |/ __/ _ \\| '_ ` _ \\ / _ \\ | __/ _ \\ \\ \\ /\\ / /| |\\/| | | | | | | \\ V V / __/ | (_| (_) | | | | | | __/ | || (_) | \\ V V / | | | | |___ | | | _| \\_/\\_/ \\___|_|\\___\\___/|_| |_| |_|\\___| \\__\\___/ \\_/\\_/ |_| |_|\\____| |_| |_|'''sbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30, 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]keys = []pc_key = [2, 13, 16, 37, 34, 32, 21, 29, 15, 25, 44, 42, 18, 35, 5, 38, 39, 12, 30, 11, 7, 20, 17, 22, 14, 10, 26, 1, 33, 46, 45, 6, 40, 41, 43, 24, 9, 47, 4, 0, 19, 28, 27, 3, 31, 36, 8, 23]def gen_key(): global keys key = getRandomNBitInteger(49) &amp; ((1 &lt;&lt; 48) - 1) key_bin = bin(key)[2:].rjust(48, '0') for i in range(6): key_bin = ''.join([key_bin[pc_key[j]] for j in range(48)]) sub_key = int(key_bin, 2) keys.append(sub_key)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 print(y_bin) return int(y_bin, 2)def F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef enc_block(x): x_bin = bin(x)[2:].rjust(64, '0') l, r = int(x_bin[:32], 2), int(x_bin[32:], 2) for i in range(6): l, r = r, l ^ F(r, keys[i]) y = (l + (r &lt;&lt; 32)) &amp; ((1 &lt;&lt; 64) - 1) return ydef enc(pt): pad_len = (8 - len(pt) % 8) % 8 pt = pt.encode() pt += b'\\x00' * pad_len ct = b'' for i in range(0, len(pt), 8): ct_block = long_to_bytes(enc_block(bytes_to_long(pt[i:i+8]))).rjust(8, b'\\x00') ct += ct_block return ctif __name__ == '__main__': print(banner) gen_key() print(keys) cipher = hexlify(enc(flag)).decode('utf8') print('[++++++++++++++++] FLAG [++++++++++++++++]') print(cipher) print('[+] You have up to 65537 chances to obtain the ct corresponding to the pt your input(&lt;= 64 bits and hex required).') for i in range(65537): pt = input() try: pt = unhexlify(pt) assert(len(pt) &lt;= 8) ct = enc(pt) print(hexlify(ct).decode('utf8')) except: print('[*] Read the above carefully!') break ​ ​ 分析源码，题目给出了是一个自己实现的 DES，测试一下 F Function 的 characteristic： ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from collections import Counterfrom Crypto.Util.number import getRandomNBitIntegersbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [\\ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30,\\ 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]def e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 # print(y_bin) return int(y_bin, 2)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef gen_diff_output(diff): p1 = getRandomNBitInteger(32) p2 = p1 ^ diff key = getRandomNBitInteger(48) c1, c2 = F(p1, key), F(p2, key) return c1^c2, (p1,p2,c1,c2)counter = Counter()for i in range(10000): P_ = 0x00002002 # \\alpha X_, _ = gen_diff_output(P_) counter[X_] += 1X_, freq = counter.most_common(1)[0]print(hex(X_)[2:].rjust(8,'0'), freq / 10000.0) # \\beta, probability# [0x00000000 0x00000000 1.0] # 0 is assure to be output 0# [0x00000002 0x00030005 0.2163]# [0x00000040 0x00000000 0.2554] # seems to be the best# [0x00002000 0x00000000 0.2492]# [0x00002002 0x00030005 0.052] ​ ​ $\\alpha\\;=\\;0x00000040$，$\\beta\\;=\\;0x00000000$ 的 high-probability 比较明显，取一下数据。借了下师傅的代码，Counter 包真好用 😳。 ​ ​ ​ 再抄一幅图，嘿嘿~ 这里我刚开始进入了一个误区，如果遍历所有 potential key 的话，复杂度必大于 $O(2^{48})$，但是如果将 48-bits 的 potential key 分成 8 个 6-bits 的 S-boxes，复杂度可以降到 $10000*O(2^{6+3})$，大概是 $O(2^{22})$，完全没有毛病。 ​ 再贴一个 F Function 的 schedule： ​ ​ ​ DES 的 F Function 流程如下： ​ Expansion D-box : E( ) function XOR - key S-boxes : S( ) function Straight D-box : D( ) function ​ 大概就是一个两边从中间靠的过程，写出来就是 : ​ S(E(T\\_R{'})\\;\\oplus\\;K_i)\\;=\\;D^{-1}(F')\\;=\\;D^{-1}(T\\_L'\\;\\oplus\\;0x00000040)​ 自己写的 exp 就不贴出来了，仔细看了一下大佬的，tql！ ​ References:Breaking DES using Differential Cryptanalysis Case Study: Differetial Cryptanalysis Attack Differential Cryptanalysis ​ 特别致谢： soreatu 大佬","categories":[],"tags":[]},{"title":"强网杯-2020-Review","slug":"强网杯-2020-Review","date":"2020-09-09T00:52:19.000Z","updated":"2020-09-09T01:34:48.306Z","comments":true,"path":"2020/09/09/强网杯-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/09/强网杯-2020-Review/","excerpt":"","text":"baby_crt&nbsp;Infective CRT-RSA，看一下大概的加密流程：&nbsp;&nbsp;&nbsp;在看一下部分参数的设置要求：&nbsp;$N, p, q, e, d$ 常规 RSA 生成。&nbsp;&nbsp;&nbsp;&nbsp;选择两个足够大的素数 $t1, t2$，bit_length 在 $60~80$。题目给出的 $t1, t2$ 过小，存在问题。&nbsp;有几个参数上面没写，补充： d_p\\equiv\\;d\\mod\\;\\varphi(p\\;·\\;t_1)\\\\ d_q\\equiv\\;d\\mod\\;\\varphi(q\\;·\\;t_2)\\\\ d\\;·\\;e_{t_1}\\mod\\;\\varphi(t_1)\\\\ d\\;·\\;e_{t_2}\\mod\\;\\varphi(t_2)&nbsp;&nbsp;继续往下看，看到一点东西了:&nbsp;&nbsp;&nbsp;&nbsp;这里 $c1$ 范围为: 1~2^{16}&nbsp;就这，就这？&nbsp;exp: 123456789101112131415161718import gmpy2e = 65537n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540p,q = 0,0sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246sig_e = pow(sig,e,n)# print(sig_e,n) check passfor i in range(65537): # print(i) # check pass p = gmpy2.gcd(pow(m,i,n) - sig_e,n) if p != 1: print(p) breakq = n // pprint(q)# flag&#123;601cb6f6d990ed5b89cf0de60508a95c07543793&#125; modestudy&nbsp;给的 file 啥玩意儿，环境关了555，以后一定不鸽比赛！","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"gactf-2020-Review","slug":"gactf-2020-Review","date":"2020-09-06T12:09:10.000Z","updated":"2020-09-08T08:24:54.505Z","comments":true,"path":"2020/09/06/gactf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/06/gactf-2020-Review/","excerpt":"","text":"比赛期间打工，所以没怎么看题，回顾一下。&nbsp; da vinci after rsayafu 分解 n 可以得到三个质数，计算 $\\varphi$ 发现 $e | \\varphi$，于是化简：&nbsp;$ e’\\;\\;=\\;\\;e\\;//\\;gcd(e,\\varphi(n))\\;=\\;5\\;,\\;d’\\;=\\;invert(e’,\\varphi(n)) $，得到：$c^{d’}\\;\\equiv\\;m^5\\mod\\;n$ 。&nbsp;看大佬的博客可以用 AMM，自己实现了一遍发现只能求一个根，直接上 sage。&nbsp;&nbsp;1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesimport itertoolsc = 421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151pa = 9749pb = 11237753507624591pc = 9127680453986244150392840833873266696712898279308227257525736684312919750469261# factor with yafumas = GF(pa)(c).nth_root(5, all=True) # find 5-th root in modulus pa, so do belowmbs = GF(pb)(c).nth_root(5, all=True)mcs = GF(pc)(c).nth_root(5, all=True)# algl = True, which means find all roots, otherwise...# all = False is default# find all possible mms = [] for ma, mb, mc in itertools.product(mas, mbs, mcs): m = ZZ(crt(list(map(ZZ,[ma,mb,mc])), [pa,pb,pc])) mi = long_to_bytes(m) if mi[:4] == b'flag': flag = mi[5:-1]# b'weadfa9987_adwd23123_454f' &nbsp;&nbsp;后面是一个斐波那契数列，秘钥是一段乱序的斐波那契数列，加密解密的过程是秘钥和原斐波那契数列的映射关系。这里是把 flag 按照 encryption 中的 key 再加密一遍。&nbsp;&nbsp;123456789101112# decrypt da vinci encryptionfb = [1,1]LEN = len(flag)while len(fb) &lt; LEN: fb.append(fb[-1] + fb[-2])fb[0] = 0enc = [0,28657,2,1,3,17711,5,8,13,21,46368,75025,34,55,89,610,377,144,233,1597,2584,4181,6765,10946,987]r_flag = [flag[fb.index(enc[i])] for i in range(LEN)]for i in r_flag: print(chr(i),end='') # w5aed4fa994f87_dwad3123_2 &nbsp;&nbsp;&nbsp; what_r_the_noise&nbsp;求平均值。。。&nbsp; elgamal_rsa&nbsp;&nbsp;yafu 分解 secret，得到一堆数。。。最高幂的素数为：$653551912583^{15}$ 。&nbsp;ws 分析一波，flag 的长度：$2^{36*8} $ 比最高幂的素数要小，舒服，跟上题一样，走 AMM，但还是要求多个根，学一手。&nbsp;取最高幂的素数为 $n$，$e’\\;=\\;e\\;//\\;gcd(e,\\;\\varphi(n))\\;=\\;2379$ ，$d’\\;=\\;invert(e’,\\;\\varphi(n))$ ，$c’\\;\\equiv\\;c^{d’}\\;\\equiv\\;m^{gcd(e,\\;\\varphi(n))}\\mod\\;n$&nbsp;借了一部分 tb师傅的exp&nbsp;师傅 tql！&nbsp;exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from gmpy2 import gcd, invertfrom Crypto.Util.number import *import randome = 0x1296c = 255310806360822158306697936064463902328816816156848194779397173946813224291656351345682266227949792774097276485816149202739762582969208376195999403112665514848825884325279574067341653685838880693150001066940379902609411551128810484902428845412055387955258568610350610226605230048821754213270699317153844590496606931431733319116866235538921198147193538906156906954406577796507390570080177313707462469835954564824944706687157852157673146976402325057144745208116022973614795377968986322754779469798013426261911408914756488145211933799442123449261969392169406969410065018032795960230701484816708147958190769470879211953704222809883281592308316942052671516609231501663363123562942# factor through yafufac = [(42044128297, 6), (232087313537, 5), (653551912583, 15), (802576647765917, 7), (28079229001363, 14), (104280142799213, 6)]def AMM(q, r, delta, k=1): \"\"\" Adleman-Manders-Miller r-th Root Extraction Algorithm in F_q * Attention: - r and q satisfy r | q - 1 :param q: modulus q --&gt; int :param r: exponent r --&gt; int :param delta: remain --&gt; int :param k: the exponent of k, default is 1 --&gt; int :return: a r-th root of delta \"\"\" phi = pow(q, k-1)*(q-1) mod = pow(q, k) while True: # step1 &amp; step2 rho = random.getrandbits(mod.nbits()) % mod if pow(rho, phi//r, mod) == 1: break # step 3 s = phi t = 0 while s % r == 0: s //= r t += 1 assert(gcd(s, r) == 1) # check if s is coprimed with r assert(pow(r, t) * s == phi) alpha = invert(r, s) a, b, c, h = pow(rho, phi//r, mod), pow(delta, r * alpha-1, mod), pow(rho, s, mod), 1 # step 4 j, k = 0, phi // (r * s) for i in range(1, t): k //= r d = pow(b, k, mod) if d == 1: j = 0 else: j = - discrete_log(phi, d, a) b, h, c = b*(pow(c, r*j, mod)) % mod, h * \\ pow(c, j, mod) % mod, pow(c, r, mod) # step 5 return pow(delta, alpha, mod) * h % moddef allroot(root, r, q, k = 1): # find all roots phi = (q - 1) * q**(k - 1) mod = q ** k all_root = set() all_root.add(root) while len(all_root) &lt; r: new_root = root unity = pow(getRandomRange(2, mod), phi // r, mod) for i in range(r - 1): new_root = (new_root * unity) % mod all_root.add(new_root) return all_root# since 653551912583**15 &gt; 2**(36*8)n0 = 653551912583n = pow(653551912583, 15)phi = n * (653551912583 - 1) // 653551912583e_p = e // gcd(e, phi)d = invert(e_p, phi)c_p = pow(c, d, n)ar = allroot(AMM(n0,2,c_p,15),2,n0,15)for i in ar: print(long_to_bytes(i))# b'you_4re_good_at_b0th_el94mal_and_rs4' &nbsp;不用 AMM 的话，直接上 sage 也可。&nbsp;&nbsp; square&nbsp;平方数求和公式化简成：$6x^{2}\\;=\\;(y\\;+\\;1)(2y\\;+\\;1)$，然后再转换成 pell 方程: $(4y\\;+\\;3)^2\\; -\\; 48x^{2} \\;=\\; 1$。&nbsp;&nbsp;再令 $t\\;=\\;4y\\;+\\;3$，有：$t^2\\;-\\;48x^{2}\\;=\\;1$。爆破走出前四位：$1,\\;7,\\;97,\\;1351$，然后在 oeis 找到递归式: a(m) = 14a(m-1) - a(m-2)&nbsp;找到所有满足 $t,\\;y$ 的pell 方程的解，然后再根据 $t,\\;x$ 的关系求出 $x,\\;y$，oeis 是个好东西。&nbsp;exp 如下：&nbsp;12345678910111213141516171819202122232425262728293031323334353637383940414243444546# We can get something like pell equation: (4*y+3)^2 - 48*x^2 == 1# Write it into t^2 - 48*x^2 == 1\"\"\"for i in range(10000): for j in range(10000): if i ** 2 - 48 * j ** 2 == 1: print(i,j)Output:1 07 197 141351 195Formula: a(m) = 14a(m-1) - a(m-2)\"\"\"import gmpy2a = [1,7,97,1351]x = [1,7,97,1351]y = [0,1,14,195]while len(x) &lt; 120: ta = 14 * a[-1] - a[-2] a.append(ta) if ta % 4 == 3: x.append(ta)for i in range(4,len(x)): y.append(gmpy2.iroot((x[i]**2-1) // 48,2)[0])for i in range(4,120): x[i] = (x[i] - 3) // 4x = x[4:]y = y[4:]for i,j in zip(x,y): print(i,j)# check passfor i,j in zip(x,y): assert((4*i+3)**2 - 48*j**2 == 1) &nbsp;坚持！","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"CISCN2020-初赛-Writeup","slug":"CISCN2020-初赛-Writeup","date":"2020-08-24T07:00:22.000Z","updated":"2020-09-08T12:57:19.202Z","comments":true,"path":"2020/08/24/CISCN2020-初赛-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/08/24/CISCN2020-初赛-Writeup/","excerpt":"","text":"这次比赛难度算是中等，神仙题和简单题参半。。。&nbsp;&nbsp; bd签到题，老 wiener 了，计算 d 的上界大概为 256 bits，题目给的 d 为 200 bits，直接上脚本：&nbsp;&nbsp;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-from gmpy2 import *from Crypto.Util.number import long_to_bytesdef continuedfra(x, y): cF = [] while y: cF += [x / y] x, y = y, x % y return cFdef simplify(ctnf): numerator = 0 denominator = 1 for x in ctnf[::-1]: numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator)def calculatefrac(x, y): cF = continuedfra(x, y) cF = map(simplify, (cF[0:i] for i in range(1, len(cF)))) return cFdef solve_pq(a, b, c): par = isqrt(b * b - 4 * a * c) return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerattack(e, n): for (d, k) in calculatefrac(e, n): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) / k p, q = solve_pq(1, n - phi + 1, n) if p * q == n: return abs(int(p)), abs(int(q)) print('not find!')n = 86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289e = 46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249c = 37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066p, q = wienerattack(e, n)d = invert(e, (p-1)*(q-1))m = pow(c,d,n)print(long_to_bytes(m))#flag&#123;d3752538-90d0-c373-cfef-9247d3e16848&#125; &nbsp;&nbsp;&nbsp; lfsr&nbsp;&nbsp;state 以及 keystream 给出 10000 bits，flag 为 mask。&nbsp;尝试分析不同 cipher 和 output bits 的关系，构建关于 mask GF(2) 下的方程，未果。&nbsp;在网上找到一个类似的题目，是 SJTU-CTF-2019的一道: 题目 :&nbsp;这题只是原题的其中一步。有一个 Berlekamp-Massey Algorithm 算法，用于构造一个最短的 LFSR 以满足给定的二进制输出序列。于是使用给出的 10000 bits中的前 200 bits。Berlekamp-Massey Algorithm ，这玩意儿有现成的在线工具 。 算出最短的 mask，然后去掉首一，转为十进制，正是 flag。&nbsp;&nbsp;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960In [15]: s= s[1:] In [16]: s Out[16]: ['99', '97', '95', '94', '91', '90', '89', '86', '84', '82', '76', '75', '74', '73', '66', '64', '62', '61', '60', '59', '58', '57', '56', '55', '52', '51', '46', '44', '43', '40', '38', '36', '32', '30', '29', '27', '26', '23', '22', '19', '18', '17', '15', '14', '13', '11', '5', '4']In [34]: res Out[34]: '1010110011100101010000011110000001010111111110011000010110010101000101101100110011101110100000110000'In [35]: int(res,2) Out[35]: 856137228707110492246853478448#flag&#123;856137228707110492246853478448&#125; &nbsp;由于当时急急忙忙先把题目做出来了。。现在学习一下原理。&nbsp;&nbsp;&nbsp;Berlekamp-Massy Algorithm 可以根据给出的 keystream， 找出能生成这个keystream 的最短 LFSR/Tap。理论上给出的 keystream 远大于 tap 的长度时，准确度极高。&nbsp;这个算法也可以在任意的 field 中找到线性递归序列的最小多项式。&nbsp;&nbsp;看一下 wiki 的描述：&nbsp;&nbsp;&nbsp;$S_n$ 在这里是 LFSR 的 keystream，$C_n$ 则是 LFSR 的 tap。整条式子的意思是，假设 tap 的长度为 $L$，那么第 $L+1$ 个值与前 $L$ 位产生的 output 的异或值为0。而算法的目的是找到这个长度为 $L$ 的 $C_n$。&nbsp;&nbsp;我们着重看一下 binary field/GF(2) 的基本运算。&nbsp;&nbsp;&nbsp;先回顾一下二进制运算。GF(2) 中 运算 操作 加法/减法 异或 乘法 逻辑与 除法 单位元运算/定义为’x/1=x’ &nbsp;&nbsp;详细看一下算法步骤：&nbsp;&nbsp;有点懵逼啊。。。先留个坑&nbsp; rsa&nbsp;神仙题，听说 32 核几秒 factor success？？？自己尝试了一下发现不太行。。。tcl 等一手 wp&nbsp;&nbsp; Reference&nbsp; https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm&nbsp;&nbsp;","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"RSA-Learning","slug":"RSA-Learning","date":"2020-08-03T13:22:37.000Z","updated":"2020-08-07T09:18:40.543Z","comments":true,"path":"2020/08/03/RSA-Learning/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/RSA-Learning/","excerpt":"","text":"今天看了一篇 RSA 的paper，总结的不错，简单地做下笔记。 RSA 是基于 Factoring Large Integers Problem 的公钥密码体制。 Elementary AttacksCommon Modulus…. Blinding出现在不经 padding 和 check 的 RSA signiture 中，如果签名方不仔细审查明文，攻击者可以伪造某人对于任何内容的签名。 cheat 大致过程如下： 整个过程称为 blinding，是因为 Bob 没能得知他要签名的内容。签名方在签名前检查内容能够防止这个问题。 Low Private Exponent低解密指数攻击。 d 的大小会影响解密的时长。为了速度上的要求，有人会将 d 设置的更小。M.Wiener 提出的攻击方法对很小的 d 的 RSA 系统带来威胁。 Theorem 2(M. Wiener): Proof:证明过程利用连分数。因为 $ed\\;\\equiv\\;1\\mod\\;\\varphi(N)$，所以存在一个 k 满足: $ed\\;-\\;k\\varphi(N)\\;=\\;1$， 因此有： \\left|\\frac{e}{\\varphi(N)}\\;-\\;\\frac{k}{d}\\right|\\;=\\;\\frac{1}{d\\varphi(N)}所以可以把 $\\frac{k}{d}$ 看成是 $\\frac{e}{\\varphi(N)}$ 的大概值。然后因为 $\\varphi(N)\\;=\\;N\\;-\\;p\\;-\\;q\\;+\\;1$ 以及 $p\\;+\\;q\\;-\\;1\\;&lt;\\;3\\sqrt{N}$ 所以有： 计算 $\\frac{e}{N}$ 的连分数，其中有一个解等于 $\\frac{k}{d}$，由于 $ed\\;-\\;k\\varphi(N)\\;=\\;1$，所以 $gcd(k, d)\\;=\\;1$ ，即 $\\frac{k}{d}$ 为真分数。线性时间可以解得 d。 LimitsLarge e:对解密指数进行改进，令 $e’\\;=\\;e\\;+\\;t\\varphi(N), t\\;is\\;large\\;enough$，$e’$ 作为新的加密指数: Using CRT保证 d 的 bit size 的同时，使用 CRT 对解密来提升解密速度。计算： d_p\\;\\equiv\\;d\\;\\mod(p\\;-\\;1)\\\\ d_q\\;\\equiv\\;d\\;\\mod(q\\;-\\;1)并且 $d_q$ 和 $d_p$ 足够小(128 bits each)。然后计算： M_p\\;\\equiv\\;C^{d_p}\\mod\\;p\\\\ M_q\\;\\equiv\\;C^{d_q}\\mod\\;q最后 CRT： \\begin{cases} M\\;\\equiv\\;C^{d_p}\\mod\\;p \\\\\\\\ M\\;\\equiv\\;C^{d_q}\\mod\\;q \\end{cases}$d_p$ 和 $d_q$ 过小会导致 N 容易分解。 Boneh and Durfee 方法可以将上界提到 $d &lt; N^{0.292}$ Low Public Exponent数字签名中，e 的大小会影响验证的计算时长。e 过小会导致低加密指数攻击。 Coppersmith’s TheoremTheorem 3(Coppersmith) Coppersmith 提供了一个快速寻找 $f(x_0)\\;\\equiv\\;0\\;\\mod\\;N$ 根的方法。 Lemma 4 Proof由 Schwarz inequality 可得： \\left|h(x_0)\\right|\\;=\\;\\left|\\sum{a_i}x_{0}^{i}\\right|\\;=\\;\\left|\\sum{a_i}X^{i}(\\frac{x_0}{X})^{i}\\right|\\;\\leq\\;\\sum\\left|a_{i}X^{i}(\\frac{x_0}{X})^i\\right|\\\\ \\leq\\;\\sum\\left|a_{i}X^{i}\\right|\\;\\leq\\;\\sqrt{d}||h(xX)||\\;\\leq\\;N由于 $h(x_0)\\;\\equiv\\;0\\;\\mod\\;N$，所以有 $h(x_0)\\;=\\;0$ 。前提是 h 的范数足够小。 因此，我们需要找到另外一个范数更小的多项式。满足上面的条件。 Coppersmith 提供了一个方法： m 是未知的常量。我们从 $g_{u,v}(x)\\;\\equiv\\;0\\;\\mod\\;N^m$ 中找到符合 $norm(h(xX))\\;&lt;\\;N^m$ 的多项式。m 足够大的时候有多个解。 找到这个合适的多项式需要构造格： Hermite’s bound 说明 $m$ 足够大的时候，可以找到 $ norn(v) &lt; N^m$ 的向量。 Fact 5(LLL) LLL 满足 Lemma 4 的条件： 2^{\\frac{w}{4}}det(L)^{\\frac{1}{w}}\\;","categories":[],"tags":[{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"}]},{"title":"De1ta-CTF-2020-Review","slug":"De1ta-CTF-2020-Review","date":"2020-08-03T03:40:01.862Z","updated":"2020-08-03T07:05:31.815Z","comments":true,"path":"2020/08/03/De1ta-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. nlfsr(unsolved)This challenge consists of 4 linear feedback shift registers (below I use LFSR instead), with accordingly 19 bits, 19 bits, 6 bits and 3 bits state length. Here is the given file: quiz.py 12345678910111213141516171819202122232425262728from flag import a, b, c, d, flagassert flag == \"De1CTF&#123;\" + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \"&#125;\"assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6]ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i &amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ dodef genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\"data\", \"w+\").write(s)genkey(128*1024) data 1a string that comprises of 128*1024*8 bits(only zero or one) ExplanationThere are four LFSR in quiz.py and each round, four LFSR simultaneously compute four according output. Then the combination function combines these four bits and output the combination result into file data. ConditionSince LFSR is the basic knowledge for us, there will more no more explanation on it. So let’s see what we have got from the files. the initial state length of each LFSR the taps of each LFSR a combination function many rounds combination results It seems to be a simple quiz because we have already known the taps of each LFSR. However, each output of four LFSR is combined as one bit, from which we can hardly retrieve the outputs of four LFSR. If we use pure brute-force attack method, the complexity would be: O(2^{47}) Such a large scale. We must relate one or some output of four LFSR to the combination result and solve the each state independently. We can use a strategies called correlation attack in stream cipher. DetailsWe first look into each possible situation of four LFSR and write down the result. ao bo co do combine 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 In the table, ao represents the single output of LFSR-1 and so on. It is very obvious that ao has 75% correlation with the combination output, and we also know that if we have the correct initial state of LFSR-1, three out of four output of LFSR-1 will be the same as the combination bits. As a result, we can independently search the initial state of LFSR-1, and the correct initial state should be the fittest one. Now the complexity comes down to: O(2^{19}+2^{28})=O({2^{28}})This is already considerable in brute-force attack method (I use approximately 3 hours with C++, half a day with python to solve). But sadly, outputs of other LFSR just has 50% correlation with the combination output (actually no correlation). We can look into the combination function: 1(ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do And interestingly it can be transformed into: 1(ao*bo) ^ ((bo^1) * (co^do)) Calculating the XOR result of co and do by ourselves, we can surprisingly find that there is correlation between (co^do) and the combination result. Try to write down the table again. ao bo co^do combine 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 Again we can know from the table that (co^do) has 75% correlation with the combination output, which is the same as ao. There the complexity comes down again to: O(2^{19}+2^{9}+2^{19})=O(2^{20})The complexity is very considerable now. RealizationOfficial realization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf8import timema, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31key = open(\"data\").read()def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def calcR(x, y): assert len(x) == len(y) cnt = 0.0 for i, j in zip(x, y): cnt += (i == j) return cnt / len(x)def brutea(nb): relation, reala = 0, 0 for i in range(0, 2 ** 19): s = '' a = i for j in range(nb * 8): a = lfsr(a, ma) s += str(a &amp; 1) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, reala = r, i print(reala, relation) return realadef brutecd(nb): relation, realc, reald = 0, 0, 0 for i in range(0, 2 ** 6): d = i for j in range(0, 2 ** 13): c = j s = '' for k in range(nb * 8): c = lfsr(c, mc) d = lfsr(d, md) s += str((c &amp; 1) ^ (d &amp; 1)) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, realc, reald = r, j, i print(realc, reald, relation) return realc, realddef bruteb(nb, a_, c_, d_): for i in range(0, 2 ** 19): b = i a, c, d = a_, c_, d_ s = '' for j in range(nb * 8): a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [k &amp; 1 for k in [a, b, c, d]] s += str((ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do) if s == key[:nb * 8]: print(i) return iif __name__ == \"__main__\": start_time = time.time() print(start_time) a = brutea(20) c, d = brutecd(20) b = bruteb(20, a, c, d) \"De1CTF&#123;%s&#125;\" % (''.join([hex(i)[2:] for i in [a, b, c, d]])) end_time = time.time() print(\"Used time:\", end_time - start_time)# De1CTF&#123;58bb578d5611363f&#125; Other challenges still remain confused. What I have doneI spent half of my afternoon writing this article, and I still have a long way to go. Keep on learning IELTS and number theory. Things to Learn and Improve How to use sage Do a review on wangdibei References https://en.wikipedia.org/wiki/Correlation_attack","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"天翼杯-2020-Writeup","slug":"天翼杯-2020-Writeup","date":"2020-07-31T15:00:19.000Z","updated":"2020-08-24T03:28:24.850Z","comments":true,"path":"2020/07/31/天翼杯-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/07/31/天翼杯-2020-Writeup/","excerpt":"","text":"比赛排得很密，gkd 把 writeup 写了。 easyRSA签到题，对于每一次加密，明文空间小，于是直接遍历。 1234567891011121314n = ...cipher = ...import stringe = 11299plaintext = ''for i in range(len(cipher)): for s in string.printable: if pow(ord(s),e,n) == cipher[i]: plaintext += s print(plaintext) break hardRSA已知 d 低 539 位，q 为 510 位，计算低位 q 的方法可以直接获得 q。 12345678910111213141516171819202122232425262728import gmpy2from Crypto.Util.number import long_to_bytesdef find_q(d0, kbits, e, n, p): X = var('X') for k in range(1, e+1): results = solve_mod([e*d0*X - k*(p-1)*X*(n//p-X+1) + (p-1)*k*(n//p) == X], 2^kbits) for x in results: q0 = ZZ(x[0]) if n % q0 == 0: return q0if __name__ == '__main__': n = 12723332779402711330767180202990021139894727917028981722242076998825097254419567024122271773380821224949951558669351311750240296591612098048129709925844660421849429715755474874708286508736369884566273719494870891070006251521469139401722700298201541140391493575314714966432624976434199682124684035067305114749262672684081617896579640435891181745346695293618235303178334371123418790204709073465264408888007492994820133128499094347122686903153588634296508454120927 e = 7 p = 3141886348112988339174865432179206412942588390228169645162293920470188882447855208783220899752887620221059861467348059334030873350571979462363834615231089 c = 8696771272015513736887843395612361647314297287781507609196936354183211655364744684164300710583625473872942712063309507651496314800393009480421886926137403759228421858414833429980059903049311837014449093365911603108158352871851677457256058510822509157407703210866317472894586087554001158540951787167699161720491198674848526093644131709561995379565643716017359731201935855247285498574923656191121426618306186331615280461405913653781283860760013215603007314688132 d0 = 0x414946b9c40728f9801e61e98ec6d17525cbe4163a5ffb8367b65c652ae4cc3abce62e70afbfb84fcf937b3119953b48922be19ef4312c4f3a88313368ca6c9b1d658b7 nbits = n.nbits() kbits = d0.nbits() q = find_q(d0, kbits, e, n, p) r = n // q // p phi = (r - 1) * (p - 1) * (q - 1) d = gmpy2.invert(e,phi) print(long_to_bytes(pow(c,d,n))) 忽略一下推导过程了。。 AliceHomeworkLLL 没跑出来，疑惑.jpg PolyCrypto没时间看题。。。tcl","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"3kctf-2020-Review","slug":"3kctf-2020-Review","date":"2020-07-27T06:21:11.000Z","updated":"2020-08-03T03:26:54.575Z","comments":true,"path":"2020/07/27/3kctf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/","excerpt":"","text":"pyzzle1Given a cst tree code, use libcst package in python to transform it into source code: 123456from libcst import *abc = Module(....)with open('...','w') as f: f.write(str(abc.code)) Here is the source code in python: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import binasciiplaintext = \"REDACTED\"def exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempdef BinaryToDecimal(binary): string = int(binary, 2) return string# encryptionPT_Ascii = [ord(x) for x in plaintext]PT_Bin = [format(y, '08b') for y in PT_Ascii]PT_Bin = \"\".join(PT_Bin)n = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showL1 = PT_Bin[0:n]R1 = PT_Bin[n::]f1 = exor(R1, K1)R2 = exor(f1, L1)L2 = R1f2 = exor(R2, K2)R3 = exor(f2, L2)L3 = R2R3 = '''''' # Too long to showL3 = '''''' # Too long to showcipher = L3+R3# # decryption (redacted)# plaintext = L6+R6# plaintext = int(plaintext, 2)# plaintext = binascii.unhexlify('%x' % plaintext)# print(plaintext) This is a pretty easy structure, we can easily recover plaintext by: 1234567891011121314151617181920212223242526272829import binasciidef exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempn = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showR3 = '''''' # Too long to showL3 = '''''' # Too long to showR2 = L3L2 = exor(exor(K2, R2), R3)R1 = L2L1 = exor(exor(K1, R1), R2)plaintext = L1+R1plaintext = int(plaintext, 2)plaintext = binascii.unhexlify('%x' % plaintext)plaintext = binascii.unhexlify(plaintext)print(plaintext) The flag is : 3k{almost_done_shizzle_up_my_nizzle} Once_upon_a_timeGiven a program and encrypted flag: scss : program entrance main.c cipher.c flag_encrypted … Excellent realization of LFSR and block cipher encryption in C. We notice that the initial vector is fixed, 0xa2 :) Addtionally, the key is fixed too, which means we can always get the same key stream. Moreover, I find something wired in cipher.c: 123case ECB: temp_ciphertext = temp_keystream ^ temp_plaintext; break; We can create a file with only ‘\\x00’ and encrypt it in ECB mode to get the keystream. Since there are five modes, we can only try every situations. Woooool, finally catch ya! OFB! 12345678910In [20]: plaintext = '' In [21]: for i in range(113): ...: iv = iv ^ keystream[i] ...: temp = iv ^ cipher[i] ...: plaintext += chr(temp) ...: In [22]: plaintext Out[22]: '3k&#123;my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail&#125;' The flag is : 3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail} You shall not get my cookiesGiven an example cipher, and if the cipher can be correctly decrypted, it will send “Nop” back. I follow the write up here: https://ctftime.org/writeup/22602 Notice that there is an error in the write up above: if the length of a block is 16 bytes, it will be appended a block of sixteen ‘\\x16’ according to PKCS#7 padding principle. Here is my exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-from pwn import *from Crypto.Util.number import bytes_to_long# context.log_level = 'debug'target = 'youshallnotgetmycookies.3k.ctf.to'port = 13337cipher = \"6F6A6A2C6E780D070A19001707060C0D\"suffix = ''fake_iv = ''dc = ''try: for i in range(1,17): assert(len(dc) == 2*(i-1)) for j in range(0x100): guess = hex(j)[2:].upper().zfill(2) fake_iv = '00' * (16-i) + guess + suffix print('[-]' + fake_iv) p = remote(target, port) p.sendlineafter('So... whats your cookie: ', fake_iv + cipher) res = p.recvall(timeout=4) p.close() res = res.decode() if len(res) == 11: pad = bytes([i]) dc = hex(int(guess, 16) ^ bytes_to_long(pad))[2:].upper().zfill(2) + dc suffix = hex(int(dc, 16) ^ bytes_to_long(bytes([(i+1)]) * i))[2:].upper().zfill(i*2) print('[-] D(C1) '+ dc) break print('[-] D(C1) '+ dc)except pwnlib.exception.PwnlibException: pass# 1C091F451A0B070D00130A1D0D0C0607 for the first block to be d(C2)# B0A608DDC37A458EEC0B74D37E888E8A for the second block# ...3B143145885BB42C94 for the third block# C2# 90C560B2A01529EF986E54B016E1FEAA# C1# 6F6A6A2C6E780D070A19001707060C0D# Calculate d(C1)# 218A7AEECEFB49CADF3D227AD84A21CF# Calculate C0# 6CEB0A82ABDB06ABAB50471BB46A63A6# The whole fake cipher:# 6CEB0A82ABDB06ABAB50471BB46A63A66F6A6A2C6E780D070A19001707060C0D90C560B2A01529EF986E54B016E1FEAA It cost 2 hours running this script twice.","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-First-Half-Review","slug":"2020-First-Half-Review","date":"2020-06-30T15:23:46.000Z","updated":"2020-07-17T02:47:27.086Z","comments":true,"path":"2020/06/30/2020-First-Half-Review/","link":"","permalink":"https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/","excerpt":"","text":"2020 已经过半，新年的钟声仿佛仍然萦绕在耳边。时间过得太快，留下的太少。 回顾今年真的很特别啊，二月份的时候还抱着回学校上课的想法，现在已经上了一学期的网课。对于网课和回学校上课，我是偏后者的。要知道，待在家里学习效率不到学校的十分之一：）不过还好，现在好像慢慢习惯下去了 hhhhh 本来是二月底开学的，不过学校说推迟开学（不带网课的那种）。好吧，等到三月份，盼了许久谁知改成网课（直接裂开&gt;_&lt;，网课==自学。不得不说，这半年处于真·白学阶段，白学能力提高了不少。 一月主要在学了 Matlab 编程和 Latex，从基本语法到画图，再到如何用 Latex 写出一篇 nice 的论文。学这个主要是为了准备数模，不过听说毕业论文要用 Latex 2333。因为寒假前有个朋友拉数模美赛，自己感觉想试试（说不定好好学能拿个奖。于是就报名去了，报名费也不便宜。后面去听了听那边的基础课，建模对数学要求还是挺高的，有点懵。后面朋友说让我学学 Matlab 编程。基础学下来其实也不用花很长时间，但是拖着拖着到二月份去了。不过回想那个时候，自己跟着网上教程走，还是不错的。 美赛在三月份，基础搞好了以后就开始放飞自我了（真就只搞了基础 wdt。其实主要是发现自己太久没搞学科了，于是又跑来这边学学。掏出一个《快乐的 Linux 命令行》，也忘了是谁发给我的了，系统地过一遍 Linux。从文件系统跳转到 vim 处理文本 再到软件包管理，最后 shell 编程，途中顺便捡回了正则表达式。看的时候其实真的有很大感触。看懂命令，提高主动性，这是我悟出的一点。最近选课突然发现下学期有一门叫《操作系统实践》的课，讲得就是 Linux 命令2333 美赛那三天每天只睡了6个小时，负责编程。另外两个大佬建模分析等等（这里的等等省略了许多…… wtcl 代码都是队友帮我找的。当时其实挺自责的，到后两天我才开始发挥作用。最终还是两位大佬带着我一个菜鸡勉强拿了个奖。求下年别再拉我了。 到了三月底就开始上课了，通常第一个星期都是介绍课程，必须要听啊，种种原因。一开始的那几个星期还是很认真的听课的，后面就不忍直视了。school 特色原因，水课很多。这时候网课的优势就凸显出来了。话虽这么说，但是英语还是得好好学。 四月份开始准备学校的新生赛。Crypto 不会出题。于是直接用了上一年校赛的模板，一波三折，最后强行凑出三道题，难度还不小，直接丢到平台，没人做出来 555 大概四月中旬，家里人出事情了，心态有点崩，之后算是勉勉强强地在学习吧。 到了五月份，整个人勤快了，学得挺快。把 Crypto 的基础过了一遍，打下了几场比赛，看了不少paper，收获还是挺大的，可惜没有进到线下。一个队伍，三缺一，加上进线下的种种困难，离目标还是很远啊。 六月份主要在准备各科的考试，全力复习，毕竟还是想混个奖学金。现在想想，不知不觉，已经在家半年。。。希望快快开学。 感想大学已经过去一半，庆幸自己这一年没有浪费，但也很可惜，没有达到自己预期的目标。怎么说呢，自己当初的目标其实已经改变了吧，现实中的变化的太快，而且自己当初的决心似乎也没有那么坚定。走一步看一步吧，毕竟不想浪费这几年宝贵的时间。 展望用某人的话：”少说话，多做事。光说不练假把式，要勤奋，勇于实践。”","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"das-CTF&GK-CTF-2020-Writeup","slug":"das-CTF-GK-CTF-2020-Writeup","date":"2020-05-24T01:30:24.000Z","updated":"2020-08-03T03:26:26.371Z","comments":true,"path":"2020/05/24/das-CTF-GK-CTF-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/","excerpt":"","text":"Only writeup in Crypto. GKCTF小学生的密码学(Solved)Pretty easy affince cipher. Both keys are given. babycrypto(Solved)Partial high bits of p is known. 123456789101112131415161718192021222324# Use sage to run the script# Reference: https://www.jianshu.com/p/1a0e876d5929from sage.all import *from Crypto.Util.number import long_to_bytes# All variables are in hexn = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005# Padding zeros to p --&gt; p4p4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000cipher = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361e2 = 65537kbits = 128 # kbits represent the loss bitsPR.&lt;x&gt; = PolynomialRing(Zmod(n)) # Create a polynomial ringf = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4 + int(roots[0]) assert n % p == 0 q = n / int(p) phin = (p-1)*(q-1) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) print long_to_bytes(flag) 汉字的密码(Solved)当铺密码+Substitution Cipher 123456dic = [66, 74, 62, 67, 118, 83, 72, 77, 86, 55, 71, 57, 82, 57, 64, 63, 51, 107]delta = 1for i in dic: print(chr(i+delta), end=\"\") delta += 1# FLAG&#123;YOU_ARE_GOOD&#125; Backdoor(Unsolved)Remain confused DASCTFbbcrypto(Solved)quiz.py 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=\"\" for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return cif __name__ == \"__main__\": m = 'flag&#123;********************************&#125;' a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(\"明文内容为：\") print(m) print(\"加密后的密文为：\") c=encrypt(m, a, si) print(c) #加密后的密文为： #177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d The length of salt is 3 and we have already known that the plain starts with “flag{“. Solve linear congruent equations to get the salt. 123456789101112131415161718192021222324c = \"177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d\"li_c = [int(c[i:i+2], 16) for i in range(0, len(c), 2)]# print(li_c)m = \"flag&#123;\"d_c = li_c[3] - li_c[0]# print(d_c)d_m = ord(m[3]) - ord(m[0])# print(d_m) # a = 57 mod 128a = 57# print((li_c[0] - a * ord(m[0])) % 128)# print(chr(97)) y1 = 'a'# print((li_c[1] - a * ord(m[1])) % 128)# print(chr(104)) y2 = 'h'# print((li_c[2] - a * ord(m[2])) % 128)# print(chr(104)) # y3 = 'h'# print((li_c[3] - a * ord(m[3])) % 128)m = \"\"from gmpy2 import invertimport itertoolsinv_a = invert(a, 128)key = itertools.cycle(\"ahh\")for i in li_c: m += chr(((i - ord(next(key))) * inv_a) % 128)print(m) encrypt_img(Solved)quiz.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from numpy import arrayfrom PIL import Imagefrom secret import KeyPlaintext1 = \"RC4IsInteresting\"Plaintext2 = \"ThisIsAEasyGame\"cnt = 0class RC4(): def __init__(self, Key): self.S = [i for i in range(256)] # 0 - 255 self.K = [ord(Key[i % len(Key)])*2 for i in range(256)] # KEY * 2(0-255) self.I, self.J = 0, 0 self.KSA() def KSA(self): for i in range(256): j = (i+self.K[i]+self.S[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def next(self): self.I = (self.I+1) % 256 self.J = (self.J+self.S[self.I]) % 256 self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J] tmp = (self.S[self.J] + self.S[self.I]) % 256 return self.S[tmp]class Encrypt(): def __init__(self, plain): global cnt cnt += 1 self.rc4 = RC4(Key) self.testRC4(plain) flag_file = Image.open(r\"flag.png\") img = array(flag_file) self.enc(img) def testRC4(self, plain): ciphertext = 0 for i in plain: ciphertext = (ciphertext &lt;&lt; 8)+ord(i) ^ self.rc4.next() print(\"ciphertext&#123;&#125; = &#123;&#125;\".format(cnt, ciphertext)) def enc(self, img): a, b, _ = img.shape for x in range(0, a): for y in range(0, b): pixel = img[x, y] for i in range(0, 3): pixel[i] = pixel[i] ^ self.rc4.next() img[x][y] = pixel enc = Image.fromarray(img) enc.save(\"enc&#123;&#125;.png\".format(cnt))Encrypt(Plaintext1)Encrypt(Plaintext2)# ciphertext1 = 12078640933356268898100798377710191641# ciphertext2 = 79124196547094980420644350061749775 enc1.png enc2.png Stream Cipher Insertion Attack Such a pity that I didn’t figure it out at that time. From two groups of plaintexts and ciphertexts we can recover keystream at the start. However, the second keystream has one bit less than the first one, from which we easily can retrieve m0, then k1, after that m1 and so on. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'''plaintext1 = \"RC4IsInteresting\"plaintext2 = \"ThisIsAEasyGame\"ciphertext1 = 12078640933356268898100798377710191641ciphertext2 = 79124196547094980420644350061749775key1 = []for i in range(len(plaintext1) - 1, -1, -1): key1 = [ord(plaintext1[i]) ^ (ciphertext1 &amp; 0xff)] + key1 ciphertext1 &gt;&gt;= 8print(key1)key2 = []for i in range(len(plaintext2) - 1, -1, -1): key2 = [ord(plaintext2[i]) ^ (ciphertext2 &amp; 0xff)] + key2 ciphertext2 &gt;&gt;= 8print(key2)# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106, 126]# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106]'''# Suppose the bit length of the flag.png is n bits, key1 and key2 can be written like:# key1: k1, k2, ..., kn# key2: k0, k1, ..., k(n-1)# Above we have already known k0 is 126, which is the last key of plaintext2,# we can retrieve m0, then k1, after that m1 and so onfrom PIL import Imagefrom numpy import arrayimg1 = array(Image.open(r\"./enc1.png\"))img2 = array(Image.open(r\"./enc2.png\"))def recovery_img(im1, im2, k): x1, y1, z1 = im1.shape for i in range(x1): for j in range(y1): pixel1 = im1[i, j] pixel2 = im2[i, j] for _ in range(3): pixel2[_] = pixel2[_] ^ k k = pixel1[_] ^ pixel2[_] im2 = Image.fromarray(im2) im2.save(\"dec.png\")recovery_img(img1, img2, 126) babyLCG(Solved)quiz.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Util.number import*from secret import flagclass LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = getRandomNBitInteger(128) self.m = getPrime(256) self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)DH = DH()flag = bytes_to_long(flag)print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"Cipher = &#123;&#125;\".format(flag ^ DH.key))'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' LCG+Diffie Hellman Exchange Key The seed is too small ,as a result, we use brute-force attack to get the seed and recover the key. When we XOR the cipher with the key, the plain is figured out. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475'''a = 3844066521b = 3316005024m = 2249804527'''class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 714405490 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() # a private key self.B, self.b = self.gen_AB() # b private key self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)'''def next(x): return (x * a + b) % mdef brute_force(): for i in range(1&lt;&lt;32): if i % 10000000 == 0: print(\"count:\", i) res = next(i) if (res &gt;&gt; 16) == 16269 and (next(res) &gt;&gt; 16) == 4249: print(i) break'''DH = DH()cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"flag = &#123;&#125;\".format(cipher ^ DH.key))# flag = 13040004482819966666226297285938773653367957972934959074317939536564198335643452104954492541# flag&#123;4dfe14e0c6c21ffcf5a3b4f0ed1911f6&#125;'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' Knapsack(Solved)quiz.py 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from functools import reducedef genKey(length): A, B = getPrime(64), getPrime(1025) Rn = getPrime(1024) key1 = [Rn//2**i for i in range(1, length+1)] key2 = [i*A % B for i in key1] return key1,key2def encrypt(text,key): Sum=0 for i in range(len(text)): Sum+=int(text[i])*key[i] return Sumdef save(Ciper,Key): f1=open(\"pub.txt\",\"w\") for i in range(len(Key)): f1.write(str(Key[i])+'\\n') f2=open(\"cip.txt\",\"w\") f2.write(hex(Ciper))FLAG = bin(bytes_to_long(flag.encode()))[2:]Key1,Key2 = genKey(len(FLAG))Ciper = encrypt(FLAG,Key1)save(Ciper,Key2) cip.txt 1a long hex string pub.txt 11015 public keys The last few key in pub.txt is too small, which actually is the original private key. We can use them to recover the original private key. backpacker(Unsolved)Remain confused What I have doneFinish learning symmetric cipher and the first chapter of Network Introduction. Things to Improve Don’t be panic when encountering a challenge that is never met Be more concentrated on study LLL algorithm","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"Npu-CTF-2020-Review","slug":"Npu-CTF-2020-Review","date":"2020-05-12T13:20:15.000Z","updated":"2020-08-03T03:26:42.361Z","comments":true,"path":"2020/05/12/Npu-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. What does the tag mean Status Description Solved Solved in the competition Unlved Unsolved in the competition Mersenne Twister(unsolved)This challenge is related to Mersenne Twister Encryption. However, there are differences between them exactly. Here is the file: Mersenne Twiser.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import *from itertools import *from binascii import hexlify , unhexlifyfrom flag import flag ,seedassert len(flag) == 26assert flag[:7] == 'npuctf&#123;'assert flag[-1] == '&#125;'XOR = lambda s1 ,s2 : bytes([x1 ^ x2 for x1 ,x2 in zip(s1 , s2)])class mt73991: def __init__(self , seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i+1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i+1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i+1)%233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4 , 'big') self.flag += 1 return bits def Next(self , tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef encrypt(key , plain): tmp = md5(plain).digest() return hexlify(XOR(tmp , key))if __name__ == \"__main__\": flag = flag.encode() random = mt73991(seed) f = open('./cipher.txt' , 'wb') for i in flag: key = b''.join([random.getramdanbits() for _ in range(4)]) cipher = encrypt(key , chr(i).encode()) f.write(cipher) cipher.txt 1an 832 bytes long hex string ExplanationMersenne Twister is a kind of PRNG, whose derives from the fact that its period length is chosen to be a Mersenne Prime. This Mersenne Twister challenge has a 32-bit length. ConditionOnly a few conditions are given. the encryption result in cipher.txt the period length partial flag the length of the flag encryption function DetailsGiven that the first part of the flag is “npuctf{“, which is a 7 bytes long string, we can retrieve the first 28 generated states with the according cipher in cipher.txt. Since we also know the last byte of the string(“}”) and the length of the string, we can easily retrieve the 100th~103th generated states. Then we look into the generate function. 12345678def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp Suppose that i equals to 103, we try to write down that situation. 12345678def generate(self): for i in range(233): y = (self.state[103] &amp; 0x80000000) | (self.state[(104) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 # 1 temp ^= self.state[(0) % 233] # 2 if y &amp; 1: temp ^= 0x9908f23f self.state[103] = temp # 3 In this situation, it is possible for us to retrieve the104th initial state, which means that we can get the seed through inversing. There are two possibilities in this situation(state[104] is odd or even). We try to draw a table. possibilites hb(1) hb(2) hb(3) even 0 0 0 odd 0 0 1 hb in the table above means the highest bit of the value in the line #n. Based on the fact that the true hb(3) is 0, which is the highest bit of the 103th generated state, it is impossible for the 104th initial state to be odd. Therefore, we can retrieve y and the low 31 bits of the 104 initial state. Since the highest bit is unknown, we can guess it (zero or one). Therefore, there are two possible seeds, which can be judged in the end. Because the seed is retrieved, we can decrypt the cipher easily.(Something just like Symmetric Cipher) By the way, the md5 function in encrypt function seems to be useless because it only encrypts one character, for which we can correspondingly generate an md5 dictionary of all printable characters and print the corresponding characters. RealizationHere is my realization. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import hashlibimport binasciifrom Cryptodome.Util.number import *import stringXOR = lambda s1, s2: bytes([x1 ^ x2 for x1, x2 in zip(s1, s2)])initial_state = [0] * 233initial_state2 = [0] * 233cipher = ['cef4876036ee8b55aa59bca043725bf3', '50a5e491debdef7ef7d63e9609a288ca', '1e2c82a7fe566bd8709e73c8d495ea50', '4a486ed11189faf8e6fb35617e47d2d1', 'ad5e4783e96afeaae9f7104ec477fb39', 'fe4ec619bf58289709e15c4449f03fc5', '1cba918cd0ebfdc12376b41e78154064', '82733b3b200826b6c78d86563edaea94', 'dccf459a4291517a4b8367d7b4a53aee', 'cd7e0accf661bfc726f5ba62e1c0e041', '00108ad32e7d5711f780185cba5cf31d', '328bee84066be4ab9582cf9d4bfe3c6f', '96a7732e1c37d800c90fd46277147f0a', '26c149dcd5eeb0f2df0c075627bc220b', 'e5eefdd67186056ac28c21e155a7f247', '664aaecdb498134de274df10114d1f06', 'f84dd21820f150d69c9439d909dec0f5', 'ccfeab61b62db2ea91d31bc8163ff16c', '7f458006bd5ac4a5f5bfae2770b23ccf', 'b7195b76aa0a9aa146831667a7b9fe08', 'c19e691afadccb3ca5169ef3fabaa3da', 'd47d536e89ed4cee6f788bc969c3ad31', '37850ebfc46a73af2b0c036c3da4b4a1', '6506f499445c604dd73eeb846a52f881', '515a3ad0ab448b4f9ed3e0ab1fffac60', 'b223dde6450ba6198e90e14de107aaf2']starts = \"npuctf&#123;\"ends = \"&#125;\"class mt73991: def __init__(self, seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i + 1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i + 1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4, 'big') self.flag += 1 return bits def Next(self, tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef USMR(x, shift, mask): res = x for i in range(32): res = x ^ (res &gt;&gt; shift &amp; mask) return resdef USML(x, shift, mask): res = x for i in range(32): res = x ^ (res &lt;&lt; shift &amp; mask) return resdef inv_Next(x): x = USMR(x, 18, 0x34adf670) x = USML(x, 15, 0xefc65400) x = USML(x, 7, 0x9ddf4680) x = USR(x, 11, 0xffffffff) return xdef inv_srand(value, index): for i in range(index-1, -1, -1): value += i value *= inverse(1812433253, 0x100000000) value = USR(value, 27, 0xffffffff) value &amp;= 0xffffffff return valuedef USR(value, shift, mask): i = 0 res = 0 while i * shift &lt; 32: partMask = ((0xffffffff &lt;&lt; (32 - shift)) &amp; 0xffffffff) &gt;&gt; (shift * i) part = value &amp; partMask value ^= (part &gt;&gt; shift) &amp; mask res |= part i += 1 return res# hash all known charactershash_starts = []for i in starts: hash_starts.append(hashlib.md5(i.encode()).digest())# print(hash_starts)hash_ends = hashlib.md5(ends.encode()).digest()state = [0] * 233# first 7 charactersfor i in range(len(starts)): key = XOR(hash_starts[i], binascii.unhexlify(cipher[i])) for j in range(4): tmp = inv_Next(bytes_to_long(key[4*j:4*j+4])) state[4*i+j] = tmp# print(state[:28]) # check passdef decrypt(key, cipher): cipher = binascii.unhexlify(cipher) temp = XOR(key, cipher) for i in md5_dic: if temp == i: print(string.printable[md5_dic.index(i)], end=\"\")# the last characterkey = XOR(hash_ends, binascii.unhexlify(cipher[-1]))for i in range(4): tmp = inv_Next(bytes_to_long(key[4*i:4*i+4])) state[100+i] = tmp# print(state[100:104]) # check pass# Since it can be simplified, there are only two situations of old_state[104]# old_state[104] is eveny = (state[0] ^ state[103]) &lt;&lt; 1 # recover y# print(y) # check passposs_1 = y &amp; 0x7fffffffposs_2 = (y &amp; 0x7fffffff) | 0x80000000# print(poss_1)# print(poss_2)# check pass# get the seed of each situationposs_1 = inv_srand(poss_1, 104)poss_2 = inv_srand(poss_2, 104)print(poss_1)print(poss_2)# generate md5 dictionarymd5_dic = []for i in string.printable: md5_dic.append(hashlib.md5(i.encode()).digest())random_1 = mt73991(poss_1)random_2 = mt73991(poss_2)# recover the flag from random_1flag = \"\"for i in range(26): key = b''.join([random_1.getramdanbits() for _ in range(4)]) decrypt(key, cipher[i])# Since random_1 is the correct one, random_2 can be ignored. 这题一开始出题人搞错了。。。自闭了一下午 认清形势，建立信心After observing the task.py, we can find that this is a classical discrete logarithm problem. Let’s see the file. task.py 12345678910111213141516171819202122from Crypto.Util.number import *from gmpy2 import *from secret import flagp = getPrime(25)e = # Hiddenq = getPrime(25)n = p * qm = bytes_to_long(flag.strip(b\"npuctf&#123;\").strip(b\"&#125;\"))c = pow(m, e, n)print(c)print(pow(2, e, n))print(pow(4, e, n))print(pow(8, e, n))'''169169912654178128509160179202518818742414340358553002064450''' ExplanationThere are many methods to solve discrete logarithm problems, BSGS(Baby Steps Giant Steps), SPH method and so on. ConditionThere are four equations in task.py and the remains of four equations are given. The flag is in the first equations. Here is what we have known. The length of q and p remains of four equations My idea is that n is possible to be solved and after that we can use the second equation to calculate e, using discrete logarithm calculation methods. DetailsWe can notice that: n\\;|\\;gcd(c1^{3}\\;-\\;c3,\\;c1^{2}\\;-\\;c2)From this character and another character that n is the product of two big prime number, we can get n. After that, it is really convenient that we can use discrete_log() function in Sage to calculate e. Luckily, e is coprime with n, so the inverse exists. The decryption is the similar with rsa. RealizationMy realization. 1234567891011121314151617181920212223242526272829303132#! /usr/bin/env sagefrom Crypto.Util.number import long_to_bytesimport gmpy2def gcd(a, b):tureif b == 0:tureturereturn a, 0turea, b = gcd(b, a % b)turereturn a, bc = 169169912654178c_1 = 128509160179202c_2 = 518818742414340c_3 = 358553002064450dc_1 = c_1 ** 2 - c_2dc_2 = c_1 ** 3 - c_3n = gcd(dc_1, dc_2)[0] / 2# print(n) # check passn.factor()p = 18195301q = 28977097phi = (p - 1) * (q - 1)e = discrete_log(Mod(c_1, n), Mod(2, n))# print(e) # check pass# print(gcd(e, phi)[0]) # check passd = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) Referenceshttps://en.wikipedia.org/wiki/Mersenne_Twister","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-05-03","slug":"2020-05-03","date":"2020-05-03T14:44:24.000Z","updated":"2020-05-03T14:50:02.431Z","comments":true,"path":"2020/05/03/2020-05-03/","link":"","permalink":"https://buki-freak.github.io/2020/05/03/2020-05-03/","excerpt":"","text":"What I Have DoneSadly, the quiz yesterday is still unsolved. It seems that z3-solver doesn’t work. As a result, I study Correlation Attack which is a kind of brute-force attack method. The method seems to work now and I am trying to understanding the codes written by others. Daily IELTS exercises have been done. What a day! Things to Learn and Improve Stream Cipher - Correlation Attack Method","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"2020-05-02","slug":"2020-05-02","date":"2020-05-02T13:12:07.000Z","updated":"2020-05-02T13:22:44.870Z","comments":true,"path":"2020/05/02/2020-05-02/","link":"","permalink":"https://buki-freak.github.io/2020/05/02/2020-05-02/","excerpt":"","text":"What I Have DoneA competition is held in these days, exciting and also exhausting! I am confident on a quiz about LFSR, which I have lately learned. However, things always does go in the right way, isn’t it? After being trapped for over five hours, I went to sleep… While I did several IELTS reading exercises, oh of course, I have finished The End of the fxxking world Season One just for fun ha ha ha! Things to Learn and Improve z3-solver English reading speed Be easygoing","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"Greeting","slug":"Greeting","date":"2020-05-01T12:33:15.000Z","updated":"2020-05-01T12:57:56.341Z","comments":true,"path":"2020/05/01/Greeting/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/Greeting/","excerpt":"","text":"Today, I have deleted all blogs deployed before. My greeting is below. The Past​ For a so-called loser, it is always mournful to talk about his or her past. Actually, I am one of them, after failing the college entrance examination. What’s more, things go wrong in these university days. It seems that I have have been trapped for such a long time, or have had a nightmare. Families, friends, mates, the environment, …, everything goes in a wrong way. However, Mama usually tells me to be positive, which merely works at some time I think. Well, as is told, if you don’t like this world, you can just try to leave it and choose your life. It will be alright, since seldom people can live for 100 years. I mean I should do what I really want to do in limited time. Therefore, stop to complain about the past, leave that fxxking world and alter a world that you want. Present Days​ Well, all roads lead to Rome. There are many ways to achieve your ambition and I choose that one that I have lately planned. Once the goal is settled, you only need to: Focus Focus Focus FutureFuture is unpredictable, but we should be hopeful. Look at the sky, and you will find how lovely it is to see the past of others. They are shining for you.","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-01T12:30:10.251Z","updated":"2019-08-27T01:03:22.557Z","comments":true,"path":"2020/05/01/hello-world/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"},{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"},{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"},{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"},{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]}