{"meta":{"title":"buk1","subtitle":"Every day is my last day.","description":"Programming","author":"buki","url":"https://buki-freak.github.io","root":"/"},"pages":[{"title":"å‹æƒ…é“¾æ¥","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":true,"path":"links/index.html","permalink":"https://buki-freak.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-03T03:02:58.465Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"repository/index.html","permalink":"https://buki-freak.github.io/repository/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"tags/index.html","permalink":"https://buki-freak.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"De1ta-CTF-2020-Review","slug":"De1ta-CTF-2020-Review","date":"2020-08-03T03:40:01.862Z","updated":"2020-08-03T07:05:31.815Z","comments":true,"path":"2020/08/03/De1ta-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. nlfsr(unsolved) This challenge consists of 4 linear feedback shift registers (below I use LFSR instead), with accordingly 19 bits, 19 bits, 6 bits and 3 bits state length. Here is the given file: quiz.py 12345678910111213141516171819202122232425262728from flag import a, b, c, d, flagassert flag == \"De1CTF&#123;\" + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \"&#125;\"assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6]ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i &amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ dodef genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\"data\", \"w+\").write(s)genkey(128*1024) data 1a string that comprises of 128*1024*8 bits(only zero or one) Explanation There are four LFSR in quiz.py and each round, four LFSR simultaneously compute four according output. Then the combination function combines these four bits and output the combination result into file data. Condition Since LFSR is the basic knowledge for us, there will more no more explanation on it. So letâ€™s see what we have got from the files. the initial state length of each LFSR the taps of each LFSR a combination function many rounds combination results It seems to be a simple quiz because we have already known the taps of each LFSR. However, each output of four LFSR is combined as one bit, from which we can hardly retrieve the outputs of four LFSR. If we use pure brute-force attack method, the complexity would be: O(247)O(2^{47}) O(247) Such a large scale. We must relate one or some output of four LFSR to the combination result and solve the each state independently. We can use a strategies called correlation attack in stream cipher. Details We first look into each possible situation of four LFSR and write down the result. ao bo co do combine 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 In the table, ao represents the single output of LFSR-1 and so on. It is very obvious that ao has 75% correlation with the combination output, and we also know that if we have the correct initial state of LFSR-1, three out of four output of LFSR-1 will be the same as the combination bits. As a result, we can independently search the initial state of LFSR-1, and the correct initial state should be the fittest one. Now the complexity comes down to: O(219+228)=O(228)O(2^{19}+2^{28})=O({2^{28}}) O(219+228)=O(228) This is already considerable in brute-force attack method (I use approximately 3 hours with C++, half a day with python to solve). But sadly, outputs of other LFSR just has 50% correlation with the combination output (actually no correlation). We can look into the combination function: 1(ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do And interestingly it can be transformed into: 1(ao*bo) ^ ((bo^1) * (co^do)) Calculating the XOR result of co and do by ourselves, we can surprisingly find that there is correlation between (co^do) and the combination result. Try to write down the table again. ao bo co^do combine 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 Again we can know from the table that (co^do) has 75% correlation with the combination output, which is the same as ao. There the complexity comes down again to: O(219+29+219)=O(220)O(2^{19}+2^{9}+2^{19})=O(2^{20}) O(219+29+219)=O(220) The complexity is very considerable now. Realization Official realization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf8import timema, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31key = open(\"data\").read()def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def calcR(x, y): assert len(x) == len(y) cnt = 0.0 for i, j in zip(x, y): cnt += (i == j) return cnt / len(x)def brutea(nb): relation, reala = 0, 0 for i in range(0, 2 ** 19): s = '' a = i for j in range(nb * 8): a = lfsr(a, ma) s += str(a &amp; 1) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, reala = r, i print(reala, relation) return realadef brutecd(nb): relation, realc, reald = 0, 0, 0 for i in range(0, 2 ** 6): d = i for j in range(0, 2 ** 13): c = j s = '' for k in range(nb * 8): c = lfsr(c, mc) d = lfsr(d, md) s += str((c &amp; 1) ^ (d &amp; 1)) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, realc, reald = r, j, i print(realc, reald, relation) return realc, realddef bruteb(nb, a_, c_, d_): for i in range(0, 2 ** 19): b = i a, c, d = a_, c_, d_ s = '' for j in range(nb * 8): a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [k &amp; 1 for k in [a, b, c, d]] s += str((ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do) if s == key[:nb * 8]: print(i) return iif __name__ == \"__main__\": start_time = time.time() print(start_time) a = brutea(20) c, d = brutecd(20) b = bruteb(20, a, c, d) \"De1CTF&#123;%s&#125;\" % (''.join([hex(i)[2:] for i in [a, b, c, d]])) end_time = time.time() print(\"Used time:\", end_time - start_time)# De1CTF&#123;58bb578d5611363f&#125; Other challenges still remain confused. What I have done I spent half of my afternoon writing this article, and I still have a long way to go. Keep on learning IELTS and number theory. Things to Learn and Improve How to use sage Do a review on wangdibei References https://en.wikipedia.org/wiki/Correlation_attack","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"å¤©ç¿¼æ¯-2020-Writeup","slug":"å¤©ç¿¼æ¯-2020-Writeup","date":"2020-07-31T15:00:19.000Z","updated":"2020-08-03T03:24:09.259Z","comments":true,"path":"2020/07/31/å¤©ç¿¼æ¯-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/07/31/å¤©ç¿¼æ¯-2020-Writeup/","excerpt":"","text":"æ¯”èµ›æ’å¾—å¾ˆå¯†ï¼Œgkd æŠŠ writeup å†™äº†ã€‚ easyRSA ç­¾åˆ°é¢˜ï¼Œå¯¹äºæ¯ä¸€æ¬¡åŠ å¯†ï¼Œæ˜æ–‡ç©ºé—´å°ï¼Œäºæ˜¯ç›´æ¥éå†ã€‚ 1234567891011121314n = ...cipher = ...import stringe = 11299plaintext = ''for i in range(len(cipher)): for s in string.printable: if pow(ord(s),e,n) == cipher[i]: plaintext += s print(plaintext) break hardRSA å·²çŸ¥ d ä½ 539 ä½ï¼Œq ä¸º 510 ä½ï¼Œè®¡ç®—ä½ä½ q çš„æ–¹æ³•å¯ä»¥ç›´æ¥è·å¾— qã€‚ 12345678910111213141516171819202122232425262728import gmpy2from Crypto.Util.number import long_to_bytesdef find_q(d0, kbits, e, n, p): X = var('X') for k in range(1, e+1): results = solve_mod([e*d0*X - k*(p-1)*X*(n//p-X+1) + (p-1)*k*(n//p) == X], 2^kbits) for x in results: q0 = ZZ(x[0]) if n % q0 == 0: return q0if __name__ == '__main__': n = 12723332779402711330767180202990021139894727917028981722242076998825097254419567024122271773380821224949951558669351311750240296591612098048129709925844660421849429715755474874708286508736369884566273719494870891070006251521469139401722700298201541140391493575314714966432624976434199682124684035067305114749262672684081617896579640435891181745346695293618235303178334371123418790204709073465264408888007492994820133128499094347122686903153588634296508454120927 e = 7 p = 3141886348112988339174865432179206412942588390228169645162293920470188882447855208783220899752887620221059861467348059334030873350571979462363834615231089 c = 8696771272015513736887843395612361647314297287781507609196936354183211655364744684164300710583625473872942712063309507651496314800393009480421886926137403759228421858414833429980059903049311837014449093365911603108158352871851677457256058510822509157407703210866317472894586087554001158540951787167699161720491198674848526093644131709561995379565643716017359731201935855247285498574923656191121426618306186331615280461405913653781283860760013215603007314688132 d0 = 0x414946b9c40728f9801e61e98ec6d17525cbe4163a5ffb8367b65c652ae4cc3abce62e70afbfb84fcf937b3119953b48922be19ef4312c4f3a88313368ca6c9b1d658b7 nbits = n.nbits() kbits = d0.nbits() q = find_q(d0, kbits, e, n, p) r = n // q // p phi = (r - 1) * (p - 1) * (q - 1) d = gmpy2.invert(e,phi) print(long_to_bytes(pow(c,d,n))) psï¼šä¹‹åæŠŠæ¨å¯¼è¿‡ç¨‹è¡¥ä¸Š AliceHomework LLL æ²¡è·‘å‡ºæ¥ï¼Œç–‘æƒ‘.jpg PolyCrypto æ²¡æ—¶é—´çœ‹é¢˜ã€‚ã€‚ã€‚tcl","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"3kctf-2020-Review","slug":"3kctf-2020-Review","date":"2020-07-27T06:21:11.000Z","updated":"2020-08-03T03:26:54.575Z","comments":true,"path":"2020/07/27/3kctf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/","excerpt":"","text":"pyzzle1 Given a cst tree code, use libcst package in python to transform it into source code: 123456from libcst import *abc = Module(....)with open('...','w') as f: f.write(str(abc.code)) Here is the source code in python: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import binasciiplaintext = \"REDACTED\"def exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempdef BinaryToDecimal(binary): string = int(binary, 2) return string# encryptionPT_Ascii = [ord(x) for x in plaintext]PT_Bin = [format(y, '08b') for y in PT_Ascii]PT_Bin = \"\".join(PT_Bin)n = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showL1 = PT_Bin[0:n]R1 = PT_Bin[n::]f1 = exor(R1, K1)R2 = exor(f1, L1)L2 = R1f2 = exor(R2, K2)R3 = exor(f2, L2)L3 = R2R3 = '''''' # Too long to showL3 = '''''' # Too long to showcipher = L3+R3# # decryption (redacted)# plaintext = L6+R6# plaintext = int(plaintext, 2)# plaintext = binascii.unhexlify('%x' % plaintext)# print(plaintext) This is a pretty easy structure, we can easily recover plaintext by: 1234567891011121314151617181920212223242526272829import binasciidef exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempn = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showR3 = '''''' # Too long to showL3 = '''''' # Too long to showR2 = L3L2 = exor(exor(K2, R2), R3)R1 = L2L1 = exor(exor(K1, R1), R2)plaintext = L1+R1plaintext = int(plaintext, 2)plaintext = binascii.unhexlify('%x' % plaintext)plaintext = binascii.unhexlify(plaintext)print(plaintext) The flag is : 3k{almost_done_shizzle_up_my_nizzle} Once_upon_a_time Given a program and encrypted flag: scss : program entrance main.c cipher.c flag_encrypted â€¦ Excellent realization of LFSR and block cipher encryption in C. We notice that the initial vector is fixed, 0xa2 ğŸ˜ƒ Addtionally, the key is fixed too, which means we can always get the same key stream. Moreover, I find something wired in cipher.c: 123case ECB: temp_ciphertext = temp_keystream ^ temp_plaintext; break; We can create a file with only â€˜\\x00â€™ and encrypt it in ECB mode to get the keystream. Since there are five modes, we can only try every situations. Woooool, finally catch ya! OFB! 12345678910In [20]: plaintext = '' In [21]: for i in range(113): ...: iv = iv ^ keystream[i] ...: temp = iv ^ cipher[i] ...: plaintext += chr(temp) ...: In [22]: plaintext Out[22]: '3k&#123;my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail&#125;' The flag is : 3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail} You shall not get my cookies Given an example cipher, and if the cipher can be correctly decrypted, it will send â€œNopâ€ back. I follow the write up here: https://ctftime.org/writeup/22602 Notice that there is an error in the write up above: if the length of a block is 16 bytes, it will be appended a block of sixteen â€˜\\x16â€™ according to PKCS#7 padding principle. Here is my exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-from pwn import *from Crypto.Util.number import bytes_to_long# context.log_level = 'debug'target = 'youshallnotgetmycookies.3k.ctf.to'port = 13337cipher = \"6F6A6A2C6E780D070A19001707060C0D\"suffix = ''fake_iv = ''dc = ''try: for i in range(1,17): assert(len(dc) == 2*(i-1)) for j in range(0x100): guess = hex(j)[2:].upper().zfill(2) fake_iv = '00' * (16-i) + guess + suffix print('[-]' + fake_iv) p = remote(target, port) p.sendlineafter('So... whats your cookie: ', fake_iv + cipher) res = p.recvall(timeout=4) p.close() res = res.decode() if len(res) == 11: pad = bytes([i]) dc = hex(int(guess, 16) ^ bytes_to_long(pad))[2:].upper().zfill(2) + dc suffix = hex(int(dc, 16) ^ bytes_to_long(bytes([(i+1)]) * i))[2:].upper().zfill(i*2) print('[-] D(C1) '+ dc) break print('[-] D(C1) '+ dc)except pwnlib.exception.PwnlibException: pass# 1C091F451A0B070D00130A1D0D0C0607 for the first block to be d(C2)# B0A608DDC37A458EEC0B74D37E888E8A for the second block# ...3B143145885BB42C94 for the third block# C2# 90C560B2A01529EF986E54B016E1FEAA# C1# 6F6A6A2C6E780D070A19001707060C0D# Calculate d(C1)# 218A7AEECEFB49CADF3D227AD84A21CF# Calculate C0# 6CEB0A82ABDB06ABAB50471BB46A63A6# The whole fake cipher:# 6CEB0A82ABDB06ABAB50471BB46A63A66F6A6A2C6E780D070A19001707060C0D90C560B2A01529EF986E54B016E1FEAA It cost 2 hours running this script twice.","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-First-Half-Review","slug":"2020-First-Half-Review","date":"2020-06-30T15:23:46.000Z","updated":"2020-07-17T02:47:27.086Z","comments":true,"path":"2020/06/30/2020-First-Half-Review/","link":"","permalink":"https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/","excerpt":"","text":"2020 å·²ç»è¿‡åŠï¼Œæ–°å¹´çš„é’Ÿå£°ä»¿ä½›ä»ç„¶è¦ç»•åœ¨è€³è¾¹ã€‚æ—¶é—´è¿‡å¾—å¤ªå¿«ï¼Œç•™ä¸‹çš„å¤ªå°‘ã€‚ å›é¡¾ ä»Šå¹´çœŸçš„å¾ˆç‰¹åˆ«å•Šï¼ŒäºŒæœˆä»½çš„æ—¶å€™è¿˜æŠ±ç€å›å­¦æ ¡ä¸Šè¯¾çš„æƒ³æ³•ï¼Œç°åœ¨å·²ç»ä¸Šäº†ä¸€å­¦æœŸçš„ç½‘è¯¾ã€‚å¯¹äºç½‘è¯¾å’Œå›å­¦æ ¡ä¸Šè¯¾ï¼Œæˆ‘æ˜¯ååè€…çš„ã€‚è¦çŸ¥é“ï¼Œå¾…åœ¨å®¶é‡Œå­¦ä¹ æ•ˆç‡ä¸åˆ°å­¦æ ¡çš„ååˆ†ä¹‹ä¸€ï¼šï¼‰ä¸è¿‡è¿˜å¥½ï¼Œç°åœ¨å¥½åƒæ…¢æ…¢ä¹ æƒ¯ä¸‹å»äº† hhhhh æœ¬æ¥æ˜¯äºŒæœˆåº•å¼€å­¦çš„ï¼Œä¸è¿‡å­¦æ ¡è¯´æ¨è¿Ÿå¼€å­¦ï¼ˆä¸å¸¦ç½‘è¯¾çš„é‚£ç§ï¼‰ã€‚å¥½å§ï¼Œç­‰åˆ°ä¸‰æœˆä»½ï¼Œç›¼äº†è®¸ä¹…è°çŸ¥æ”¹æˆç½‘è¯¾ï¼ˆç›´æ¥è£‚å¼€&gt;_&lt;ï¼Œç½‘è¯¾==è‡ªå­¦ã€‚ä¸å¾—ä¸è¯´ï¼Œè¿™åŠå¹´å¤„äºçœŸÂ·ç™½å­¦é˜¶æ®µï¼Œç™½å­¦èƒ½åŠ›æé«˜äº†ä¸å°‘ã€‚ ä¸€æœˆä¸»è¦åœ¨å­¦äº† Matlab ç¼–ç¨‹å’Œ Latexï¼Œä»åŸºæœ¬è¯­æ³•åˆ°ç”»å›¾ï¼Œå†åˆ°å¦‚ä½•ç”¨ Latex å†™å‡ºä¸€ç¯‡ nice çš„è®ºæ–‡ã€‚å­¦è¿™ä¸ªä¸»è¦æ˜¯ä¸ºäº†å‡†å¤‡æ•°æ¨¡ï¼Œä¸è¿‡å¬è¯´æ¯•ä¸šè®ºæ–‡è¦ç”¨ Latex 2333ã€‚å› ä¸ºå¯’å‡å‰æœ‰ä¸ªæœ‹å‹æ‹‰æ•°æ¨¡ç¾èµ›ï¼Œè‡ªå·±æ„Ÿè§‰æƒ³è¯•è¯•ï¼ˆè¯´ä¸å®šå¥½å¥½å­¦èƒ½æ‹¿ä¸ªå¥–ã€‚äºæ˜¯å°±æŠ¥åå»äº†ï¼ŒæŠ¥åè´¹ä¹Ÿä¸ä¾¿å®œã€‚åé¢å»å¬äº†å¬é‚£è¾¹çš„åŸºç¡€è¯¾ï¼Œå»ºæ¨¡å¯¹æ•°å­¦è¦æ±‚è¿˜æ˜¯æŒºé«˜çš„ï¼Œæœ‰ç‚¹æ‡µã€‚åé¢æœ‹å‹è¯´è®©æˆ‘å­¦å­¦ Matlab ç¼–ç¨‹ã€‚åŸºç¡€å­¦ä¸‹æ¥å…¶å®ä¹Ÿä¸ç”¨èŠ±å¾ˆé•¿æ—¶é—´ï¼Œä½†æ˜¯æ‹–ç€æ‹–ç€åˆ°äºŒæœˆä»½å»äº†ã€‚ä¸è¿‡å›æƒ³é‚£ä¸ªæ—¶å€™ï¼Œè‡ªå·±è·Ÿç€ç½‘ä¸Šæ•™ç¨‹èµ°ï¼Œè¿˜æ˜¯ä¸é”™çš„ã€‚ ç¾èµ›åœ¨ä¸‰æœˆä»½ï¼ŒåŸºç¡€æå¥½äº†ä»¥åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘äº†ï¼ˆçœŸå°±åªæäº†åŸºç¡€ wdtã€‚å…¶å®ä¸»è¦æ˜¯å‘ç°è‡ªå·±å¤ªä¹…æ²¡æå­¦ç§‘äº†ï¼Œäºæ˜¯åˆè·‘æ¥è¿™è¾¹å­¦å­¦ã€‚æå‡ºä¸€ä¸ªã€Šå¿«ä¹çš„ Linux å‘½ä»¤è¡Œã€‹ï¼Œä¹Ÿå¿˜äº†æ˜¯è°å‘ç»™æˆ‘çš„äº†ï¼Œç³»ç»Ÿåœ°è¿‡ä¸€é Linuxã€‚ä»æ–‡ä»¶ç³»ç»Ÿè·³è½¬åˆ° vim å¤„ç†æ–‡æœ¬ å†åˆ°è½¯ä»¶åŒ…ç®¡ç†ï¼Œæœ€å shell ç¼–ç¨‹ï¼Œé€”ä¸­é¡ºä¾¿æ¡å›äº†æ­£åˆ™è¡¨è¾¾å¼ã€‚çœ‹çš„æ—¶å€™å…¶å®çœŸçš„æœ‰å¾ˆå¤§æ„Ÿè§¦ã€‚çœ‹æ‡‚å‘½ä»¤ï¼Œæé«˜ä¸»åŠ¨æ€§ï¼Œè¿™æ˜¯æˆ‘æ‚Ÿå‡ºçš„ä¸€ç‚¹ã€‚æœ€è¿‘é€‰è¯¾çªç„¶å‘ç°ä¸‹å­¦æœŸæœ‰ä¸€é—¨å«ã€Šæ“ä½œç³»ç»Ÿå®è·µã€‹çš„è¯¾ï¼Œè®²å¾—å°±æ˜¯ Linux å‘½ä»¤2333 ç¾èµ›é‚£ä¸‰å¤©æ¯å¤©åªç¡äº†6ä¸ªå°æ—¶ï¼Œè´Ÿè´£ç¼–ç¨‹ã€‚å¦å¤–ä¸¤ä¸ªå¤§ä½¬å»ºæ¨¡åˆ†æç­‰ç­‰ï¼ˆè¿™é‡Œçš„ç­‰ç­‰çœç•¥äº†è®¸å¤šâ€¦ wtcl ä»£ç éƒ½æ˜¯é˜Ÿå‹å¸®æˆ‘æ‰¾çš„ã€‚å½“æ—¶å…¶å®æŒºè‡ªè´£çš„ï¼Œåˆ°åä¸¤å¤©æˆ‘æ‰å¼€å§‹å‘æŒ¥ä½œç”¨ã€‚æœ€ç»ˆè¿˜æ˜¯ä¸¤ä½å¤§ä½¬å¸¦ç€æˆ‘ä¸€ä¸ªèœé¸¡å‹‰å¼ºæ‹¿äº†ä¸ªå¥–ã€‚æ±‚ä¸‹å¹´åˆ«å†æ‹‰æˆ‘äº†ã€‚ åˆ°äº†ä¸‰æœˆåº•å°±å¼€å§‹ä¸Šè¯¾äº†ï¼Œé€šå¸¸ç¬¬ä¸€ä¸ªæ˜ŸæœŸéƒ½æ˜¯ä»‹ç»è¯¾ç¨‹ï¼Œå¿…é¡»è¦å¬å•Šï¼Œç§ç§åŸå› ã€‚ä¸€å¼€å§‹çš„é‚£å‡ ä¸ªæ˜ŸæœŸè¿˜æ˜¯å¾ˆè®¤çœŸçš„å¬è¯¾çš„ï¼Œåé¢å°±ä¸å¿ç›´è§†äº†ã€‚school ç‰¹è‰²åŸå› ï¼Œæ°´è¯¾å¾ˆå¤šã€‚è¿™æ—¶å€™ç½‘è¯¾çš„ä¼˜åŠ¿å°±å‡¸æ˜¾å‡ºæ¥äº†ã€‚è¯è™½è¿™ä¹ˆè¯´ï¼Œä½†æ˜¯è‹±è¯­è¿˜æ˜¯å¾—å¥½å¥½å­¦ã€‚ å››æœˆä»½å¼€å§‹å‡†å¤‡å­¦æ ¡çš„æ–°ç”Ÿèµ›ã€‚Crypto ä¸ä¼šå‡ºé¢˜ã€‚äºæ˜¯ç›´æ¥ç”¨äº†ä¸Šä¸€å¹´æ ¡èµ›çš„æ¨¡æ¿ï¼Œä¸€æ³¢ä¸‰æŠ˜ï¼Œæœ€åå¼ºè¡Œå‡‘å‡ºä¸‰é“é¢˜ï¼Œéš¾åº¦è¿˜ä¸å°ï¼Œç›´æ¥ä¸¢åˆ°å¹³å°ï¼Œæ²¡äººåšå‡ºæ¥ 555 å¤§æ¦‚å››æœˆä¸­æ—¬ï¼Œå®¶é‡Œäººå‡ºäº‹æƒ…äº†ï¼Œå¿ƒæ€æœ‰ç‚¹å´©ï¼Œä¹‹åç®—æ˜¯å‹‰å‹‰å¼ºå¼ºåœ°åœ¨å­¦ä¹ å§ã€‚ åˆ°äº†äº”æœˆä»½ï¼Œæ•´ä¸ªäººå‹¤å¿«äº†ï¼Œå­¦å¾—æŒºå¿«ã€‚æŠŠ Crypto çš„åŸºç¡€è¿‡äº†ä¸€éï¼Œæ‰“ä¸‹äº†å‡ åœºæ¯”èµ›ï¼Œçœ‹äº†ä¸å°‘paperï¼Œæ”¶è·è¿˜æ˜¯æŒºå¤§çš„ï¼Œå¯æƒœæ²¡æœ‰è¿›åˆ°çº¿ä¸‹ã€‚ä¸€ä¸ªé˜Ÿä¼ï¼Œä¸‰ç¼ºä¸€ï¼ŒåŠ ä¸Šè¿›çº¿ä¸‹çš„ç§ç§å›°éš¾ï¼Œç¦»ç›®æ ‡è¿˜æ˜¯å¾ˆè¿œå•Šã€‚ å…­æœˆä»½ä¸»è¦åœ¨å‡†å¤‡å„ç§‘çš„è€ƒè¯•ï¼Œå…¨åŠ›å¤ä¹ ï¼Œæ¯•ç«Ÿè¿˜æ˜¯æƒ³æ··ä¸ªå¥–å­¦é‡‘ã€‚ç°åœ¨æƒ³æƒ³ï¼Œä¸çŸ¥ä¸è§‰ï¼Œå·²ç»åœ¨å®¶åŠå¹´ã€‚ã€‚ã€‚å¸Œæœ›å¿«å¿«å¼€å­¦ã€‚ æ„Ÿæƒ³ å¤§å­¦å·²ç»è¿‡å»ä¸€åŠï¼Œåº†å¹¸è‡ªå·±è¿™ä¸€å¹´æ²¡æœ‰æµªè´¹ï¼Œä½†ä¹Ÿå¾ˆå¯æƒœï¼Œæ²¡æœ‰è¾¾åˆ°è‡ªå·±é¢„æœŸçš„ç›®æ ‡ã€‚æ€ä¹ˆè¯´å‘¢ï¼Œè‡ªå·±å½“åˆçš„ç›®æ ‡å…¶å®å·²ç»æ”¹å˜äº†å§ï¼Œç°å®ä¸­çš„å˜åŒ–çš„å¤ªå¿«ï¼Œè€Œä¸”è‡ªå·±å½“åˆçš„å†³å¿ƒä¼¼ä¹ä¹Ÿæ²¡æœ‰é‚£ä¹ˆåšå®šã€‚èµ°ä¸€æ­¥çœ‹ä¸€æ­¥å§ï¼Œæ¯•ç«Ÿä¸æƒ³æµªè´¹è¿™å‡ å¹´å®è´µçš„æ—¶é—´ã€‚ å±•æœ› ç”¨æŸäººçš„è¯ï¼šâ€œå°‘è¯´è¯ï¼Œå¤šåšäº‹ã€‚å…‰è¯´ä¸ç»ƒå‡æŠŠå¼ï¼Œè¦å‹¤å¥‹ï¼Œå‹‡äºå®è·µã€‚â€","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"das-CTF&GK-CTF-2020-Writeup","slug":"das-CTF-GK-CTF-2020-Writeup","date":"2020-05-24T01:30:24.000Z","updated":"2020-08-03T03:26:26.371Z","comments":true,"path":"2020/05/24/das-CTF-GK-CTF-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/","excerpt":"","text":"Only writeup in Crypto. GKCTF å°å­¦ç”Ÿçš„å¯†ç å­¦(Solved) Pretty easy affince cipher. Both keys are given. babycrypto(Solved) Partial high bits of p is known. 123456789101112131415161718192021222324# Use sage to run the script# Reference: https://www.jianshu.com/p/1a0e876d5929from sage.all import *from Crypto.Util.number import long_to_bytes# All variables are in hexn = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005# Padding zeros to p --&gt; p4p4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000cipher = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361e2 = 65537kbits = 128 # kbits represent the loss bitsPR.&lt;x&gt; = PolynomialRing(Zmod(n)) # Create a polynomial ringf = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4 + int(roots[0]) assert n % p == 0 q = n / int(p) phin = (p-1)*(q-1) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) print long_to_bytes(flag) æ±‰å­—çš„å¯†ç (Solved) å½“é“ºå¯†ç +Substitution Cipher 123456dic = [66, 74, 62, 67, 118, 83, 72, 77, 86, 55, 71, 57, 82, 57, 64, 63, 51, 107]delta = 1for i in dic: print(chr(i+delta), end=\"\") delta += 1# FLAG&#123;YOU_ARE_GOOD&#125; Backdoor(Unsolved) Remain confused DASCTF bbcrypto(Solved) quiz.py 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=\"\" for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return cif __name__ == \"__main__\": m = 'flag&#123;********************************&#125;' a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(\"æ˜æ–‡å†…å®¹ä¸ºï¼š\") print(m) print(\"åŠ å¯†åçš„å¯†æ–‡ä¸ºï¼š\") c=encrypt(m, a, si) print(c) #åŠ å¯†åçš„å¯†æ–‡ä¸ºï¼š #177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d The length of salt is 3 and we have already known that the plain starts with â€œflag{â€. Solve linear congruent equations to get the salt. 123456789101112131415161718192021222324c = \"177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d\"li_c = [int(c[i:i+2], 16) for i in range(0, len(c), 2)]# print(li_c)m = \"flag&#123;\"d_c = li_c[3] - li_c[0]# print(d_c)d_m = ord(m[3]) - ord(m[0])# print(d_m) # a = 57 mod 128a = 57# print((li_c[0] - a * ord(m[0])) % 128)# print(chr(97)) y1 = 'a'# print((li_c[1] - a * ord(m[1])) % 128)# print(chr(104)) y2 = 'h'# print((li_c[2] - a * ord(m[2])) % 128)# print(chr(104)) # y3 = 'h'# print((li_c[3] - a * ord(m[3])) % 128)m = \"\"from gmpy2 import invertimport itertoolsinv_a = invert(a, 128)key = itertools.cycle(\"ahh\")for i in li_c: m += chr(((i - ord(next(key))) * inv_a) % 128)print(m) encrypt_img(Solved) quiz.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from numpy import arrayfrom PIL import Imagefrom secret import KeyPlaintext1 = \"RC4IsInteresting\"Plaintext2 = \"ThisIsAEasyGame\"cnt = 0class RC4(): def __init__(self, Key): self.S = [i for i in range(256)] # 0 - 255 self.K = [ord(Key[i % len(Key)])*2 for i in range(256)] # KEY * 2(0-255) self.I, self.J = 0, 0 self.KSA() def KSA(self): for i in range(256): j = (i+self.K[i]+self.S[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def next(self): self.I = (self.I+1) % 256 self.J = (self.J+self.S[self.I]) % 256 self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J] tmp = (self.S[self.J] + self.S[self.I]) % 256 return self.S[tmp]class Encrypt(): def __init__(self, plain): global cnt cnt += 1 self.rc4 = RC4(Key) self.testRC4(plain) flag_file = Image.open(r\"flag.png\") img = array(flag_file) self.enc(img) def testRC4(self, plain): ciphertext = 0 for i in plain: ciphertext = (ciphertext &lt;&lt; 8)+ord(i) ^ self.rc4.next() print(\"ciphertext&#123;&#125; = &#123;&#125;\".format(cnt, ciphertext)) def enc(self, img): a, b, _ = img.shape for x in range(0, a): for y in range(0, b): pixel = img[x, y] for i in range(0, 3): pixel[i] = pixel[i] ^ self.rc4.next() img[x][y] = pixel enc = Image.fromarray(img) enc.save(\"enc&#123;&#125;.png\".format(cnt))Encrypt(Plaintext1)Encrypt(Plaintext2)# ciphertext1 = 12078640933356268898100798377710191641# ciphertext2 = 79124196547094980420644350061749775 enc1.png enc2.png Stream Cipher Insertion Attack Such a pity that I didnâ€™t figure it out at that time. From two groups of plaintexts and ciphertexts we can recover keystream at the start. However, the second keystream has one bit less than the first one, from which we easily can retrieve m0, then k1, after that m1 and so on. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'''plaintext1 = \"RC4IsInteresting\"plaintext2 = \"ThisIsAEasyGame\"ciphertext1 = 12078640933356268898100798377710191641ciphertext2 = 79124196547094980420644350061749775key1 = []for i in range(len(plaintext1) - 1, -1, -1): key1 = [ord(plaintext1[i]) ^ (ciphertext1 &amp; 0xff)] + key1 ciphertext1 &gt;&gt;= 8print(key1)key2 = []for i in range(len(plaintext2) - 1, -1, -1): key2 = [ord(plaintext2[i]) ^ (ciphertext2 &amp; 0xff)] + key2 ciphertext2 &gt;&gt;= 8print(key2)# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106, 126]# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106]'''# Suppose the bit length of the flag.png is n bits, key1 and key2 can be written like:# key1: k1, k2, ..., kn# key2: k0, k1, ..., k(n-1)# Above we have already known k0 is 126, which is the last key of plaintext2,# we can retrieve m0, then k1, after that m1 and so onfrom PIL import Imagefrom numpy import arrayimg1 = array(Image.open(r\"./enc1.png\"))img2 = array(Image.open(r\"./enc2.png\"))def recovery_img(im1, im2, k): x1, y1, z1 = im1.shape for i in range(x1): for j in range(y1): pixel1 = im1[i, j] pixel2 = im2[i, j] for _ in range(3): pixel2[_] = pixel2[_] ^ k k = pixel1[_] ^ pixel2[_] im2 = Image.fromarray(im2) im2.save(\"dec.png\")recovery_img(img1, img2, 126) babyLCG(Solved) quiz.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Util.number import*from secret import flagclass LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = getRandomNBitInteger(128) self.m = getPrime(256) self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)DH = DH()flag = bytes_to_long(flag)print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"Cipher = &#123;&#125;\".format(flag ^ DH.key))'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' LCG+Diffie Hellman Exchange Key The seed is too small ,as a result, we use brute-force attack to get the seed and recover the key. When we XOR the cipher with the key, the plain is figured out. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475'''a = 3844066521b = 3316005024m = 2249804527'''class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 714405490 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() # a private key self.B, self.b = self.gen_AB() # b private key self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)'''def next(x): return (x * a + b) % mdef brute_force(): for i in range(1&lt;&lt;32): if i % 10000000 == 0: print(\"count:\", i) res = next(i) if (res &gt;&gt; 16) == 16269 and (next(res) &gt;&gt; 16) == 4249: print(i) break'''DH = DH()cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"flag = &#123;&#125;\".format(cipher ^ DH.key))# flag = 13040004482819966666226297285938773653367957972934959074317939536564198335643452104954492541# flag&#123;4dfe14e0c6c21ffcf5a3b4f0ed1911f6&#125;'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' Knapsack(Solved) quiz.py 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from functools import reducedef genKey(length): A, B = getPrime(64), getPrime(1025) Rn = getPrime(1024) key1 = [Rn//2**i for i in range(1, length+1)] key2 = [i*A % B for i in key1] return key1,key2def encrypt(text,key): Sum=0 for i in range(len(text)): Sum+=int(text[i])*key[i] return Sumdef save(Ciper,Key): f1=open(\"pub.txt\",\"w\") for i in range(len(Key)): f1.write(str(Key[i])+'\\n') f2=open(\"cip.txt\",\"w\") f2.write(hex(Ciper))FLAG = bin(bytes_to_long(flag.encode()))[2:]Key1,Key2 = genKey(len(FLAG))Ciper = encrypt(FLAG,Key1)save(Ciper,Key2) cip.txt 1a long hex string pub.txt 11015 public keys The last few key in pub.txt is too small, which actually is the original private key. We can use them to recover the original private key. backpacker(Unsolved) Remain confused What I have done Finish learning symmetric cipher and the first chapter of Network Introduction. Things to Improve Donâ€™t be panic when encountering a challenge that is never met Be more concentrated on study LLL algorithm","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"Npu-CTF-2020-Review","slug":"Npu-CTF-2020-Review","date":"2020-05-12T13:20:15.000Z","updated":"2020-08-03T03:26:42.361Z","comments":true,"path":"2020/05/12/Npu-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. What does the tag mean Status Description Solved Solved in the competition Unlved Unsolved in the competition Mersenne Twister(unsolved) This challenge is related to Mersenne Twister Encryption. However, there are differences between them exactly. Here is the file: Mersenne Twiser.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import *from itertools import *from binascii import hexlify , unhexlifyfrom flag import flag ,seedassert len(flag) == 26assert flag[:7] == 'npuctf&#123;'assert flag[-1] == '&#125;'XOR = lambda s1 ,s2 : bytes([x1 ^ x2 for x1 ,x2 in zip(s1 , s2)])class mt73991: def __init__(self , seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i+1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i+1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i+1)%233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4 , 'big') self.flag += 1 return bits def Next(self , tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef encrypt(key , plain): tmp = md5(plain).digest() return hexlify(XOR(tmp , key))if __name__ == \"__main__\": flag = flag.encode() random = mt73991(seed) f = open('./cipher.txt' , 'wb') for i in flag: key = b''.join([random.getramdanbits() for _ in range(4)]) cipher = encrypt(key , chr(i).encode()) f.write(cipher) cipher.txt 1an 832 bytes long hex string Explanation Mersenne Twister is a kind of PRNG, whose derives from the fact that its period length is chosen to be a Mersenne Prime. This Mersenne Twister challenge has a 32-bit length. Condition Only a few conditions are given. the encryption result in cipher.txt the period length partial flag the length of the flag encryption function Details Given that the first part of the flag is â€œnpuctf{â€, which is a 7 bytes long string, we can retrieve the first 28 generated states with the according cipher in cipher.txt. Since we also know the last byte of the string(&quot;}&quot;) and the length of the string, we can easily retrieve the 100th~103th generated states. Then we look into the generate function. 12345678def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp Suppose that i equals to 103, we try to write down that situation. 12345678def generate(self): for i in range(233): y = (self.state[103] &amp; 0x80000000) | (self.state[(104) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 # 1 temp ^= self.state[(0) % 233] # 2 if y &amp; 1: temp ^= 0x9908f23f self.state[103] = temp # 3 In this situation, it is possible for us to retrieve the104th initial state, which means that we can get the seed through inversing. There are two possibilities in this situation(state[104] is odd or even). We try to draw a table. possibilites hb(1) hb(2) hb(3) even 0 0 0 odd 0 0 1 hb in the table above means the highest bit of the value in the line #n. Based on the fact that the true hb(3) is 0, which is the highest bit of the 103th generated state, it is impossible for the 104th initial state to be odd. Therefore, we can retrieve y and the low 31 bits of the 104 initial state. Since the highest bit is unknown, we can guess it (zero or one). Therefore, there are two possible seeds, which can be judged in the end. Because the seed is retrieved, we can decrypt the cipher easily.(Something just like Symmetric Cipher) By the way, the md5 function in encrypt function seems to be useless because it only encrypts one character, for which we can correspondingly generate an md5 dictionary of all printable characters and print the corresponding characters. Realization Here is my realization. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import hashlibimport binasciifrom Cryptodome.Util.number import *import stringXOR = lambda s1, s2: bytes([x1 ^ x2 for x1, x2 in zip(s1, s2)])initial_state = [0] * 233initial_state2 = [0] * 233cipher = ['cef4876036ee8b55aa59bca043725bf3', '50a5e491debdef7ef7d63e9609a288ca', '1e2c82a7fe566bd8709e73c8d495ea50', '4a486ed11189faf8e6fb35617e47d2d1', 'ad5e4783e96afeaae9f7104ec477fb39', 'fe4ec619bf58289709e15c4449f03fc5', '1cba918cd0ebfdc12376b41e78154064', '82733b3b200826b6c78d86563edaea94', 'dccf459a4291517a4b8367d7b4a53aee', 'cd7e0accf661bfc726f5ba62e1c0e041', '00108ad32e7d5711f780185cba5cf31d', '328bee84066be4ab9582cf9d4bfe3c6f', '96a7732e1c37d800c90fd46277147f0a', '26c149dcd5eeb0f2df0c075627bc220b', 'e5eefdd67186056ac28c21e155a7f247', '664aaecdb498134de274df10114d1f06', 'f84dd21820f150d69c9439d909dec0f5', 'ccfeab61b62db2ea91d31bc8163ff16c', '7f458006bd5ac4a5f5bfae2770b23ccf', 'b7195b76aa0a9aa146831667a7b9fe08', 'c19e691afadccb3ca5169ef3fabaa3da', 'd47d536e89ed4cee6f788bc969c3ad31', '37850ebfc46a73af2b0c036c3da4b4a1', '6506f499445c604dd73eeb846a52f881', '515a3ad0ab448b4f9ed3e0ab1fffac60', 'b223dde6450ba6198e90e14de107aaf2']starts = \"npuctf&#123;\"ends = \"&#125;\"class mt73991: def __init__(self, seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i + 1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i + 1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4, 'big') self.flag += 1 return bits def Next(self, tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef USMR(x, shift, mask): res = x for i in range(32): res = x ^ (res &gt;&gt; shift &amp; mask) return resdef USML(x, shift, mask): res = x for i in range(32): res = x ^ (res &lt;&lt; shift &amp; mask) return resdef inv_Next(x): x = USMR(x, 18, 0x34adf670) x = USML(x, 15, 0xefc65400) x = USML(x, 7, 0x9ddf4680) x = USR(x, 11, 0xffffffff) return xdef inv_srand(value, index): for i in range(index-1, -1, -1): value += i value *= inverse(1812433253, 0x100000000) value = USR(value, 27, 0xffffffff) value &amp;= 0xffffffff return valuedef USR(value, shift, mask): i = 0 res = 0 while i * shift &lt; 32: partMask = ((0xffffffff &lt;&lt; (32 - shift)) &amp; 0xffffffff) &gt;&gt; (shift * i) part = value &amp; partMask value ^= (part &gt;&gt; shift) &amp; mask res |= part i += 1 return res# hash all known charactershash_starts = []for i in starts: hash_starts.append(hashlib.md5(i.encode()).digest())# print(hash_starts)hash_ends = hashlib.md5(ends.encode()).digest()state = [0] * 233# first 7 charactersfor i in range(len(starts)): key = XOR(hash_starts[i], binascii.unhexlify(cipher[i])) for j in range(4): tmp = inv_Next(bytes_to_long(key[4*j:4*j+4])) state[4*i+j] = tmp# print(state[:28]) # check passdef decrypt(key, cipher): cipher = binascii.unhexlify(cipher) temp = XOR(key, cipher) for i in md5_dic: if temp == i: print(string.printable[md5_dic.index(i)], end=\"\")# the last characterkey = XOR(hash_ends, binascii.unhexlify(cipher[-1]))for i in range(4): tmp = inv_Next(bytes_to_long(key[4*i:4*i+4])) state[100+i] = tmp# print(state[100:104]) # check pass# Since it can be simplified, there are only two situations of old_state[104]# old_state[104] is eveny = (state[0] ^ state[103]) &lt;&lt; 1 # recover y# print(y) # check passposs_1 = y &amp; 0x7fffffffposs_2 = (y &amp; 0x7fffffff) | 0x80000000# print(poss_1)# print(poss_2)# check pass# get the seed of each situationposs_1 = inv_srand(poss_1, 104)poss_2 = inv_srand(poss_2, 104)print(poss_1)print(poss_2)# generate md5 dictionarymd5_dic = []for i in string.printable: md5_dic.append(hashlib.md5(i.encode()).digest())random_1 = mt73991(poss_1)random_2 = mt73991(poss_2)# recover the flag from random_1flag = \"\"for i in range(26): key = b''.join([random_1.getramdanbits() for _ in range(4)]) decrypt(key, cipher[i])# Since random_1 is the correct one, random_2 can be ignored. è¿™é¢˜ä¸€å¼€å§‹å‡ºé¢˜äººæé”™äº†ã€‚ã€‚ã€‚è‡ªé—­äº†ä¸€ä¸‹åˆ è®¤æ¸…å½¢åŠ¿ï¼Œå»ºç«‹ä¿¡å¿ƒ After observing the task.py, we can find that this is a classical discrete logarithm problem. Letâ€™s see the file. task.py 12345678910111213141516171819202122from Crypto.Util.number import *from gmpy2 import *from secret import flagp = getPrime(25)e = # Hiddenq = getPrime(25)n = p * qm = bytes_to_long(flag.strip(b\"npuctf&#123;\").strip(b\"&#125;\"))c = pow(m, e, n)print(c)print(pow(2, e, n))print(pow(4, e, n))print(pow(8, e, n))'''169169912654178128509160179202518818742414340358553002064450''' Explanation There are many methods to solve discrete logarithm problems, BSGS(Baby Steps Giant Steps), SPH method and so on. Condition There are four equations in task.py and the remains of four equations are given. The flag is in the first equations. Here is what we have known. The length of q and p remains of four equations My idea is that n is possible to be solved and after that we can use the second equation to calculate e, using discrete logarithm calculation methods. Details We can notice that: n âˆ£ gcd(c13 âˆ’ c3, c12 âˆ’ c2)n\\;|\\;gcd(c1^{3}\\;-\\;c3,\\;c1^{2}\\;-\\;c2) nâˆ£gcd(c13âˆ’c3,c12âˆ’c2) From this character and another character that n is the product of two big prime number, we can get n. After that, it is really convenient that we can use discrete_log() function in Sage to calculate e. Luckily, e is coprime with n, so the inverse exists. The decryption is the similar with rsa. Realization My realization. 1234567891011121314151617181920212223242526272829303132#! /usr/bin/env sagefrom Crypto.Util.number import long_to_bytesimport gmpy2def gcd(a, b):tureif b == 0:tureturereturn a, 0turea, b = gcd(b, a % b)turereturn a, bc = 169169912654178c_1 = 128509160179202c_2 = 518818742414340c_3 = 358553002064450dc_1 = c_1 ** 2 - c_2dc_2 = c_1 ** 3 - c_3n = gcd(dc_1, dc_2)[0] / 2# print(n) # check passn.factor()p = 18195301q = 28977097phi = (p - 1) * (q - 1)e = discrete_log(Mod(c_1, n), Mod(2, n))# print(e) # check pass# print(gcd(e, phi)[0]) # check passd = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) References https://en.wikipedia.org/wiki/Mersenne_Twister","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-05-03","slug":"2020-05-03","date":"2020-05-03T14:44:24.000Z","updated":"2020-05-03T14:50:02.431Z","comments":true,"path":"2020/05/03/2020-05-03/","link":"","permalink":"https://buki-freak.github.io/2020/05/03/2020-05-03/","excerpt":"","text":"What I Have Done Sadly, the quiz yesterday is still unsolved. It seems that z3-solver doesnâ€™t work. As a result, I study Correlation Attack which is a kind of brute-force attack method. The method seems to work now and I am trying to understanding the codes written by others. Daily IELTS exercises have been done. What a day! Things to Learn and Improve Stream Cipher - Correlation Attack Method","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"2020-05-02","slug":"2020-05-02","date":"2020-05-02T13:12:07.000Z","updated":"2020-05-02T13:22:44.870Z","comments":true,"path":"2020/05/02/2020-05-02/","link":"","permalink":"https://buki-freak.github.io/2020/05/02/2020-05-02/","excerpt":"","text":"What I Have Done A competition is held in these days, exciting and also exhausting! I am confident on a quiz about LFSR, which I have lately learned. However, things always does go in the right way, isnâ€™t it? After being trapped for over five hours, I went to sleepâ€¦ While I did several IELTS reading exercises, oh of course, I have finished The End of the fxxking world Season One just for fun ha ha ha! Things to Learn and Improve z3-solver English reading speed Be easygoing","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"Greeting","slug":"Greeting","date":"2020-05-01T12:33:15.000Z","updated":"2020-05-01T12:57:56.341Z","comments":true,"path":"2020/05/01/Greeting/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/Greeting/","excerpt":"","text":"Today, I have deleted all blogs deployed before. My greeting is below. The Past â€‹ For a so-called loser, it is always mournful to talk about his or her past. Actually, I am one of them, after failing the college entrance examination. Whatâ€™s more, things go wrong in these university days. It seems that I have have been trapped for such a long time, or have had a nightmare. Families, friends, mates, the environment, â€¦, everything goes in a wrong way. However, Mama usually tells me to be positive, which merely works at some time I think. Well, as is told, if you donâ€™t like this world, you can just try to leave it and choose your life. It will be alright, since seldom people can live for 100 years. I mean I should do what I really want to do in limited time. Therefore, stop to complain about the past, leave that fxxking world and alter a world that you want. Present Days â€‹ Well, all roads lead to Rome. There are many ways to achieve your ambition and I choose that one that I have lately planned. Once the goal is settled, you only need to: Focus Focus Focus Future Future is unpredictable, but we should be hopeful. Look at the sky, and you will find how lovely it is to see the past of others. They are shining for you.","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-01T12:30:10.251Z","updated":"2019-08-27T01:03:22.557Z","comments":true,"path":"2020/05/01/hello-world/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"},{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"},{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"},{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]}