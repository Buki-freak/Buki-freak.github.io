{"meta":{"title":"buk1","subtitle":"Every day is my last day.","description":"Programming","author":"buki","url":"https://buki-freak.github.io","root":"/"},"pages":[{"title":"å‹æƒ…é“¾æ¥","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":true,"path":"links/index.html","permalink":"https://buki-freak.github.io/links/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"tags/index.html","permalink":"https://buki-freak.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-08-03T03:02:58.465Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"repository/index.html","permalink":"https://buki-freak.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"differential attack learning","slug":"differential-attack-learning","date":"2020-09-10T12:48:14.000Z","updated":"2020-09-11T14:23:56.199Z","comments":true,"path":"2020/09/10/differential-attack-learning/","link":"","permalink":"https://buki-freak.github.io/2020/09/10/differential-attack-learning/","excerpt":"","text":"å­¦ä¹ ä¸€ä¸‹å·®åˆ†æ”»å‡»ï¼Œæœ€è¿‘æ¯”èµ›å‡ºç°å¾—æœ‰ç‚¹å¤šã€‚ â€‹ åŸç†å‰–æå…ˆèŠ±ä¸ª 30 åˆ†é’Ÿçœ‹ä¸ªè§†é¢‘ï¼Œçœ‹ä¸€ä¸‹å·®åˆ†æ”»å‡»åˆ°åº•æ˜¯ä¸ªå•¥ã€‚è‹±è¯­æœ‰ç‚¹æ’‡è„šï¼Œå‹‰å¼ºå¬ä¸€ä¸‹ã€‚ é¡ºä¾¿è®°å½•ä¸€ä¸‹ non-generic attack çš„åˆ†ç±»ï¼š â€‹ linear attack differential attack slide-channel attack related key attack &nbsp; &nbsp; å€Ÿä¸ªå›¾ï¼Œè™½ç„¶æœ‰ç‚¹ç³Šã€‚å·®åˆ†æ”»å‡»åŸºäºé€‰æ‹©æ˜æ–‡æ”»å‡»ï¼Œå¹¶ä¸”å‰ææ˜¯ $\\alpha\\;-\\;\\beta$ å…·æœ‰ high-probabilityã€‚è§£é‡Šä¸€ä¸‹ï¼Œ$\\alpha$ æ˜¯ä¸€å¯¹ æ˜æ–‡ï¼Œæˆ–è€…è¿›å…¥ F function å‰ä¸­é—´å€¼çš„å¼‚æˆ–å€¼ï¼ˆå·®å€¼ï¼‰ï¼Œ$\\beta$ æ˜¯ç»è¿‡ $r-1$ round F Function ä¹‹åçš„å¯¹åº”çš„å¯†æ–‡å¯¹çš„å¼‚æˆ– å€¼ã€‚â€‹â€‹ å¯¹äº $\\alpha$ï¼Œ \\alpha\\;=\\;x_1\\;\\oplus\\;x_2â€‹ å¯¹äº $\\beta$ï¼Œ y_1\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_1)\\\\ y_2\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_2)\\\\ \\beta\\;=\\;y_1\\;\\;\\oplus\\;y_2â€‹ â€‹ é‚£ä¹ˆ $\\alpha$ï¼Œ$\\beta$ æ€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘ä»¬å…ˆå‡è®¾ $\\alpha$ å’Œ $\\beta$ æ˜¯ç¡®å®šçš„å¹¶å…·æœ‰ high-probabilityï¼Œé‚£ä¹ˆå¯¹äºä¸€ä¸ª n bits çš„ keyï¼Œå¯¹äºæ‰€æœ‰å¯èƒ½ çš„å€¼ï¼Œæˆ‘ä»¬å»ºç«‹ä¸€ä¸ªè¡¨ï¼š â€‹ Potential r-th round Key K0 K1 â€¦ Ki Kn-2 Kn-1 Kn Count 0 0 0 0 0 0 0 â€‹ â€‹ å¯¹äºæ‰€æœ‰å·®å€¼ä¸º $\\alpha$ çš„æ˜æ–‡å¯¹ï¼Œæˆ‘ä»¬ç”¨ $K_i$ è®¡ç®—å¯¹åº”çš„ $\\betaâ€™$ã€‚å¯¹äºæ¯ä¸€ä¸ª $K_i$ ï¼Œå¦‚æœäº§ç”Ÿçš„å·®å€¼ä¸º $\\beta$ ï¼Œé‚£ä¹ˆ count è‡ªå¢ã€‚æœ€ å count ä¸º maximum çš„ potential r-th round key å¾ˆå¯èƒ½ä¸º real keyã€‚ â€‹ é‚£ä¹ˆå¦‚ä½•æ‰¾å‡ºæœ€ä½³çš„ $\\alpha$ï¼Œ$\\beta$ å‘¢ï¼Ÿè¿™é‡Œå…ˆæŠ›å¼€ potential r-th keyï¼Œå¯¹äºæ¯ä¸€ä¸ªå¯èƒ½çš„ $\\alpha$ï¼Œ$\\beta$ï¼Œå»ºç«‹ä¸€ä¸ªè¡¨æ ¼ï¼ˆå‡è®¾è¿™é‡Œå–å€¼èŒƒå›´ä¸º 0x04ï¼‰: â€‹ B/A 0x01 0x02 0x03 0x04 0x01 0 0 0 0 0x02 0 0 0 0 0x03 0 0 0 0 0x04 0 0 0 0 â€‹ è®¾ $\\alpha$ çš„å€¼ä¸º $\\alpha_i$ï¼Œå¯¹åº”è¡¨æ ¼ä¸Šçš„æ¯ä¸€åˆ—ï¼Œå¯¹æ‰€æœ‰å·®å€¼ä¸º $\\alpha_i$ çš„æ˜æ–‡å¯¹ï¼Œè®¡ç®—å…¶ $\\beta$ å€¼å¹¶ä¸”åœ¨è¡¨æ ¼ä¸Šè®°å½•å‡ºç°é¢‘ç‡ï¼Œé¢‘ç‡æœ€é«˜çš„ $\\alpha-\\beta$ ä¸ºæœ€ä½³ characteristicã€‚ â€‹ â€‹ çœ‹æ‡‚åŸç†ä¹‹åï¼Œè·Ÿç€ soreatu å¤§ä½¬å¤ç°ä¸€æ³¢é¢˜ç›®ã€‚ â€‹ â€‹ WMCTF- idiot boxâ€‹ â€‹ é¢˜ç›®ç»™å‡ºçš„è¿œç¨‹æ–‡ä»¶ã€‚ â€‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import itertoolsfrom binascii import hexlify, unhexlifyimport Crypto.Random.random as randomfrom Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomNBitIntegerfrom secret import flagbanner = '''__ __ _ _ __ ____ __ ____ _____ _____\\ \\ / /__| | ___ ___ _ __ ___ ___ | |_ ___ \\ \\ / / \\/ |/ ___|_ _| ___| \\ \\ /\\ / / _ \\ |/ __/ _ \\| '_ ` _ \\ / _ \\ | __/ _ \\ \\ \\ /\\ / /| |\\/| | | | | | | \\ V V / __/ | (_| (_) | | | | | | __/ | || (_) | \\ V V / | | | | |___ | | | _| \\_/\\_/ \\___|_|\\___\\___/|_| |_| |_|\\___| \\__\\___/ \\_/\\_/ |_| |_|\\____| |_| |_|'''sbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30, 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]keys = []pc_key = [2, 13, 16, 37, 34, 32, 21, 29, 15, 25, 44, 42, 18, 35, 5, 38, 39, 12, 30, 11, 7, 20, 17, 22, 14, 10, 26, 1, 33, 46, 45, 6, 40, 41, 43, 24, 9, 47, 4, 0, 19, 28, 27, 3, 31, 36, 8, 23]def gen_key(): global keys key = getRandomNBitInteger(49) &amp; ((1 &lt;&lt; 48) - 1) key_bin = bin(key)[2:].rjust(48, '0') for i in range(6): key_bin = ''.join([key_bin[pc_key[j]] for j in range(48)]) sub_key = int(key_bin, 2) keys.append(sub_key)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 print(y_bin) return int(y_bin, 2)def F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef enc_block(x): x_bin = bin(x)[2:].rjust(64, '0') l, r = int(x_bin[:32], 2), int(x_bin[32:], 2) for i in range(6): l, r = r, l ^ F(r, keys[i]) y = (l + (r &lt;&lt; 32)) &amp; ((1 &lt;&lt; 64) - 1) return ydef enc(pt): pad_len = (8 - len(pt) % 8) % 8 pt = pt.encode() pt += b'\\x00' * pad_len ct = b'' for i in range(0, len(pt), 8): ct_block = long_to_bytes(enc_block(bytes_to_long(pt[i:i+8]))).rjust(8, b'\\x00') ct += ct_block return ctif __name__ == '__main__': print(banner) gen_key() print(keys) cipher = hexlify(enc(flag)).decode('utf8') print('[++++++++++++++++] FLAG [++++++++++++++++]') print(cipher) print('[+] You have up to 65537 chances to obtain the ct corresponding to the pt your input(&lt;= 64 bits and hex required).') for i in range(65537): pt = input() try: pt = unhexlify(pt) assert(len(pt) &lt;= 8) ct = enc(pt) print(hexlify(ct).decode('utf8')) except: print('[*] Read the above carefully!') break â€‹ â€‹ åˆ†ææºç ï¼Œé¢˜ç›®ç»™å‡ºäº†æ˜¯ä¸€ä¸ªè‡ªå·±å®ç°çš„ DESï¼Œæµ‹è¯•ä¸€ä¸‹ F Function çš„ characteristicï¼š â€‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from collections import Counterfrom Crypto.Util.number import getRandomNBitIntegersbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [\\ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30,\\ 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]def e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 # print(y_bin) return int(y_bin, 2)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef gen_diff_output(diff): p1 = getRandomNBitInteger(32) p2 = p1 ^ diff key = getRandomNBitInteger(48) c1, c2 = F(p1, key), F(p2, key) return c1^c2, (p1,p2,c1,c2)counter = Counter()for i in range(10000): P_ = 0x00002002 # \\alpha X_, _ = gen_diff_output(P_) counter[X_] += 1X_, freq = counter.most_common(1)[0]print(hex(X_)[2:].rjust(8,'0'), freq / 10000.0) # \\beta, probability# [0x00000000 0x00000000 1.0] # 0 is assure to be output 0# [0x00000002 0x00030005 0.2163]# [0x00000040 0x00000000 0.2554] # seems to be the best# [0x00002000 0x00000000 0.2492]# [0x00002002 0x00030005 0.052] â€‹ â€‹ $\\alpha\\;=\\;0x00000040$ï¼Œ$\\beta\\;=\\;0x00000000$ çš„ high-probability æ¯”è¾ƒæ˜æ˜¾ï¼Œå–ä¸€ä¸‹æ•°æ®ã€‚å€Ÿäº†ä¸‹å¸ˆå‚…çš„ä»£ç ï¼ŒCounter åŒ…çœŸå¥½ç”¨ ğŸ˜³ã€‚ â€‹ â€‹ â€‹ å†æŠ„ä¸€å¹…å›¾ï¼Œå˜¿å˜¿~ è¿™é‡Œæˆ‘åˆšå¼€å§‹è¿›å…¥äº†ä¸€ä¸ªè¯¯åŒºï¼Œå¦‚æœéå†æ‰€æœ‰ potential key çš„è¯ï¼Œå¤æ‚åº¦å¿…å¤§äº $O(2^{48})$ï¼Œä½†æ˜¯å¦‚æœå°† 48-bits çš„ potential key åˆ†æˆ 8 ä¸ª 6-bits çš„ S-boxesï¼Œå¤æ‚åº¦å¯ä»¥é™åˆ° $10000*O(2^{6+3})$ï¼Œå¤§æ¦‚æ˜¯ $O(2^{22})$ï¼Œå®Œå…¨æ²¡æœ‰æ¯›ç—…ã€‚ â€‹ å†è´´ä¸€ä¸ª F Function çš„ scheduleï¼š â€‹ â€‹ â€‹ DES çš„ F Function æµç¨‹å¦‚ä¸‹ï¼š â€‹ Expansion D-box : E( ) function XOR - key S-boxes : S( ) function Straight D-box : D( ) function â€‹ å¤§æ¦‚å°±æ˜¯ä¸€ä¸ªä¸¤è¾¹ä»ä¸­é—´é çš„è¿‡ç¨‹ï¼Œå†™å‡ºæ¥å°±æ˜¯ : â€‹ S(E(T\\_R{'})\\;\\oplus\\;K_i)\\;=\\;D^{-1}(F')\\;=\\;D^{-1}(T\\_L'\\;\\oplus\\;0x00000040)â€‹ è‡ªå·±å†™çš„ exp å°±ä¸è´´å‡ºæ¥äº†ï¼Œä»”ç»†çœ‹äº†ä¸€ä¸‹å¤§ä½¬çš„ï¼Œtqlï¼ â€‹ References:Breaking DES using Differential Cryptanalysis Case Study: Differetial Cryptanalysis Attack Differential Cryptanalysis â€‹ ç‰¹åˆ«è‡´è°¢ï¼š soreatu å¤§ä½¬","categories":[],"tags":[]},{"title":"å¼ºç½‘æ¯-2020-Review","slug":"å¼ºç½‘æ¯-2020-Review","date":"2020-09-09T00:52:19.000Z","updated":"2020-09-09T01:34:48.306Z","comments":true,"path":"2020/09/09/å¼ºç½‘æ¯-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/09/å¼ºç½‘æ¯-2020-Review/","excerpt":"","text":"baby_crt&nbsp;Infective CRT-RSAï¼Œçœ‹ä¸€ä¸‹å¤§æ¦‚çš„åŠ å¯†æµç¨‹ï¼š&nbsp;&nbsp;&nbsp;åœ¨çœ‹ä¸€ä¸‹éƒ¨åˆ†å‚æ•°çš„è®¾ç½®è¦æ±‚ï¼š&nbsp;$N, p, q, e, d$ å¸¸è§„ RSA ç”Ÿæˆã€‚&nbsp;&nbsp;&nbsp;&nbsp;é€‰æ‹©ä¸¤ä¸ªè¶³å¤Ÿå¤§çš„ç´ æ•° $t1, t2$ï¼Œbit_length åœ¨ $60~80$ã€‚é¢˜ç›®ç»™å‡ºçš„ $t1, t2$ è¿‡å°ï¼Œå­˜åœ¨é—®é¢˜ã€‚&nbsp;æœ‰å‡ ä¸ªå‚æ•°ä¸Šé¢æ²¡å†™ï¼Œè¡¥å……ï¼š d_p\\equiv\\;d\\mod\\;\\varphi(p\\;Â·\\;t_1)\\\\ d_q\\equiv\\;d\\mod\\;\\varphi(q\\;Â·\\;t_2)\\\\ d\\;Â·\\;e_{t_1}\\mod\\;\\varphi(t_1)\\\\ d\\;Â·\\;e_{t_2}\\mod\\;\\varphi(t_2)&nbsp;&nbsp;ç»§ç»­å¾€ä¸‹çœ‹ï¼Œçœ‹åˆ°ä¸€ç‚¹ä¸œè¥¿äº†:&nbsp;&nbsp;&nbsp;&nbsp;è¿™é‡Œ $c1$ èŒƒå›´ä¸º: 1~2^{16}&nbsp;å°±è¿™ï¼Œå°±è¿™ï¼Ÿ&nbsp;exp: 123456789101112131415161718import gmpy2e = 65537n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540p,q = 0,0sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246sig_e = pow(sig,e,n)# print(sig_e,n) check passfor i in range(65537): # print(i) # check pass p = gmpy2.gcd(pow(m,i,n) - sig_e,n) if p != 1: print(p) breakq = n // pprint(q)# flag&#123;601cb6f6d990ed5b89cf0de60508a95c07543793&#125; modestudy&nbsp;ç»™çš„ file å•¥ç©æ„å„¿ï¼Œç¯å¢ƒå…³äº†555ï¼Œä»¥åä¸€å®šä¸é¸½æ¯”èµ›ï¼","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"gactf-2020-Review","slug":"gactf-2020-Review","date":"2020-09-06T12:09:10.000Z","updated":"2020-09-08T08:24:54.505Z","comments":true,"path":"2020/09/06/gactf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/06/gactf-2020-Review/","excerpt":"","text":"æ¯”èµ›æœŸé—´æ‰“å·¥ï¼Œæ‰€ä»¥æ²¡æ€ä¹ˆçœ‹é¢˜ï¼Œå›é¡¾ä¸€ä¸‹ã€‚&nbsp; da vinci after rsayafu åˆ†è§£ n å¯ä»¥å¾—åˆ°ä¸‰ä¸ªè´¨æ•°ï¼Œè®¡ç®— $\\varphi$ å‘ç° $e | \\varphi$ï¼Œäºæ˜¯åŒ–ç®€ï¼š&nbsp;$ eâ€™\\;\\;=\\;\\;e\\;//\\;gcd(e,\\varphi(n))\\;=\\;5\\;,\\;dâ€™\\;=\\;invert(eâ€™,\\varphi(n)) $ï¼Œå¾—åˆ°ï¼š$c^{dâ€™}\\;\\equiv\\;m^5\\mod\\;n$ ã€‚&nbsp;çœ‹å¤§ä½¬çš„åšå®¢å¯ä»¥ç”¨ AMMï¼Œè‡ªå·±å®ç°äº†ä¸€éå‘ç°åªèƒ½æ±‚ä¸€ä¸ªæ ¹ï¼Œç›´æ¥ä¸Š sageã€‚&nbsp;&nbsp;1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesimport itertoolsc = 421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151pa = 9749pb = 11237753507624591pc = 9127680453986244150392840833873266696712898279308227257525736684312919750469261# factor with yafumas = GF(pa)(c).nth_root(5, all=True) # find 5-th root in modulus pa, so do belowmbs = GF(pb)(c).nth_root(5, all=True)mcs = GF(pc)(c).nth_root(5, all=True)# algl = True, which means find all roots, otherwise...# all = False is default# find all possible mms = [] for ma, mb, mc in itertools.product(mas, mbs, mcs): m = ZZ(crt(list(map(ZZ,[ma,mb,mc])), [pa,pb,pc])) mi = long_to_bytes(m) if mi[:4] == b'flag': flag = mi[5:-1]# b'weadfa9987_adwd23123_454f' &nbsp;&nbsp;åé¢æ˜¯ä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œç§˜é’¥æ˜¯ä¸€æ®µä¹±åºçš„æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ŒåŠ å¯†è§£å¯†çš„è¿‡ç¨‹æ˜¯ç§˜é’¥å’ŒåŸæ–æ³¢é‚£å¥‘æ•°åˆ—çš„æ˜ å°„å…³ç³»ã€‚è¿™é‡Œæ˜¯æŠŠ flag æŒ‰ç…§ encryption ä¸­çš„ key å†åŠ å¯†ä¸€éã€‚&nbsp;&nbsp;123456789101112# decrypt da vinci encryptionfb = [1,1]LEN = len(flag)while len(fb) &lt; LEN: fb.append(fb[-1] + fb[-2])fb[0] = 0enc = [0,28657,2,1,3,17711,5,8,13,21,46368,75025,34,55,89,610,377,144,233,1597,2584,4181,6765,10946,987]r_flag = [flag[fb.index(enc[i])] for i in range(LEN)]for i in r_flag: print(chr(i),end='') # w5aed4fa994f87_dwad3123_2 &nbsp;&nbsp;&nbsp; what_r_the_noise&nbsp;æ±‚å¹³å‡å€¼ã€‚ã€‚ã€‚&nbsp; elgamal_rsa&nbsp;&nbsp;yafu åˆ†è§£ secretï¼Œå¾—åˆ°ä¸€å †æ•°ã€‚ã€‚ã€‚æœ€é«˜å¹‚çš„ç´ æ•°ä¸ºï¼š$653551912583^{15}$ ã€‚&nbsp;ws åˆ†æä¸€æ³¢ï¼Œflag çš„é•¿åº¦ï¼š$2^{36*8} $ æ¯”æœ€é«˜å¹‚çš„ç´ æ•°è¦å°ï¼Œèˆ’æœï¼Œè·Ÿä¸Šé¢˜ä¸€æ ·ï¼Œèµ° AMMï¼Œä½†è¿˜æ˜¯è¦æ±‚å¤šä¸ªæ ¹ï¼Œå­¦ä¸€æ‰‹ã€‚&nbsp;å–æœ€é«˜å¹‚çš„ç´ æ•°ä¸º $n$ï¼Œ$eâ€™\\;=\\;e\\;//\\;gcd(e,\\;\\varphi(n))\\;=\\;2379$ ï¼Œ$dâ€™\\;=\\;invert(eâ€™,\\;\\varphi(n))$ ï¼Œ$câ€™\\;\\equiv\\;c^{dâ€™}\\;\\equiv\\;m^{gcd(e,\\;\\varphi(n))}\\mod\\;n$&nbsp;å€Ÿäº†ä¸€éƒ¨åˆ† tbå¸ˆå‚…çš„exp&nbsp;å¸ˆå‚… tqlï¼&nbsp;expï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from gmpy2 import gcd, invertfrom Crypto.Util.number import *import randome = 0x1296c = 255310806360822158306697936064463902328816816156848194779397173946813224291656351345682266227949792774097276485816149202739762582969208376195999403112665514848825884325279574067341653685838880693150001066940379902609411551128810484902428845412055387955258568610350610226605230048821754213270699317153844590496606931431733319116866235538921198147193538906156906954406577796507390570080177313707462469835954564824944706687157852157673146976402325057144745208116022973614795377968986322754779469798013426261911408914756488145211933799442123449261969392169406969410065018032795960230701484816708147958190769470879211953704222809883281592308316942052671516609231501663363123562942# factor through yafufac = [(42044128297, 6), (232087313537, 5), (653551912583, 15), (802576647765917, 7), (28079229001363, 14), (104280142799213, 6)]def AMM(q, r, delta, k=1): \"\"\" Adleman-Manders-Miller r-th Root Extraction Algorithm in F_q * Attention: - r and q satisfy r | q - 1 :param q: modulus q --&gt; int :param r: exponent r --&gt; int :param delta: remain --&gt; int :param k: the exponent of k, default is 1 --&gt; int :return: a r-th root of delta \"\"\" phi = pow(q, k-1)*(q-1) mod = pow(q, k) while True: # step1 &amp; step2 rho = random.getrandbits(mod.nbits()) % mod if pow(rho, phi//r, mod) == 1: break # step 3 s = phi t = 0 while s % r == 0: s //= r t += 1 assert(gcd(s, r) == 1) # check if s is coprimed with r assert(pow(r, t) * s == phi) alpha = invert(r, s) a, b, c, h = pow(rho, phi//r, mod), pow(delta, r * alpha-1, mod), pow(rho, s, mod), 1 # step 4 j, k = 0, phi // (r * s) for i in range(1, t): k //= r d = pow(b, k, mod) if d == 1: j = 0 else: j = - discrete_log(phi, d, a) b, h, c = b*(pow(c, r*j, mod)) % mod, h * \\ pow(c, j, mod) % mod, pow(c, r, mod) # step 5 return pow(delta, alpha, mod) * h % moddef allroot(root, r, q, k = 1): # find all roots phi = (q - 1) * q**(k - 1) mod = q ** k all_root = set() all_root.add(root) while len(all_root) &lt; r: new_root = root unity = pow(getRandomRange(2, mod), phi // r, mod) for i in range(r - 1): new_root = (new_root * unity) % mod all_root.add(new_root) return all_root# since 653551912583**15 &gt; 2**(36*8)n0 = 653551912583n = pow(653551912583, 15)phi = n * (653551912583 - 1) // 653551912583e_p = e // gcd(e, phi)d = invert(e_p, phi)c_p = pow(c, d, n)ar = allroot(AMM(n0,2,c_p,15),2,n0,15)for i in ar: print(long_to_bytes(i))# b'you_4re_good_at_b0th_el94mal_and_rs4' &nbsp;ä¸ç”¨ AMM çš„è¯ï¼Œç›´æ¥ä¸Š sage ä¹Ÿå¯ã€‚&nbsp;&nbsp; square&nbsp;å¹³æ–¹æ•°æ±‚å’Œå…¬å¼åŒ–ç®€æˆï¼š$6x^{2}\\;=\\;(y\\;+\\;1)(2y\\;+\\;1)$ï¼Œç„¶åå†è½¬æ¢æˆ pell æ–¹ç¨‹: $(4y\\;+\\;3)^2\\; -\\; 48x^{2} \\;=\\; 1$ã€‚&nbsp;&nbsp;å†ä»¤ $t\\;=\\;4y\\;+\\;3$ï¼Œæœ‰ï¼š$t^2\\;-\\;48x^{2}\\;=\\;1$ã€‚çˆ†ç ´èµ°å‡ºå‰å››ä½ï¼š$1,\\;7,\\;97,\\;1351$ï¼Œç„¶ååœ¨ oeis æ‰¾åˆ°é€’å½’å¼: a(m) = 14a(m-1) - a(m-2)&nbsp;æ‰¾åˆ°æ‰€æœ‰æ»¡è¶³ $t,\\;y$ çš„pell æ–¹ç¨‹çš„è§£ï¼Œç„¶åå†æ ¹æ® $t,\\;x$ çš„å…³ç³»æ±‚å‡º $x,\\;y$ï¼Œoeis æ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚&nbsp;exp å¦‚ä¸‹ï¼š&nbsp;12345678910111213141516171819202122232425262728293031323334353637383940414243444546# We can get something like pell equation: (4*y+3)^2 - 48*x^2 == 1# Write it into t^2 - 48*x^2 == 1\"\"\"for i in range(10000): for j in range(10000): if i ** 2 - 48 * j ** 2 == 1: print(i,j)Output:1 07 197 141351 195Formula: a(m) = 14a(m-1) - a(m-2)\"\"\"import gmpy2a = [1,7,97,1351]x = [1,7,97,1351]y = [0,1,14,195]while len(x) &lt; 120: ta = 14 * a[-1] - a[-2] a.append(ta) if ta % 4 == 3: x.append(ta)for i in range(4,len(x)): y.append(gmpy2.iroot((x[i]**2-1) // 48,2)[0])for i in range(4,120): x[i] = (x[i] - 3) // 4x = x[4:]y = y[4:]for i,j in zip(x,y): print(i,j)# check passfor i,j in zip(x,y): assert((4*i+3)**2 - 48*j**2 == 1) &nbsp;åšæŒï¼","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"CISCN2020-åˆèµ›-Writeup","slug":"CISCN2020-åˆèµ›-Writeup","date":"2020-08-24T07:00:22.000Z","updated":"2020-09-08T12:57:19.202Z","comments":true,"path":"2020/08/24/CISCN2020-åˆèµ›-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/08/24/CISCN2020-åˆèµ›-Writeup/","excerpt":"","text":"è¿™æ¬¡æ¯”èµ›éš¾åº¦ç®—æ˜¯ä¸­ç­‰ï¼Œç¥ä»™é¢˜å’Œç®€å•é¢˜å‚åŠã€‚ã€‚ã€‚&nbsp;&nbsp; bdç­¾åˆ°é¢˜ï¼Œè€ wiener äº†ï¼Œè®¡ç®— d çš„ä¸Šç•Œå¤§æ¦‚ä¸º 256 bitsï¼Œé¢˜ç›®ç»™çš„ d ä¸º 200 bitsï¼Œç›´æ¥ä¸Šè„šæœ¬ï¼š&nbsp;&nbsp;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-from gmpy2 import *from Crypto.Util.number import long_to_bytesdef continuedfra(x, y): cF = [] while y: cF += [x / y] x, y = y, x % y return cFdef simplify(ctnf): numerator = 0 denominator = 1 for x in ctnf[::-1]: numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator)def calculatefrac(x, y): cF = continuedfra(x, y) cF = map(simplify, (cF[0:i] for i in range(1, len(cF)))) return cFdef solve_pq(a, b, c): par = isqrt(b * b - 4 * a * c) return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerattack(e, n): for (d, k) in calculatefrac(e, n): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) / k p, q = solve_pq(1, n - phi + 1, n) if p * q == n: return abs(int(p)), abs(int(q)) print('not find!')n = 86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289e = 46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249c = 37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066p, q = wienerattack(e, n)d = invert(e, (p-1)*(q-1))m = pow(c,d,n)print(long_to_bytes(m))#flag&#123;d3752538-90d0-c373-cfef-9247d3e16848&#125; &nbsp;&nbsp;&nbsp; lfsr&nbsp;&nbsp;state ä»¥åŠ keystream ç»™å‡º 10000 bitsï¼Œflag ä¸º maskã€‚&nbsp;å°è¯•åˆ†æä¸åŒ cipher å’Œ output bits çš„å…³ç³»ï¼Œæ„å»ºå…³äº mask GF(2) ä¸‹çš„æ–¹ç¨‹ï¼Œæœªæœã€‚&nbsp;åœ¨ç½‘ä¸Šæ‰¾åˆ°ä¸€ä¸ªç±»ä¼¼çš„é¢˜ç›®ï¼Œæ˜¯ SJTU-CTF-2019çš„ä¸€é“: é¢˜ç›® :&nbsp;è¿™é¢˜åªæ˜¯åŸé¢˜çš„å…¶ä¸­ä¸€æ­¥ã€‚æœ‰ä¸€ä¸ª Berlekamp-Massey Algorithm ç®—æ³•ï¼Œç”¨äºæ„é€ ä¸€ä¸ªæœ€çŸ­çš„ LFSR ä»¥æ»¡è¶³ç»™å®šçš„äºŒè¿›åˆ¶è¾“å‡ºåºåˆ—ã€‚äºæ˜¯ä½¿ç”¨ç»™å‡ºçš„ 10000 bitsä¸­çš„å‰ 200 bitsã€‚Berlekamp-Massey Algorithm ï¼Œè¿™ç©æ„å„¿æœ‰ç°æˆçš„åœ¨çº¿å·¥å…· ã€‚ ç®—å‡ºæœ€çŸ­çš„ maskï¼Œç„¶åå»æ‰é¦–ä¸€ï¼Œè½¬ä¸ºåè¿›åˆ¶ï¼Œæ­£æ˜¯ flagã€‚&nbsp;&nbsp;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960In [15]: s= s[1:] In [16]: s Out[16]: ['99', '97', '95', '94', '91', '90', '89', '86', '84', '82', '76', '75', '74', '73', '66', '64', '62', '61', '60', '59', '58', '57', '56', '55', '52', '51', '46', '44', '43', '40', '38', '36', '32', '30', '29', '27', '26', '23', '22', '19', '18', '17', '15', '14', '13', '11', '5', '4']In [34]: res Out[34]: '1010110011100101010000011110000001010111111110011000010110010101000101101100110011101110100000110000'In [35]: int(res,2) Out[35]: 856137228707110492246853478448#flag&#123;856137228707110492246853478448&#125; &nbsp;ç”±äºå½“æ—¶æ€¥æ€¥å¿™å¿™å…ˆæŠŠé¢˜ç›®åšå‡ºæ¥äº†ã€‚ã€‚ç°åœ¨å­¦ä¹ ä¸€ä¸‹åŸç†ã€‚&nbsp;&nbsp;&nbsp;Berlekamp-Massy Algorithm å¯ä»¥æ ¹æ®ç»™å‡ºçš„ keystreamï¼Œ æ‰¾å‡ºèƒ½ç”Ÿæˆè¿™ä¸ªkeystream çš„æœ€çŸ­ LFSR/Tapã€‚ç†è®ºä¸Šç»™å‡ºçš„ keystream è¿œå¤§äº tap çš„é•¿åº¦æ—¶ï¼Œå‡†ç¡®åº¦æé«˜ã€‚&nbsp;è¿™ä¸ªç®—æ³•ä¹Ÿå¯ä»¥åœ¨ä»»æ„çš„ field ä¸­æ‰¾åˆ°çº¿æ€§é€’å½’åºåˆ—çš„æœ€å°å¤šé¡¹å¼ã€‚&nbsp;&nbsp;çœ‹ä¸€ä¸‹ wiki çš„æè¿°ï¼š&nbsp;&nbsp;&nbsp;$S_n$ åœ¨è¿™é‡Œæ˜¯ LFSR çš„ keystreamï¼Œ$C_n$ åˆ™æ˜¯ LFSR çš„ tapã€‚æ•´æ¡å¼å­çš„æ„æ€æ˜¯ï¼Œå‡è®¾ tap çš„é•¿åº¦ä¸º $L$ï¼Œé‚£ä¹ˆç¬¬ $L+1$ ä¸ªå€¼ä¸å‰ $L$ ä½äº§ç”Ÿçš„ output çš„å¼‚æˆ–å€¼ä¸º0ã€‚è€Œç®—æ³•çš„ç›®çš„æ˜¯æ‰¾åˆ°è¿™ä¸ªé•¿åº¦ä¸º $L$ çš„ $C_n$ã€‚&nbsp;&nbsp;æˆ‘ä»¬ç€é‡çœ‹ä¸€ä¸‹ binary field/GF(2) çš„åŸºæœ¬è¿ç®—ã€‚&nbsp;&nbsp;&nbsp;å…ˆå›é¡¾ä¸€ä¸‹äºŒè¿›åˆ¶è¿ç®—ã€‚GF(2) ä¸­ è¿ç®— æ“ä½œ åŠ æ³•/å‡æ³• å¼‚æˆ– ä¹˜æ³• é€»è¾‘ä¸ é™¤æ³• å•ä½å…ƒè¿ç®—/å®šä¹‰ä¸ºâ€™x/1=xâ€™ &nbsp;&nbsp;è¯¦ç»†çœ‹ä¸€ä¸‹ç®—æ³•æ­¥éª¤ï¼š&nbsp;&nbsp;æœ‰ç‚¹æ‡µé€¼å•Šã€‚ã€‚ã€‚å…ˆç•™ä¸ªå‘&nbsp; rsa&nbsp;ç¥ä»™é¢˜ï¼Œå¬è¯´ 32 æ ¸å‡ ç§’ factor successï¼Ÿï¼Ÿï¼Ÿè‡ªå·±å°è¯•äº†ä¸€ä¸‹å‘ç°ä¸å¤ªè¡Œã€‚ã€‚ã€‚tcl ç­‰ä¸€æ‰‹ wp&nbsp;&nbsp; Reference&nbsp; https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm&nbsp;&nbsp;","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"RSA-Learning","slug":"RSA-Learning","date":"2020-08-03T13:22:37.000Z","updated":"2020-08-07T09:18:40.543Z","comments":true,"path":"2020/08/03/RSA-Learning/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/RSA-Learning/","excerpt":"","text":"ä»Šå¤©çœ‹äº†ä¸€ç¯‡ RSA çš„paperï¼Œæ€»ç»“çš„ä¸é”™ï¼Œç®€å•åœ°åšä¸‹ç¬”è®°ã€‚ RSA æ˜¯åŸºäº Factoring Large Integers Problem çš„å…¬é’¥å¯†ç ä½“åˆ¶ã€‚ Elementary AttacksCommon Modulusâ€¦. Blindingå‡ºç°åœ¨ä¸ç» padding å’Œ check çš„ RSA signiture ä¸­ï¼Œå¦‚æœç­¾åæ–¹ä¸ä»”ç»†å®¡æŸ¥æ˜æ–‡ï¼Œæ”»å‡»è€…å¯ä»¥ä¼ªé€ æŸäººå¯¹äºä»»ä½•å†…å®¹çš„ç­¾åã€‚ cheat å¤§è‡´è¿‡ç¨‹å¦‚ä¸‹ï¼š æ•´ä¸ªè¿‡ç¨‹ç§°ä¸º blindingï¼Œæ˜¯å› ä¸º Bob æ²¡èƒ½å¾—çŸ¥ä»–è¦ç­¾åçš„å†…å®¹ã€‚ç­¾åæ–¹åœ¨ç­¾åå‰æ£€æŸ¥å†…å®¹èƒ½å¤Ÿé˜²æ­¢è¿™ä¸ªé—®é¢˜ã€‚ Low Private Exponentä½è§£å¯†æŒ‡æ•°æ”»å‡»ã€‚ d çš„å¤§å°ä¼šå½±å“è§£å¯†çš„æ—¶é•¿ã€‚ä¸ºäº†é€Ÿåº¦ä¸Šçš„è¦æ±‚ï¼Œæœ‰äººä¼šå°† d è®¾ç½®çš„æ›´å°ã€‚M.Wiener æå‡ºçš„æ”»å‡»æ–¹æ³•å¯¹å¾ˆå°çš„ d çš„ RSA ç³»ç»Ÿå¸¦æ¥å¨èƒã€‚ Theorem 2(M. Wiener): Proof:è¯æ˜è¿‡ç¨‹åˆ©ç”¨è¿åˆ†æ•°ã€‚å› ä¸º $ed\\;\\equiv\\;1\\mod\\;\\varphi(N)$ï¼Œæ‰€ä»¥å­˜åœ¨ä¸€ä¸ª k æ»¡è¶³: $ed\\;-\\;k\\varphi(N)\\;=\\;1$ï¼Œ å› æ­¤æœ‰ï¼š \\left|\\frac{e}{\\varphi(N)}\\;-\\;\\frac{k}{d}\\right|\\;=\\;\\frac{1}{d\\varphi(N)}æ‰€ä»¥å¯ä»¥æŠŠ $\\frac{k}{d}$ çœ‹æˆæ˜¯ $\\frac{e}{\\varphi(N)}$ çš„å¤§æ¦‚å€¼ã€‚ç„¶åå› ä¸º $\\varphi(N)\\;=\\;N\\;-\\;p\\;-\\;q\\;+\\;1$ ä»¥åŠ $p\\;+\\;q\\;-\\;1\\;&lt;\\;3\\sqrt{N}$ æ‰€ä»¥æœ‰ï¼š è®¡ç®— $\\frac{e}{N}$ çš„è¿åˆ†æ•°ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªè§£ç­‰äº $\\frac{k}{d}$ï¼Œç”±äº $ed\\;-\\;k\\varphi(N)\\;=\\;1$ï¼Œæ‰€ä»¥ $gcd(k, d)\\;=\\;1$ ï¼Œå³ $\\frac{k}{d}$ ä¸ºçœŸåˆ†æ•°ã€‚çº¿æ€§æ—¶é—´å¯ä»¥è§£å¾— dã€‚ LimitsLarge e:å¯¹è§£å¯†æŒ‡æ•°è¿›è¡Œæ”¹è¿›ï¼Œä»¤ $eâ€™\\;=\\;e\\;+\\;t\\varphi(N), t\\;is\\;large\\;enough$ï¼Œ$eâ€™$ ä½œä¸ºæ–°çš„åŠ å¯†æŒ‡æ•°: Using CRTä¿è¯ d çš„ bit size çš„åŒæ—¶ï¼Œä½¿ç”¨ CRT å¯¹è§£å¯†æ¥æå‡è§£å¯†é€Ÿåº¦ã€‚è®¡ç®—ï¼š d_p\\;\\equiv\\;d\\;\\mod(p\\;-\\;1)\\\\ d_q\\;\\equiv\\;d\\;\\mod(q\\;-\\;1)å¹¶ä¸” $d_q$ å’Œ $d_p$ è¶³å¤Ÿå°(128 bits each)ã€‚ç„¶åè®¡ç®—ï¼š M_p\\;\\equiv\\;C^{d_p}\\mod\\;p\\\\ M_q\\;\\equiv\\;C^{d_q}\\mod\\;qæœ€å CRTï¼š \\begin{cases} M\\;\\equiv\\;C^{d_p}\\mod\\;p \\\\\\\\ M\\;\\equiv\\;C^{d_q}\\mod\\;q \\end{cases}$d_p$ å’Œ $d_q$ è¿‡å°ä¼šå¯¼è‡´ N å®¹æ˜“åˆ†è§£ã€‚ Boneh and Durfee æ–¹æ³•å¯ä»¥å°†ä¸Šç•Œæåˆ° $d &lt; N^{0.292}$ Low Public Exponentæ•°å­—ç­¾åä¸­ï¼Œe çš„å¤§å°ä¼šå½±å“éªŒè¯çš„è®¡ç®—æ—¶é•¿ã€‚e è¿‡å°ä¼šå¯¼è‡´ä½åŠ å¯†æŒ‡æ•°æ”»å‡»ã€‚ Coppersmithâ€™s TheoremTheorem 3(Coppersmith) Coppersmith æä¾›äº†ä¸€ä¸ªå¿«é€Ÿå¯»æ‰¾ $f(x_0)\\;\\equiv\\;0\\;\\mod\\;N$ æ ¹çš„æ–¹æ³•ã€‚ Lemma 4 Proofç”± Schwarz inequality å¯å¾—ï¼š \\left|h(x_0)\\right|\\;=\\;\\left|\\sum{a_i}x_{0}^{i}\\right|\\;=\\;\\left|\\sum{a_i}X^{i}(\\frac{x_0}{X})^{i}\\right|\\;\\leq\\;\\sum\\left|a_{i}X^{i}(\\frac{x_0}{X})^i\\right|\\\\ \\leq\\;\\sum\\left|a_{i}X^{i}\\right|\\;\\leq\\;\\sqrt{d}||h(xX)||\\;\\leq\\;Nç”±äº $h(x_0)\\;\\equiv\\;0\\;\\mod\\;N$ï¼Œæ‰€ä»¥æœ‰ $h(x_0)\\;=\\;0$ ã€‚å‰ææ˜¯ h çš„èŒƒæ•°è¶³å¤Ÿå°ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°å¦å¤–ä¸€ä¸ªèŒƒæ•°æ›´å°çš„å¤šé¡¹å¼ã€‚æ»¡è¶³ä¸Šé¢çš„æ¡ä»¶ã€‚ Coppersmith æä¾›äº†ä¸€ä¸ªæ–¹æ³•ï¼š m æ˜¯æœªçŸ¥çš„å¸¸é‡ã€‚æˆ‘ä»¬ä» $g_{u,v}(x)\\;\\equiv\\;0\\;\\mod\\;N^m$ ä¸­æ‰¾åˆ°ç¬¦åˆ $norm(h(xX))\\;&lt;\\;N^m$ çš„å¤šé¡¹å¼ã€‚m è¶³å¤Ÿå¤§çš„æ—¶å€™æœ‰å¤šä¸ªè§£ã€‚ æ‰¾åˆ°è¿™ä¸ªåˆé€‚çš„å¤šé¡¹å¼éœ€è¦æ„é€ æ ¼ï¼š Hermiteâ€™s bound è¯´æ˜ $m$ è¶³å¤Ÿå¤§çš„æ—¶å€™ï¼Œå¯ä»¥æ‰¾åˆ° $ norn(v) &lt; N^m$ çš„å‘é‡ã€‚ Fact 5(LLL) LLL æ»¡è¶³ Lemma 4 çš„æ¡ä»¶ï¼š 2^{\\frac{w}{4}}det(L)^{\\frac{1}{w}}\\;","categories":[],"tags":[{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"}]},{"title":"De1ta-CTF-2020-Review","slug":"De1ta-CTF-2020-Review","date":"2020-08-03T03:40:01.862Z","updated":"2020-08-03T07:05:31.815Z","comments":true,"path":"2020/08/03/De1ta-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. nlfsr(unsolved)This challenge consists of 4 linear feedback shift registers (below I use LFSR instead), with accordingly 19 bits, 19 bits, 6 bits and 3 bits state length. Here is the given file: quiz.py 12345678910111213141516171819202122232425262728from flag import a, b, c, d, flagassert flag == \"De1CTF&#123;\" + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \"&#125;\"assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6]ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i &amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ dodef genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\"data\", \"w+\").write(s)genkey(128*1024) data 1a string that comprises of 128*1024*8 bits(only zero or one) ExplanationThere are four LFSR in quiz.py and each round, four LFSR simultaneously compute four according output. Then the combination function combines these four bits and output the combination result into file data. ConditionSince LFSR is the basic knowledge for us, there will more no more explanation on it. So letâ€™s see what we have got from the files. the initial state length of each LFSR the taps of each LFSR a combination function many rounds combination results It seems to be a simple quiz because we have already known the taps of each LFSR. However, each output of four LFSR is combined as one bit, from which we can hardly retrieve the outputs of four LFSR. If we use pure brute-force attack method, the complexity would be: O(2^{47}) Such a large scale. We must relate one or some output of four LFSR to the combination result and solve the each state independently. We can use a strategies called correlation attack in stream cipher. DetailsWe first look into each possible situation of four LFSR and write down the result. ao bo co do combine 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 In the table, ao represents the single output of LFSR-1 and so on. It is very obvious that ao has 75% correlation with the combination output, and we also know that if we have the correct initial state of LFSR-1, three out of four output of LFSR-1 will be the same as the combination bits. As a result, we can independently search the initial state of LFSR-1, and the correct initial state should be the fittest one. Now the complexity comes down to: O(2^{19}+2^{28})=O({2^{28}})This is already considerable in brute-force attack method (I use approximately 3 hours with C++, half a day with python to solve). But sadly, outputs of other LFSR just has 50% correlation with the combination output (actually no correlation). We can look into the combination function: 1(ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do And interestingly it can be transformed into: 1(ao*bo) ^ ((bo^1) * (co^do)) Calculating the XOR result of co and do by ourselves, we can surprisingly find that there is correlation between (co^do) and the combination result. Try to write down the table again. ao bo co^do combine 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 Again we can know from the table that (co^do) has 75% correlation with the combination output, which is the same as ao. There the complexity comes down again to: O(2^{19}+2^{9}+2^{19})=O(2^{20})The complexity is very considerable now. RealizationOfficial realization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf8import timema, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31key = open(\"data\").read()def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def calcR(x, y): assert len(x) == len(y) cnt = 0.0 for i, j in zip(x, y): cnt += (i == j) return cnt / len(x)def brutea(nb): relation, reala = 0, 0 for i in range(0, 2 ** 19): s = '' a = i for j in range(nb * 8): a = lfsr(a, ma) s += str(a &amp; 1) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, reala = r, i print(reala, relation) return realadef brutecd(nb): relation, realc, reald = 0, 0, 0 for i in range(0, 2 ** 6): d = i for j in range(0, 2 ** 13): c = j s = '' for k in range(nb * 8): c = lfsr(c, mc) d = lfsr(d, md) s += str((c &amp; 1) ^ (d &amp; 1)) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, realc, reald = r, j, i print(realc, reald, relation) return realc, realddef bruteb(nb, a_, c_, d_): for i in range(0, 2 ** 19): b = i a, c, d = a_, c_, d_ s = '' for j in range(nb * 8): a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [k &amp; 1 for k in [a, b, c, d]] s += str((ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do) if s == key[:nb * 8]: print(i) return iif __name__ == \"__main__\": start_time = time.time() print(start_time) a = brutea(20) c, d = brutecd(20) b = bruteb(20, a, c, d) \"De1CTF&#123;%s&#125;\" % (''.join([hex(i)[2:] for i in [a, b, c, d]])) end_time = time.time() print(\"Used time:\", end_time - start_time)# De1CTF&#123;58bb578d5611363f&#125; Other challenges still remain confused. What I have doneI spent half of my afternoon writing this article, and I still have a long way to go. Keep on learning IELTS and number theory. Things to Learn and Improve How to use sage Do a review on wangdibei References https://en.wikipedia.org/wiki/Correlation_attack","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"å¤©ç¿¼æ¯-2020-Writeup","slug":"å¤©ç¿¼æ¯-2020-Writeup","date":"2020-07-31T15:00:19.000Z","updated":"2020-08-24T03:28:24.850Z","comments":true,"path":"2020/07/31/å¤©ç¿¼æ¯-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/07/31/å¤©ç¿¼æ¯-2020-Writeup/","excerpt":"","text":"æ¯”èµ›æ’å¾—å¾ˆå¯†ï¼Œgkd æŠŠ writeup å†™äº†ã€‚ easyRSAç­¾åˆ°é¢˜ï¼Œå¯¹äºæ¯ä¸€æ¬¡åŠ å¯†ï¼Œæ˜æ–‡ç©ºé—´å°ï¼Œäºæ˜¯ç›´æ¥éå†ã€‚ 1234567891011121314n = ...cipher = ...import stringe = 11299plaintext = ''for i in range(len(cipher)): for s in string.printable: if pow(ord(s),e,n) == cipher[i]: plaintext += s print(plaintext) break hardRSAå·²çŸ¥ d ä½ 539 ä½ï¼Œq ä¸º 510 ä½ï¼Œè®¡ç®—ä½ä½ q çš„æ–¹æ³•å¯ä»¥ç›´æ¥è·å¾— qã€‚ 12345678910111213141516171819202122232425262728import gmpy2from Crypto.Util.number import long_to_bytesdef find_q(d0, kbits, e, n, p): X = var('X') for k in range(1, e+1): results = solve_mod([e*d0*X - k*(p-1)*X*(n//p-X+1) + (p-1)*k*(n//p) == X], 2^kbits) for x in results: q0 = ZZ(x[0]) if n % q0 == 0: return q0if __name__ == '__main__': n = 12723332779402711330767180202990021139894727917028981722242076998825097254419567024122271773380821224949951558669351311750240296591612098048129709925844660421849429715755474874708286508736369884566273719494870891070006251521469139401722700298201541140391493575314714966432624976434199682124684035067305114749262672684081617896579640435891181745346695293618235303178334371123418790204709073465264408888007492994820133128499094347122686903153588634296508454120927 e = 7 p = 3141886348112988339174865432179206412942588390228169645162293920470188882447855208783220899752887620221059861467348059334030873350571979462363834615231089 c = 8696771272015513736887843395612361647314297287781507609196936354183211655364744684164300710583625473872942712063309507651496314800393009480421886926137403759228421858414833429980059903049311837014449093365911603108158352871851677457256058510822509157407703210866317472894586087554001158540951787167699161720491198674848526093644131709561995379565643716017359731201935855247285498574923656191121426618306186331615280461405913653781283860760013215603007314688132 d0 = 0x414946b9c40728f9801e61e98ec6d17525cbe4163a5ffb8367b65c652ae4cc3abce62e70afbfb84fcf937b3119953b48922be19ef4312c4f3a88313368ca6c9b1d658b7 nbits = n.nbits() kbits = d0.nbits() q = find_q(d0, kbits, e, n, p) r = n // q // p phi = (r - 1) * (p - 1) * (q - 1) d = gmpy2.invert(e,phi) print(long_to_bytes(pow(c,d,n))) å¿½ç•¥ä¸€ä¸‹æ¨å¯¼è¿‡ç¨‹äº†ã€‚ã€‚ AliceHomeworkLLL æ²¡è·‘å‡ºæ¥ï¼Œç–‘æƒ‘.jpg PolyCryptoæ²¡æ—¶é—´çœ‹é¢˜ã€‚ã€‚ã€‚tcl","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"3kctf-2020-Review","slug":"3kctf-2020-Review","date":"2020-07-27T06:21:11.000Z","updated":"2020-08-03T03:26:54.575Z","comments":true,"path":"2020/07/27/3kctf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/","excerpt":"","text":"pyzzle1Given a cst tree code, use libcst package in python to transform it into source code: 123456from libcst import *abc = Module(....)with open('...','w') as f: f.write(str(abc.code)) Here is the source code in python: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import binasciiplaintext = \"REDACTED\"def exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempdef BinaryToDecimal(binary): string = int(binary, 2) return string# encryptionPT_Ascii = [ord(x) for x in plaintext]PT_Bin = [format(y, '08b') for y in PT_Ascii]PT_Bin = \"\".join(PT_Bin)n = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showL1 = PT_Bin[0:n]R1 = PT_Bin[n::]f1 = exor(R1, K1)R2 = exor(f1, L1)L2 = R1f2 = exor(R2, K2)R3 = exor(f2, L2)L3 = R2R3 = '''''' # Too long to showL3 = '''''' # Too long to showcipher = L3+R3# # decryption (redacted)# plaintext = L6+R6# plaintext = int(plaintext, 2)# plaintext = binascii.unhexlify('%x' % plaintext)# print(plaintext) This is a pretty easy structure, we can easily recover plaintext by: 1234567891011121314151617181920212223242526272829import binasciidef exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempn = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showR3 = '''''' # Too long to showL3 = '''''' # Too long to showR2 = L3L2 = exor(exor(K2, R2), R3)R1 = L2L1 = exor(exor(K1, R1), R2)plaintext = L1+R1plaintext = int(plaintext, 2)plaintext = binascii.unhexlify('%x' % plaintext)plaintext = binascii.unhexlify(plaintext)print(plaintext) The flag is : 3k{almost_done_shizzle_up_my_nizzle} Once_upon_a_timeGiven a program and encrypted flag: scss : program entrance main.c cipher.c flag_encrypted â€¦ Excellent realization of LFSR and block cipher encryption in C. We notice that the initial vector is fixed, 0xa2 :) Addtionally, the key is fixed too, which means we can always get the same key stream. Moreover, I find something wired in cipher.c: 123case ECB: temp_ciphertext = temp_keystream ^ temp_plaintext; break; We can create a file with only â€˜\\x00â€™ and encrypt it in ECB mode to get the keystream. Since there are five modes, we can only try every situations. Woooool, finally catch ya! OFB! 12345678910In [20]: plaintext = '' In [21]: for i in range(113): ...: iv = iv ^ keystream[i] ...: temp = iv ^ cipher[i] ...: plaintext += chr(temp) ...: In [22]: plaintext Out[22]: '3k&#123;my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail&#125;' The flag is : 3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail} You shall not get my cookiesGiven an example cipher, and if the cipher can be correctly decrypted, it will send â€œNopâ€ back. I follow the write up here: https://ctftime.org/writeup/22602 Notice that there is an error in the write up above: if the length of a block is 16 bytes, it will be appended a block of sixteen â€˜\\x16â€™ according to PKCS#7 padding principle. Here is my exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-from pwn import *from Crypto.Util.number import bytes_to_long# context.log_level = 'debug'target = 'youshallnotgetmycookies.3k.ctf.to'port = 13337cipher = \"6F6A6A2C6E780D070A19001707060C0D\"suffix = ''fake_iv = ''dc = ''try: for i in range(1,17): assert(len(dc) == 2*(i-1)) for j in range(0x100): guess = hex(j)[2:].upper().zfill(2) fake_iv = '00' * (16-i) + guess + suffix print('[-]' + fake_iv) p = remote(target, port) p.sendlineafter('So... whats your cookie: ', fake_iv + cipher) res = p.recvall(timeout=4) p.close() res = res.decode() if len(res) == 11: pad = bytes([i]) dc = hex(int(guess, 16) ^ bytes_to_long(pad))[2:].upper().zfill(2) + dc suffix = hex(int(dc, 16) ^ bytes_to_long(bytes([(i+1)]) * i))[2:].upper().zfill(i*2) print('[-] D(C1) '+ dc) break print('[-] D(C1) '+ dc)except pwnlib.exception.PwnlibException: pass# 1C091F451A0B070D00130A1D0D0C0607 for the first block to be d(C2)# B0A608DDC37A458EEC0B74D37E888E8A for the second block# ...3B143145885BB42C94 for the third block# C2# 90C560B2A01529EF986E54B016E1FEAA# C1# 6F6A6A2C6E780D070A19001707060C0D# Calculate d(C1)# 218A7AEECEFB49CADF3D227AD84A21CF# Calculate C0# 6CEB0A82ABDB06ABAB50471BB46A63A6# The whole fake cipher:# 6CEB0A82ABDB06ABAB50471BB46A63A66F6A6A2C6E780D070A19001707060C0D90C560B2A01529EF986E54B016E1FEAA It cost 2 hours running this script twice.","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-First-Half-Review","slug":"2020-First-Half-Review","date":"2020-06-30T15:23:46.000Z","updated":"2020-07-17T02:47:27.086Z","comments":true,"path":"2020/06/30/2020-First-Half-Review/","link":"","permalink":"https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/","excerpt":"","text":"2020 å·²ç»è¿‡åŠï¼Œæ–°å¹´çš„é’Ÿå£°ä»¿ä½›ä»ç„¶è¦ç»•åœ¨è€³è¾¹ã€‚æ—¶é—´è¿‡å¾—å¤ªå¿«ï¼Œç•™ä¸‹çš„å¤ªå°‘ã€‚ å›é¡¾ä»Šå¹´çœŸçš„å¾ˆç‰¹åˆ«å•Šï¼ŒäºŒæœˆä»½çš„æ—¶å€™è¿˜æŠ±ç€å›å­¦æ ¡ä¸Šè¯¾çš„æƒ³æ³•ï¼Œç°åœ¨å·²ç»ä¸Šäº†ä¸€å­¦æœŸçš„ç½‘è¯¾ã€‚å¯¹äºç½‘è¯¾å’Œå›å­¦æ ¡ä¸Šè¯¾ï¼Œæˆ‘æ˜¯ååè€…çš„ã€‚è¦çŸ¥é“ï¼Œå¾…åœ¨å®¶é‡Œå­¦ä¹ æ•ˆç‡ä¸åˆ°å­¦æ ¡çš„ååˆ†ä¹‹ä¸€ï¼šï¼‰ä¸è¿‡è¿˜å¥½ï¼Œç°åœ¨å¥½åƒæ…¢æ…¢ä¹ æƒ¯ä¸‹å»äº† hhhhh æœ¬æ¥æ˜¯äºŒæœˆåº•å¼€å­¦çš„ï¼Œä¸è¿‡å­¦æ ¡è¯´æ¨è¿Ÿå¼€å­¦ï¼ˆä¸å¸¦ç½‘è¯¾çš„é‚£ç§ï¼‰ã€‚å¥½å§ï¼Œç­‰åˆ°ä¸‰æœˆä»½ï¼Œç›¼äº†è®¸ä¹…è°çŸ¥æ”¹æˆç½‘è¯¾ï¼ˆç›´æ¥è£‚å¼€&gt;_&lt;ï¼Œç½‘è¯¾==è‡ªå­¦ã€‚ä¸å¾—ä¸è¯´ï¼Œè¿™åŠå¹´å¤„äºçœŸÂ·ç™½å­¦é˜¶æ®µï¼Œç™½å­¦èƒ½åŠ›æé«˜äº†ä¸å°‘ã€‚ ä¸€æœˆä¸»è¦åœ¨å­¦äº† Matlab ç¼–ç¨‹å’Œ Latexï¼Œä»åŸºæœ¬è¯­æ³•åˆ°ç”»å›¾ï¼Œå†åˆ°å¦‚ä½•ç”¨ Latex å†™å‡ºä¸€ç¯‡ nice çš„è®ºæ–‡ã€‚å­¦è¿™ä¸ªä¸»è¦æ˜¯ä¸ºäº†å‡†å¤‡æ•°æ¨¡ï¼Œä¸è¿‡å¬è¯´æ¯•ä¸šè®ºæ–‡è¦ç”¨ Latex 2333ã€‚å› ä¸ºå¯’å‡å‰æœ‰ä¸ªæœ‹å‹æ‹‰æ•°æ¨¡ç¾èµ›ï¼Œè‡ªå·±æ„Ÿè§‰æƒ³è¯•è¯•ï¼ˆè¯´ä¸å®šå¥½å¥½å­¦èƒ½æ‹¿ä¸ªå¥–ã€‚äºæ˜¯å°±æŠ¥åå»äº†ï¼ŒæŠ¥åè´¹ä¹Ÿä¸ä¾¿å®œã€‚åé¢å»å¬äº†å¬é‚£è¾¹çš„åŸºç¡€è¯¾ï¼Œå»ºæ¨¡å¯¹æ•°å­¦è¦æ±‚è¿˜æ˜¯æŒºé«˜çš„ï¼Œæœ‰ç‚¹æ‡µã€‚åé¢æœ‹å‹è¯´è®©æˆ‘å­¦å­¦ Matlab ç¼–ç¨‹ã€‚åŸºç¡€å­¦ä¸‹æ¥å…¶å®ä¹Ÿä¸ç”¨èŠ±å¾ˆé•¿æ—¶é—´ï¼Œä½†æ˜¯æ‹–ç€æ‹–ç€åˆ°äºŒæœˆä»½å»äº†ã€‚ä¸è¿‡å›æƒ³é‚£ä¸ªæ—¶å€™ï¼Œè‡ªå·±è·Ÿç€ç½‘ä¸Šæ•™ç¨‹èµ°ï¼Œè¿˜æ˜¯ä¸é”™çš„ã€‚ ç¾èµ›åœ¨ä¸‰æœˆä»½ï¼ŒåŸºç¡€æå¥½äº†ä»¥åå°±å¼€å§‹æ”¾é£è‡ªæˆ‘äº†ï¼ˆçœŸå°±åªæäº†åŸºç¡€ wdtã€‚å…¶å®ä¸»è¦æ˜¯å‘ç°è‡ªå·±å¤ªä¹…æ²¡æå­¦ç§‘äº†ï¼Œäºæ˜¯åˆè·‘æ¥è¿™è¾¹å­¦å­¦ã€‚æå‡ºä¸€ä¸ªã€Šå¿«ä¹çš„ Linux å‘½ä»¤è¡Œã€‹ï¼Œä¹Ÿå¿˜äº†æ˜¯è°å‘ç»™æˆ‘çš„äº†ï¼Œç³»ç»Ÿåœ°è¿‡ä¸€é Linuxã€‚ä»æ–‡ä»¶ç³»ç»Ÿè·³è½¬åˆ° vim å¤„ç†æ–‡æœ¬ å†åˆ°è½¯ä»¶åŒ…ç®¡ç†ï¼Œæœ€å shell ç¼–ç¨‹ï¼Œé€”ä¸­é¡ºä¾¿æ¡å›äº†æ­£åˆ™è¡¨è¾¾å¼ã€‚çœ‹çš„æ—¶å€™å…¶å®çœŸçš„æœ‰å¾ˆå¤§æ„Ÿè§¦ã€‚çœ‹æ‡‚å‘½ä»¤ï¼Œæé«˜ä¸»åŠ¨æ€§ï¼Œè¿™æ˜¯æˆ‘æ‚Ÿå‡ºçš„ä¸€ç‚¹ã€‚æœ€è¿‘é€‰è¯¾çªç„¶å‘ç°ä¸‹å­¦æœŸæœ‰ä¸€é—¨å«ã€Šæ“ä½œç³»ç»Ÿå®è·µã€‹çš„è¯¾ï¼Œè®²å¾—å°±æ˜¯ Linux å‘½ä»¤2333 ç¾èµ›é‚£ä¸‰å¤©æ¯å¤©åªç¡äº†6ä¸ªå°æ—¶ï¼Œè´Ÿè´£ç¼–ç¨‹ã€‚å¦å¤–ä¸¤ä¸ªå¤§ä½¬å»ºæ¨¡åˆ†æç­‰ç­‰ï¼ˆè¿™é‡Œçš„ç­‰ç­‰çœç•¥äº†è®¸å¤šâ€¦â€¦ wtcl ä»£ç éƒ½æ˜¯é˜Ÿå‹å¸®æˆ‘æ‰¾çš„ã€‚å½“æ—¶å…¶å®æŒºè‡ªè´£çš„ï¼Œåˆ°åä¸¤å¤©æˆ‘æ‰å¼€å§‹å‘æŒ¥ä½œç”¨ã€‚æœ€ç»ˆè¿˜æ˜¯ä¸¤ä½å¤§ä½¬å¸¦ç€æˆ‘ä¸€ä¸ªèœé¸¡å‹‰å¼ºæ‹¿äº†ä¸ªå¥–ã€‚æ±‚ä¸‹å¹´åˆ«å†æ‹‰æˆ‘äº†ã€‚ åˆ°äº†ä¸‰æœˆåº•å°±å¼€å§‹ä¸Šè¯¾äº†ï¼Œé€šå¸¸ç¬¬ä¸€ä¸ªæ˜ŸæœŸéƒ½æ˜¯ä»‹ç»è¯¾ç¨‹ï¼Œå¿…é¡»è¦å¬å•Šï¼Œç§ç§åŸå› ã€‚ä¸€å¼€å§‹çš„é‚£å‡ ä¸ªæ˜ŸæœŸè¿˜æ˜¯å¾ˆè®¤çœŸçš„å¬è¯¾çš„ï¼Œåé¢å°±ä¸å¿ç›´è§†äº†ã€‚school ç‰¹è‰²åŸå› ï¼Œæ°´è¯¾å¾ˆå¤šã€‚è¿™æ—¶å€™ç½‘è¯¾çš„ä¼˜åŠ¿å°±å‡¸æ˜¾å‡ºæ¥äº†ã€‚è¯è™½è¿™ä¹ˆè¯´ï¼Œä½†æ˜¯è‹±è¯­è¿˜æ˜¯å¾—å¥½å¥½å­¦ã€‚ å››æœˆä»½å¼€å§‹å‡†å¤‡å­¦æ ¡çš„æ–°ç”Ÿèµ›ã€‚Crypto ä¸ä¼šå‡ºé¢˜ã€‚äºæ˜¯ç›´æ¥ç”¨äº†ä¸Šä¸€å¹´æ ¡èµ›çš„æ¨¡æ¿ï¼Œä¸€æ³¢ä¸‰æŠ˜ï¼Œæœ€åå¼ºè¡Œå‡‘å‡ºä¸‰é“é¢˜ï¼Œéš¾åº¦è¿˜ä¸å°ï¼Œç›´æ¥ä¸¢åˆ°å¹³å°ï¼Œæ²¡äººåšå‡ºæ¥ 555 å¤§æ¦‚å››æœˆä¸­æ—¬ï¼Œå®¶é‡Œäººå‡ºäº‹æƒ…äº†ï¼Œå¿ƒæ€æœ‰ç‚¹å´©ï¼Œä¹‹åç®—æ˜¯å‹‰å‹‰å¼ºå¼ºåœ°åœ¨å­¦ä¹ å§ã€‚ åˆ°äº†äº”æœˆä»½ï¼Œæ•´ä¸ªäººå‹¤å¿«äº†ï¼Œå­¦å¾—æŒºå¿«ã€‚æŠŠ Crypto çš„åŸºç¡€è¿‡äº†ä¸€éï¼Œæ‰“ä¸‹äº†å‡ åœºæ¯”èµ›ï¼Œçœ‹äº†ä¸å°‘paperï¼Œæ”¶è·è¿˜æ˜¯æŒºå¤§çš„ï¼Œå¯æƒœæ²¡æœ‰è¿›åˆ°çº¿ä¸‹ã€‚ä¸€ä¸ªé˜Ÿä¼ï¼Œä¸‰ç¼ºä¸€ï¼ŒåŠ ä¸Šè¿›çº¿ä¸‹çš„ç§ç§å›°éš¾ï¼Œç¦»ç›®æ ‡è¿˜æ˜¯å¾ˆè¿œå•Šã€‚ å…­æœˆä»½ä¸»è¦åœ¨å‡†å¤‡å„ç§‘çš„è€ƒè¯•ï¼Œå…¨åŠ›å¤ä¹ ï¼Œæ¯•ç«Ÿè¿˜æ˜¯æƒ³æ··ä¸ªå¥–å­¦é‡‘ã€‚ç°åœ¨æƒ³æƒ³ï¼Œä¸çŸ¥ä¸è§‰ï¼Œå·²ç»åœ¨å®¶åŠå¹´ã€‚ã€‚ã€‚å¸Œæœ›å¿«å¿«å¼€å­¦ã€‚ æ„Ÿæƒ³å¤§å­¦å·²ç»è¿‡å»ä¸€åŠï¼Œåº†å¹¸è‡ªå·±è¿™ä¸€å¹´æ²¡æœ‰æµªè´¹ï¼Œä½†ä¹Ÿå¾ˆå¯æƒœï¼Œæ²¡æœ‰è¾¾åˆ°è‡ªå·±é¢„æœŸçš„ç›®æ ‡ã€‚æ€ä¹ˆè¯´å‘¢ï¼Œè‡ªå·±å½“åˆçš„ç›®æ ‡å…¶å®å·²ç»æ”¹å˜äº†å§ï¼Œç°å®ä¸­çš„å˜åŒ–çš„å¤ªå¿«ï¼Œè€Œä¸”è‡ªå·±å½“åˆçš„å†³å¿ƒä¼¼ä¹ä¹Ÿæ²¡æœ‰é‚£ä¹ˆåšå®šã€‚èµ°ä¸€æ­¥çœ‹ä¸€æ­¥å§ï¼Œæ¯•ç«Ÿä¸æƒ³æµªè´¹è¿™å‡ å¹´å®è´µçš„æ—¶é—´ã€‚ å±•æœ›ç”¨æŸäººçš„è¯ï¼šâ€å°‘è¯´è¯ï¼Œå¤šåšäº‹ã€‚å…‰è¯´ä¸ç»ƒå‡æŠŠå¼ï¼Œè¦å‹¤å¥‹ï¼Œå‹‡äºå®è·µã€‚â€","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"das-CTF&GK-CTF-2020-Writeup","slug":"das-CTF-GK-CTF-2020-Writeup","date":"2020-05-24T01:30:24.000Z","updated":"2020-08-03T03:26:26.371Z","comments":true,"path":"2020/05/24/das-CTF-GK-CTF-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/","excerpt":"","text":"Only writeup in Crypto. GKCTFå°å­¦ç”Ÿçš„å¯†ç å­¦(Solved)Pretty easy affince cipher. Both keys are given. babycrypto(Solved)Partial high bits of p is known. 123456789101112131415161718192021222324# Use sage to run the script# Reference: https://www.jianshu.com/p/1a0e876d5929from sage.all import *from Crypto.Util.number import long_to_bytes# All variables are in hexn = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005# Padding zeros to p --&gt; p4p4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000cipher = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361e2 = 65537kbits = 128 # kbits represent the loss bitsPR.&lt;x&gt; = PolynomialRing(Zmod(n)) # Create a polynomial ringf = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4 + int(roots[0]) assert n % p == 0 q = n / int(p) phin = (p-1)*(q-1) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) print long_to_bytes(flag) æ±‰å­—çš„å¯†ç (Solved)å½“é“ºå¯†ç +Substitution Cipher 123456dic = [66, 74, 62, 67, 118, 83, 72, 77, 86, 55, 71, 57, 82, 57, 64, 63, 51, 107]delta = 1for i in dic: print(chr(i+delta), end=\"\") delta += 1# FLAG&#123;YOU_ARE_GOOD&#125; Backdoor(Unsolved)Remain confused DASCTFbbcrypto(Solved)quiz.py 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=\"\" for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return cif __name__ == \"__main__\": m = 'flag&#123;********************************&#125;' a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(\"æ˜æ–‡å†…å®¹ä¸ºï¼š\") print(m) print(\"åŠ å¯†åçš„å¯†æ–‡ä¸ºï¼š\") c=encrypt(m, a, si) print(c) #åŠ å¯†åçš„å¯†æ–‡ä¸ºï¼š #177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d The length of salt is 3 and we have already known that the plain starts with â€œflag{â€œ. Solve linear congruent equations to get the salt. 123456789101112131415161718192021222324c = \"177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d\"li_c = [int(c[i:i+2], 16) for i in range(0, len(c), 2)]# print(li_c)m = \"flag&#123;\"d_c = li_c[3] - li_c[0]# print(d_c)d_m = ord(m[3]) - ord(m[0])# print(d_m) # a = 57 mod 128a = 57# print((li_c[0] - a * ord(m[0])) % 128)# print(chr(97)) y1 = 'a'# print((li_c[1] - a * ord(m[1])) % 128)# print(chr(104)) y2 = 'h'# print((li_c[2] - a * ord(m[2])) % 128)# print(chr(104)) # y3 = 'h'# print((li_c[3] - a * ord(m[3])) % 128)m = \"\"from gmpy2 import invertimport itertoolsinv_a = invert(a, 128)key = itertools.cycle(\"ahh\")for i in li_c: m += chr(((i - ord(next(key))) * inv_a) % 128)print(m) encrypt_img(Solved)quiz.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from numpy import arrayfrom PIL import Imagefrom secret import KeyPlaintext1 = \"RC4IsInteresting\"Plaintext2 = \"ThisIsAEasyGame\"cnt = 0class RC4(): def __init__(self, Key): self.S = [i for i in range(256)] # 0 - 255 self.K = [ord(Key[i % len(Key)])*2 for i in range(256)] # KEY * 2(0-255) self.I, self.J = 0, 0 self.KSA() def KSA(self): for i in range(256): j = (i+self.K[i]+self.S[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def next(self): self.I = (self.I+1) % 256 self.J = (self.J+self.S[self.I]) % 256 self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J] tmp = (self.S[self.J] + self.S[self.I]) % 256 return self.S[tmp]class Encrypt(): def __init__(self, plain): global cnt cnt += 1 self.rc4 = RC4(Key) self.testRC4(plain) flag_file = Image.open(r\"flag.png\") img = array(flag_file) self.enc(img) def testRC4(self, plain): ciphertext = 0 for i in plain: ciphertext = (ciphertext &lt;&lt; 8)+ord(i) ^ self.rc4.next() print(\"ciphertext&#123;&#125; = &#123;&#125;\".format(cnt, ciphertext)) def enc(self, img): a, b, _ = img.shape for x in range(0, a): for y in range(0, b): pixel = img[x, y] for i in range(0, 3): pixel[i] = pixel[i] ^ self.rc4.next() img[x][y] = pixel enc = Image.fromarray(img) enc.save(\"enc&#123;&#125;.png\".format(cnt))Encrypt(Plaintext1)Encrypt(Plaintext2)# ciphertext1 = 12078640933356268898100798377710191641# ciphertext2 = 79124196547094980420644350061749775 enc1.png enc2.png Stream Cipher Insertion Attack Such a pity that I didnâ€™t figure it out at that time. From two groups of plaintexts and ciphertexts we can recover keystream at the start. However, the second keystream has one bit less than the first one, from which we easily can retrieve m0, then k1, after that m1 and so on. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'''plaintext1 = \"RC4IsInteresting\"plaintext2 = \"ThisIsAEasyGame\"ciphertext1 = 12078640933356268898100798377710191641ciphertext2 = 79124196547094980420644350061749775key1 = []for i in range(len(plaintext1) - 1, -1, -1): key1 = [ord(plaintext1[i]) ^ (ciphertext1 &amp; 0xff)] + key1 ciphertext1 &gt;&gt;= 8print(key1)key2 = []for i in range(len(plaintext2) - 1, -1, -1): key2 = [ord(plaintext2[i]) ^ (ciphertext2 &amp; 0xff)] + key2 ciphertext2 &gt;&gt;= 8print(key2)# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106, 126]# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106]'''# Suppose the bit length of the flag.png is n bits, key1 and key2 can be written like:# key1: k1, k2, ..., kn# key2: k0, k1, ..., k(n-1)# Above we have already known k0 is 126, which is the last key of plaintext2,# we can retrieve m0, then k1, after that m1 and so onfrom PIL import Imagefrom numpy import arrayimg1 = array(Image.open(r\"./enc1.png\"))img2 = array(Image.open(r\"./enc2.png\"))def recovery_img(im1, im2, k): x1, y1, z1 = im1.shape for i in range(x1): for j in range(y1): pixel1 = im1[i, j] pixel2 = im2[i, j] for _ in range(3): pixel2[_] = pixel2[_] ^ k k = pixel1[_] ^ pixel2[_] im2 = Image.fromarray(im2) im2.save(\"dec.png\")recovery_img(img1, img2, 126) babyLCG(Solved)quiz.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Util.number import*from secret import flagclass LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = getRandomNBitInteger(128) self.m = getPrime(256) self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)DH = DH()flag = bytes_to_long(flag)print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"Cipher = &#123;&#125;\".format(flag ^ DH.key))'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' LCG+Diffie Hellman Exchange Key The seed is too small ,as a result, we use brute-force attack to get the seed and recover the key. When we XOR the cipher with the key, the plain is figured out. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475'''a = 3844066521b = 3316005024m = 2249804527'''class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 714405490 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() # a private key self.B, self.b = self.gen_AB() # b private key self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)'''def next(x): return (x * a + b) % mdef brute_force(): for i in range(1&lt;&lt;32): if i % 10000000 == 0: print(\"count:\", i) res = next(i) if (res &gt;&gt; 16) == 16269 and (next(res) &gt;&gt; 16) == 4249: print(i) break'''DH = DH()cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"flag = &#123;&#125;\".format(cipher ^ DH.key))# flag = 13040004482819966666226297285938773653367957972934959074317939536564198335643452104954492541# flag&#123;4dfe14e0c6c21ffcf5a3b4f0ed1911f6&#125;'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' Knapsack(Solved)quiz.py 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from functools import reducedef genKey(length): A, B = getPrime(64), getPrime(1025) Rn = getPrime(1024) key1 = [Rn//2**i for i in range(1, length+1)] key2 = [i*A % B for i in key1] return key1,key2def encrypt(text,key): Sum=0 for i in range(len(text)): Sum+=int(text[i])*key[i] return Sumdef save(Ciper,Key): f1=open(\"pub.txt\",\"w\") for i in range(len(Key)): f1.write(str(Key[i])+'\\n') f2=open(\"cip.txt\",\"w\") f2.write(hex(Ciper))FLAG = bin(bytes_to_long(flag.encode()))[2:]Key1,Key2 = genKey(len(FLAG))Ciper = encrypt(FLAG,Key1)save(Ciper,Key2) cip.txt 1a long hex string pub.txt 11015 public keys The last few key in pub.txt is too small, which actually is the original private key. We can use them to recover the original private key. backpacker(Unsolved)Remain confused What I have doneFinish learning symmetric cipher and the first chapter of Network Introduction. Things to Improve Donâ€™t be panic when encountering a challenge that is never met Be more concentrated on study LLL algorithm","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"Npu-CTF-2020-Review","slug":"Npu-CTF-2020-Review","date":"2020-05-12T13:20:15.000Z","updated":"2020-08-03T03:26:42.361Z","comments":true,"path":"2020/05/12/Npu-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. What does the tag mean Status Description Solved Solved in the competition Unlved Unsolved in the competition Mersenne Twister(unsolved)This challenge is related to Mersenne Twister Encryption. However, there are differences between them exactly. Here is the file: Mersenne Twiser.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import *from itertools import *from binascii import hexlify , unhexlifyfrom flag import flag ,seedassert len(flag) == 26assert flag[:7] == 'npuctf&#123;'assert flag[-1] == '&#125;'XOR = lambda s1 ,s2 : bytes([x1 ^ x2 for x1 ,x2 in zip(s1 , s2)])class mt73991: def __init__(self , seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i+1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i+1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i+1)%233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4 , 'big') self.flag += 1 return bits def Next(self , tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef encrypt(key , plain): tmp = md5(plain).digest() return hexlify(XOR(tmp , key))if __name__ == \"__main__\": flag = flag.encode() random = mt73991(seed) f = open('./cipher.txt' , 'wb') for i in flag: key = b''.join([random.getramdanbits() for _ in range(4)]) cipher = encrypt(key , chr(i).encode()) f.write(cipher) cipher.txt 1an 832 bytes long hex string ExplanationMersenne Twister is a kind of PRNG, whose derives from the fact that its period length is chosen to be a Mersenne Prime. This Mersenne Twister challenge has a 32-bit length. ConditionOnly a few conditions are given. the encryption result in cipher.txt the period length partial flag the length of the flag encryption function DetailsGiven that the first part of the flag is â€œnpuctf{â€œ, which is a 7 bytes long string, we can retrieve the first 28 generated states with the according cipher in cipher.txt. Since we also know the last byte of the string(â€œ}â€) and the length of the string, we can easily retrieve the 100th~103th generated states. Then we look into the generate function. 12345678def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp Suppose that i equals to 103, we try to write down that situation. 12345678def generate(self): for i in range(233): y = (self.state[103] &amp; 0x80000000) | (self.state[(104) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 # 1 temp ^= self.state[(0) % 233] # 2 if y &amp; 1: temp ^= 0x9908f23f self.state[103] = temp # 3 In this situation, it is possible for us to retrieve the104th initial state, which means that we can get the seed through inversing. There are two possibilities in this situation(state[104] is odd or even). We try to draw a table. possibilites hb(1) hb(2) hb(3) even 0 0 0 odd 0 0 1 hb in the table above means the highest bit of the value in the line #n. Based on the fact that the true hb(3) is 0, which is the highest bit of the 103th generated state, it is impossible for the 104th initial state to be odd. Therefore, we can retrieve y and the low 31 bits of the 104 initial state. Since the highest bit is unknown, we can guess it (zero or one). Therefore, there are two possible seeds, which can be judged in the end. Because the seed is retrieved, we can decrypt the cipher easily.(Something just like Symmetric Cipher) By the way, the md5 function in encrypt function seems to be useless because it only encrypts one character, for which we can correspondingly generate an md5 dictionary of all printable characters and print the corresponding characters. RealizationHere is my realization. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import hashlibimport binasciifrom Cryptodome.Util.number import *import stringXOR = lambda s1, s2: bytes([x1 ^ x2 for x1, x2 in zip(s1, s2)])initial_state = [0] * 233initial_state2 = [0] * 233cipher = ['cef4876036ee8b55aa59bca043725bf3', '50a5e491debdef7ef7d63e9609a288ca', '1e2c82a7fe566bd8709e73c8d495ea50', '4a486ed11189faf8e6fb35617e47d2d1', 'ad5e4783e96afeaae9f7104ec477fb39', 'fe4ec619bf58289709e15c4449f03fc5', '1cba918cd0ebfdc12376b41e78154064', '82733b3b200826b6c78d86563edaea94', 'dccf459a4291517a4b8367d7b4a53aee', 'cd7e0accf661bfc726f5ba62e1c0e041', '00108ad32e7d5711f780185cba5cf31d', '328bee84066be4ab9582cf9d4bfe3c6f', '96a7732e1c37d800c90fd46277147f0a', '26c149dcd5eeb0f2df0c075627bc220b', 'e5eefdd67186056ac28c21e155a7f247', '664aaecdb498134de274df10114d1f06', 'f84dd21820f150d69c9439d909dec0f5', 'ccfeab61b62db2ea91d31bc8163ff16c', '7f458006bd5ac4a5f5bfae2770b23ccf', 'b7195b76aa0a9aa146831667a7b9fe08', 'c19e691afadccb3ca5169ef3fabaa3da', 'd47d536e89ed4cee6f788bc969c3ad31', '37850ebfc46a73af2b0c036c3da4b4a1', '6506f499445c604dd73eeb846a52f881', '515a3ad0ab448b4f9ed3e0ab1fffac60', 'b223dde6450ba6198e90e14de107aaf2']starts = \"npuctf&#123;\"ends = \"&#125;\"class mt73991: def __init__(self, seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i + 1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i + 1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4, 'big') self.flag += 1 return bits def Next(self, tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef USMR(x, shift, mask): res = x for i in range(32): res = x ^ (res &gt;&gt; shift &amp; mask) return resdef USML(x, shift, mask): res = x for i in range(32): res = x ^ (res &lt;&lt; shift &amp; mask) return resdef inv_Next(x): x = USMR(x, 18, 0x34adf670) x = USML(x, 15, 0xefc65400) x = USML(x, 7, 0x9ddf4680) x = USR(x, 11, 0xffffffff) return xdef inv_srand(value, index): for i in range(index-1, -1, -1): value += i value *= inverse(1812433253, 0x100000000) value = USR(value, 27, 0xffffffff) value &amp;= 0xffffffff return valuedef USR(value, shift, mask): i = 0 res = 0 while i * shift &lt; 32: partMask = ((0xffffffff &lt;&lt; (32 - shift)) &amp; 0xffffffff) &gt;&gt; (shift * i) part = value &amp; partMask value ^= (part &gt;&gt; shift) &amp; mask res |= part i += 1 return res# hash all known charactershash_starts = []for i in starts: hash_starts.append(hashlib.md5(i.encode()).digest())# print(hash_starts)hash_ends = hashlib.md5(ends.encode()).digest()state = [0] * 233# first 7 charactersfor i in range(len(starts)): key = XOR(hash_starts[i], binascii.unhexlify(cipher[i])) for j in range(4): tmp = inv_Next(bytes_to_long(key[4*j:4*j+4])) state[4*i+j] = tmp# print(state[:28]) # check passdef decrypt(key, cipher): cipher = binascii.unhexlify(cipher) temp = XOR(key, cipher) for i in md5_dic: if temp == i: print(string.printable[md5_dic.index(i)], end=\"\")# the last characterkey = XOR(hash_ends, binascii.unhexlify(cipher[-1]))for i in range(4): tmp = inv_Next(bytes_to_long(key[4*i:4*i+4])) state[100+i] = tmp# print(state[100:104]) # check pass# Since it can be simplified, there are only two situations of old_state[104]# old_state[104] is eveny = (state[0] ^ state[103]) &lt;&lt; 1 # recover y# print(y) # check passposs_1 = y &amp; 0x7fffffffposs_2 = (y &amp; 0x7fffffff) | 0x80000000# print(poss_1)# print(poss_2)# check pass# get the seed of each situationposs_1 = inv_srand(poss_1, 104)poss_2 = inv_srand(poss_2, 104)print(poss_1)print(poss_2)# generate md5 dictionarymd5_dic = []for i in string.printable: md5_dic.append(hashlib.md5(i.encode()).digest())random_1 = mt73991(poss_1)random_2 = mt73991(poss_2)# recover the flag from random_1flag = \"\"for i in range(26): key = b''.join([random_1.getramdanbits() for _ in range(4)]) decrypt(key, cipher[i])# Since random_1 is the correct one, random_2 can be ignored. è¿™é¢˜ä¸€å¼€å§‹å‡ºé¢˜äººæé”™äº†ã€‚ã€‚ã€‚è‡ªé—­äº†ä¸€ä¸‹åˆ è®¤æ¸…å½¢åŠ¿ï¼Œå»ºç«‹ä¿¡å¿ƒAfter observing the task.py, we can find that this is a classical discrete logarithm problem. Letâ€™s see the file. task.py 12345678910111213141516171819202122from Crypto.Util.number import *from gmpy2 import *from secret import flagp = getPrime(25)e = # Hiddenq = getPrime(25)n = p * qm = bytes_to_long(flag.strip(b\"npuctf&#123;\").strip(b\"&#125;\"))c = pow(m, e, n)print(c)print(pow(2, e, n))print(pow(4, e, n))print(pow(8, e, n))'''169169912654178128509160179202518818742414340358553002064450''' ExplanationThere are many methods to solve discrete logarithm problems, BSGS(Baby Steps Giant Steps), SPH method and so on. ConditionThere are four equations in task.py and the remains of four equations are given. The flag is in the first equations. Here is what we have known. The length of q and p remains of four equations My idea is that n is possible to be solved and after that we can use the second equation to calculate e, using discrete logarithm calculation methods. DetailsWe can notice that: n\\;|\\;gcd(c1^{3}\\;-\\;c3,\\;c1^{2}\\;-\\;c2)From this character and another character that n is the product of two big prime number, we can get n. After that, it is really convenient that we can use discrete_log() function in Sage to calculate e. Luckily, e is coprime with n, so the inverse exists. The decryption is the similar with rsa. RealizationMy realization. 1234567891011121314151617181920212223242526272829303132#! /usr/bin/env sagefrom Crypto.Util.number import long_to_bytesimport gmpy2def gcd(a, b):tureif b == 0:tureturereturn a, 0turea, b = gcd(b, a % b)turereturn a, bc = 169169912654178c_1 = 128509160179202c_2 = 518818742414340c_3 = 358553002064450dc_1 = c_1 ** 2 - c_2dc_2 = c_1 ** 3 - c_3n = gcd(dc_1, dc_2)[0] / 2# print(n) # check passn.factor()p = 18195301q = 28977097phi = (p - 1) * (q - 1)e = discrete_log(Mod(c_1, n), Mod(2, n))# print(e) # check pass# print(gcd(e, phi)[0]) # check passd = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) Referenceshttps://en.wikipedia.org/wiki/Mersenne_Twister","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-05-03","slug":"2020-05-03","date":"2020-05-03T14:44:24.000Z","updated":"2020-05-03T14:50:02.431Z","comments":true,"path":"2020/05/03/2020-05-03/","link":"","permalink":"https://buki-freak.github.io/2020/05/03/2020-05-03/","excerpt":"","text":"What I Have DoneSadly, the quiz yesterday is still unsolved. It seems that z3-solver doesnâ€™t work. As a result, I study Correlation Attack which is a kind of brute-force attack method. The method seems to work now and I am trying to understanding the codes written by others. Daily IELTS exercises have been done. What a day! Things to Learn and Improve Stream Cipher - Correlation Attack Method","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"2020-05-02","slug":"2020-05-02","date":"2020-05-02T13:12:07.000Z","updated":"2020-05-02T13:22:44.870Z","comments":true,"path":"2020/05/02/2020-05-02/","link":"","permalink":"https://buki-freak.github.io/2020/05/02/2020-05-02/","excerpt":"","text":"What I Have DoneA competition is held in these days, exciting and also exhausting! I am confident on a quiz about LFSR, which I have lately learned. However, things always does go in the right way, isnâ€™t it? After being trapped for over five hours, I went to sleepâ€¦ While I did several IELTS reading exercises, oh of course, I have finished The End of the fxxking world Season One just for fun ha ha ha! Things to Learn and Improve z3-solver English reading speed Be easygoing","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"Greeting","slug":"Greeting","date":"2020-05-01T12:33:15.000Z","updated":"2020-05-01T12:57:56.341Z","comments":true,"path":"2020/05/01/Greeting/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/Greeting/","excerpt":"","text":"Today, I have deleted all blogs deployed before. My greeting is below. The Pastâ€‹ For a so-called loser, it is always mournful to talk about his or her past. Actually, I am one of them, after failing the college entrance examination. Whatâ€™s more, things go wrong in these university days. It seems that I have have been trapped for such a long time, or have had a nightmare. Families, friends, mates, the environment, â€¦, everything goes in a wrong way. However, Mama usually tells me to be positive, which merely works at some time I think. Well, as is told, if you donâ€™t like this world, you can just try to leave it and choose your life. It will be alright, since seldom people can live for 100 years. I mean I should do what I really want to do in limited time. Therefore, stop to complain about the past, leave that fxxking world and alter a world that you want. Present Daysâ€‹ Well, all roads lead to Rome. There are many ways to achieve your ambition and I choose that one that I have lately planned. Once the goal is settled, you only need to: Focus Focus Focus FutureFuture is unpredictable, but we should be hopeful. Look at the sky, and you will find how lovely it is to see the past of others. They are shining for you.","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-01T12:30:10.251Z","updated":"2019-08-27T01:03:22.557Z","comments":true,"path":"2020/05/01/hello-world/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"},{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"},{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"},{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"},{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]}