{"meta":{"title":"buk1","subtitle":"Every day is my last day.","description":"Programming","author":"buki","url":"https://buki-freak.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2020-08-03T03:02:58.465Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"repository/index.html","permalink":"https://buki-freak.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":false,"path":"tags/index.html","permalink":"https://buki-freak.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-03T02:29:11.317Z","updated":"2020-08-03T02:29:11.317Z","comments":true,"path":"links/index.html","permalink":"https://buki-freak.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"极客巅峰-2020-Review","slug":"极客巅峰-2020-Review","date":"2020-10-19T11:23:05.000Z","updated":"2020-11-19T08:43:03.957Z","comments":true,"path":"2020/10/19/极客巅峰-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/10/19/极客巅峰-2020-Review/","excerpt":"","text":"​ 菜狗比赛没做出几题，前一段时间心态崩了，复现一下吧。 ​ tryrsa​ 比赛的时候把精力都放在 trypoly 上面了，没看到这道题，tcl 。。。 ​ 先看一下题目，output 给出数据。 ​ 12345678910111213141516171819from secret import e1,e2,flagfrom Crypto.Util.number import *msg = bytes_to_long(\"=========Hint:e1=\"+str(e1)+\"=============\") # 2020321p = getPrime(512)q = getPrime(512)N = p*qprint Nprint pow(msg,3,N) msg = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)N = p*qc = pow(msg, e2, N)print N,e2 print c print(pow(p+q,e1,N ))print(pow(p+e1, q, N)) ​ 数据挺多的。首先看到一个低加密指数，尝试一下开三次方，成功得到 $e1$ 。 ​ 12345In [6]: c = 28249132350044579687091110964285446575404805400757326954185222098803605008954490760462246663674360047951197296557689347856716297531621331430289344669498939239588624311221464757652619402073234993515450143594805022438694559765344247838048186137683783869848355994953125 In [7]: gmpy2.iroot(c,3) Out[7]: (mpz(30455684940295012564308820485670106905218940938159317278342517311135788043906905072811325), True) # e1 ​ 下面是一个常规的 rsa 加密，给出了几个关系： ​ 1.\\;c\\;\\equiv\\;msg^{e2}\\mod N\\\\ \\;\\;\\;\\;\\;2.\\;c_1\\;\\equiv(p+q)^{e1}\\mod N\\\\ \\;\\;\\;\\;\\;\\;3.\\;c_2\\;\\equiv(p+e_1)^q\\mod N​ ​ 对于第二条式子，进行以下化简： ​ c_1\\;=\\;(p+q)^{e_1}\\;+\\;kqp\\\\ c_1\\mod q\\;=\\;(p\\mod q\\;+\\;q\\mod q)^{e1}\\mod q\\;+\\;0\\\\ c_1\\equiv p^{e1}\\mod q\\\\ c_1\\;=\\;p^{e_1}\\;+\\;kq​ 对于第三条式子，也进行化简，中间使用费马定理： ​ c_2\\;=\\;(p+e_1)^q\\;+\\;kpq\\\\ c_2\\mod q\\;=\\;(p\\mod q\\;+\\;e_1\\mod q)^q\\mod q\\;+\\;0\\\\ c_2\\equiv p\\;+\\;e_1\\mod q\\\\ c_2\\;=\\;p\\;+\\;e_1\\;+\\;kq\\\\ c_2\\;-\\;e_1\\;=\\;p\\;+\\;kq​ 注意第三条式子左边的值我们是可以进行计算的。加上 $e1$ 次方，再用二项式定理展开可得： ​ (c_2-e_1)^{e1}\\;=\\;(p+kq)^{e1}\\;=\\;C_n^{0}p^{e1}+C_n^{1}p^{e1-1}(kq)+\\;...\\;+C_n^{n-1}p(kq)^{n-1}+C_{n}^{n}(kq)^n​ 再减去第一条式子可得： ​ （c_2-e_1）^{e1}-c_1\\;=\\;tkq​ 上面这条式子右边的值为 $q$ 的整数倍，而左边的值我们可以进行计算，求其与 $N$ 的最大公因数即可。 ​ exp 如下： ​ 123456789101112131415In [29]: q = gmpy2.gcd(pow(c2 - e1,e1,N) - c1,N) In [30]: q Out[30]: mpz(162984526621683870625098586014910615083563535116972222345188747969350923464088799732530801488388575838451737347617234153531460507216470173767572431203228056853761835680227568853138262896922662664650377958457439852663861645573573134863458099139681417307977919507889782957584330019942586292868271385366037674313)In [46]: p = N // q In [47]: p Out[47]: mpz(165756727599372791875820541625601955300453776993770577352314168977734910665053298526454521639089078020881208027049933409502069159705827587730047406034448233170464600044968540270031406627778916422623991350852342453286144055883559111480220646693965481942701883316426823927969224691707129909621502373328134683537)In [48]: phi = (p - 1) * (q - 1) In [49]: d = gmpy2.invert(e2,phi) In [50]: m = pow(c,d,N) In [52]: long_to_bytes(m) Out[52]: b'flag&#123;5b55c69f-398d-47bc-ad37-4f268e8ae4b2&#125;'# flag&#123;5b55c69f-398d-47bc-ad37-4f268e8ae4b2&#125; ​ ​ ​ trypoly​ 这题是原题 。 ​ 花了 10 分钟。当时急急忙忙做出来了，现在仔细看一下原理。 ​ 看一下代码： ​ 123456789101112131415from secret import *from Crypto.Util.number import *flag = bytes_to_long(flag) ranges = int(log(flag,3))pri = next_prime(ZZ.random_element(3^16, 3^17))it = 5N = pri^120P.&lt;x&gt; = PolynomialRing(Zmod(N), implementation='NTL')poly = 0for c in range(it): poly += ZZ.random_element(3^ranges, 3^(ranges+1))*x^cpoly = poly - poly(flag)print(pri)print(poly) ​ 题目定义了一个模 $pri^{120}$ 下的多项式环，接着生成一个 $degree$ 为 4 的多项式 $poly$，然后用这个多项式减去 $flag$ 代入的 值 $poly(flag)$ 得到一个新的多项式 $poly’$, 题目给出了 $pri$ 和 $poly’$ 。 ​ 分析一下可以知道，$flag$ 是 $poly’\\;\\equiv\\;0\\mod p^{120}$ 的一个解。 ​ 原题的 write up 中提供了一个思路，先算出 $\\mod p$ 下的所有解，然后用 henstel_lifting 的方法求出 模高次幂 $p$ 下的解，其中可能为 $flag$ 。 ​ If a polynomial equation has a simple root modulo a prime number p, then this root corresponds to a unique root of the same equation modulo any higher power of p, which can be found by iteratively “lifting” the solution modulo successive powers of p. ​ 先算出 $\\mod p$ 下的可能解： ​ 12345p = 91178819P.&lt;x&gt; = PolynomialRing(Zmod(p), implementation='NTL')f = 57453455752934422314569380490870437392139092788674299919611253252932221869550680569946725024530545003*x^4 + 48037906924411573201214693262554265057001265856059030798403001287597455830201673623580499809814145397*x^3 + 115978529756755271495684497597111489575180207439819530844214796357232008531997740692954971387805647169*x^2 + 90144181335780729761572136076745420392729113384422074643542473780101371704844686670328386988693003565*x + 15391307705240277278890263165432140210177612531692370138228866751525717915844630600454114316817767347237410103825891623720982676085014910889900050564292685762014395155362574870811426331093375257234685605632632665945906781957636758863633857453440902818467506862994716985071078742637470209975218157566199744899513967029548028126417040526508345337196021889482286023256338442270711332457021150881328372306307158084639537132701296810708211240517552171001258318265080522140684915746401253066679720255872700102642721647928067158080049850626073426063356187938363644873928284413044082195265066444624399404805990964473348796290240520637015040450522056216046061514855949283976028501383885079871184350334880950826925674190842626492485432769357092486284047237776336391752959868191708104998859612329034138201867198495897106145496766577408003296902815140152148936337282162436442452632231320117066224252199246120829466402954585288911632249785731492040264164216078655949851print (f.monic().roots())# [(71914448, 1), (30387361, 1), (26714989, 1), (823233, 1)] ​ ​ 最后 exp 如下： ​ 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import * def lift(f, p, k, previous): result = [] df = diff(f) for lower_solution in previous: dfr = Integer(df(lower_solution)) fr = Integer(f(lower_solution)) if dfr % p != 0: t = (-(xgcd(dfr, p)[1]) * int(fr / p ** (k - 1))) % p result.append(lower_solution + t * p ** (k - 1)) if dfr % p == 0: if fr % p ** k == 0: for t in range(0, p): result.append(lower_solution + t * p ** (k - 1)) return result def hensel_lifting(f, p, k, base_solution): solution = base_solution for i in range(2, k + 1): solution = lift(f, p, i, solution) return solution if __name__==\"__main__\": #base = [(71914448, 1), (30387361, 1), (26714989, 1), (823233, 1)] base = [71914448] p = 91178819 k = 120 N = p^k P.&lt;x&gt; = PolynomialRing(Zmod(N), implementation='NTL') f = 57453455752934422314569380490870437392139092788674299919611253252932221869550680569946725024530545003*x^4 + 48037906924411573201214693262554265057001265856059030798403001287597455830201673623580499809814145397*x^3 + 115978529756755271495684497597111489575180207439819530844214796357232008531997740692954971387805647169*x^2 + 90144181335780729761572136076745420392729113384422074643542473780101371704844686670328386988693003565*x + 15391307705240277278890263165432140210177612531692370138228866751525717915844630600454114316817767347237410103825891623720982676085014910889900050564292685762014395155362574870811426331093375257234685605632632665945906781957636758863633857453440902818467506862994716985071078742637470209975218157566199744899513967029548028126417040526508345337196021889482286023256338442270711332457021150881328372306307158084639537132701296810708211240517552171001258318265080522140684915746401253066679720255872700102642721647928067158080049850626073426063356187938363644873928284413044082195265066444624399404805990964473348796290240520637015040450522056216046061514855949283976028501383885079871184350334880950826925674190842626492485432769357092486284047237776336391752959868191708104998859612329034138201867198495897106145496766577408003296902815140152148936337282162436442452632231320117066224252199246120829466402954585288911632249785731492040264164216078655949851 solutions = hensel_lifting(f,p,k,base) for solution in solutions: print (long_to_bytes(solution)) # b'flag&#123;b3cfcea8-6cca-11ea-bc55-0242ac130003&#125;' ​ ​ tryecc​ ​ 题目如下： ​ 1234567891011121314151617181920212223242526from secret import *from Crypto.Util.number import *print \"N is : \",Nprint \"C is : \",CF = IntegerModRing(N)E1 = EllipticCurve(F, [A, C])E2 = EllipticCurve(F, [A, B])P1 = (40868726519566019162794925971370501749760105301423309229554,54687980868371628310908123178978977864897123871328723)P2 = (235149117685317066108245267690004572936544028030457002179126,1289371238921298371232163781261298731812137628190)P1 = E1(P1)P2 = E2(P2)msg = flagmsg1 = msg[:19]msg2 = msg[19:]m1 = bytes_to_long(msg1)m2 = bytes_to_long(msg2)assert m1 &lt; nassert m2 &lt; nP3 = m1 * P2P4 = m2 * P2print(P1)print(P2)print(P3)print(P4) ​ ​ $N$ 可以被分解成： ​ 1N = 773793889124783574343562335367 * 773793889124783574343613279393 ​ 所以很明显 $N$ 为合数。 题目给出了两个 ECC，第一个 ECC 已知参数 $C$，可以求出两个椭圆曲线的参数。 ​ 然后用 Elliptic Curve Discrete Log in a Composite Ring 的方法求 CRT 可以分别求得两个部分的 $flag$ 。 ​ SageMath 的 Discrete logs 也可以求 ECC 的 DLP ！ ​ ​ 最后 exp: ​ 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import long_to_bytesN = 598756982846857855564861803797067906933452532971372536192231p = 773793889124783574343562335367q = 773793889124783574343613279393C = 4480960863875584511148612202888184984874434295853921P1x = 40868726519566019162794925971370501749760105301423309229554P1y = 54687980868371628310908123178978977864897123871328723P2x = 235149117685317066108245267690004572936544028030457002179126P2y = 1289371238921298371232163781261298731812137628190P3x = 230807308713660443214609900462802224133677339138938919914236P3y = 15979270783196203822523802015845150885928738960540101206481P4x = 48539794908526618490272854315619275063139157075919926757183P4y = 253317587580758121061061480314672531383057603048054780326781F = IntegerModRing(N)A = ((P1y^2 - C - P1x^3) * inverse_mod(P1x,N)) % NB = (P2y ^ 2 - P2x ^ 3 - A * P2x) % NEq = EllipticCurve(GF(q), [A, B])Ep = EllipticCurve(GF(p), [A, B])P2q = Eq(P2x,P2y)P2p = Ep(P2x,P2y)P3q = Eq(P3x,P3y)P3p = Ep(P3x,P3y)P4q = Eq(P4x,P4y)P4p = Ep(P4x,P4y)oq = Eq.order()op = Ep.order()m1q = discrete_log(P3q,P2q,oq,operation='+')m1p = discrete_log(P3p,P2p,op,operation='+')m1 = CRT([m1p,m1q],[op,int(oq)//gcd(op,oq)]) # modulus are pairwise coprimem2q = discrete_log(P4q,P2q,oq,operation='+')m2p = discrete_log(P4p,P2p,op,operation='+')m2 = CRT([m2p,m2q],[op,int(oq)//gcd(op,oq)]) # modulus are pairwise coprimeprint(long_to_bytes(m1) + long_to_bytes(m2))# b'flag&#123;de7a89ab1d074ef3930fb3054c0e3ac8&#125;' ​ ​ 比赛时没有注意到 CRT 需要每个模数互质，没出来。。。 ​ ​ ​ ReferenceS​ https://blog.csdn.net/weixin_45369385/article/details/108876212 https://amritabi0s.wordpress.com/2019/03/18/confidence-teaser-ctf-crypto-writeups/ ​ ​ ​ 坚持！","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"西湖论剑-2020-Writeup","slug":"西湖论剑-2020-Writeup","date":"2020-10-12T03:15:11.000Z","updated":"2020-10-14T02:18:34.156Z","comments":true,"path":"2020/10/12/西湖论剑-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/10/12/西湖论剑-2020-Writeup/","excerpt":"","text":"​ 这次远程题居然翻车了 2333，菜狗差点做不出来。。。 ​ BrokenSystems​ 给了一个公钥，提取看一下： ​ 1234567891011121314151617181920212223242526272829303132333435363738394041(base) buk1@ubuntu:~/Desktop/t1$ openssl rsa -in ./public.key -pubin -text -modulusRSA Public-Key: (2048 bit)Modulus: 00:c2:07:45:22:3f:f5:b9:4b:2c:d8:41:21:66:f7: 28:8a:21:f2:18:7e:1a:42:14:53:91:8c:ab:03:c8: 02:53:45:12:33:eb:1b:dc:23:63:74:42:28:aa:86: 94:a8:c2:cb:c8:33:f8:0d:df:40:83:1a:68:90:1b: 23:0b:83:f3:f0:fe:d4:b7:2d:0b:94:2b:5e:95:de: da:c8:dc:c0:04:7a:2a:fb:90:c8:1e:d7:2d:3a:d4: 9b:72:fc:8b:d0:d3:16:7d:dd:aa:6a:b5:16:7c:05: 8d:f3:6a:f1:90:b2:16:08:5b:bd:9d:62:1f:9b:d2: 3a:09:3e:4e:3d:9c:c3:87:b6:27:4f:2c:33:9c:88: e1:b2:d9:08:ac:b3:3f:4e:20:e6:47:ab:ee:07:14: a3:cc:e4:64:6e:89:62:94:b7:81:03:dc:c9:a4:db: 7e:d6:81:16:4c:6e:6c:c7:fd:33:47:6e:17:4a:6c: 70:70:37:b2:50:49:13:65:f9:f0:eb:76:ae:ab:a0: 7d:b2:f6:62:d8:80:48:af:98:c8:8c:76:c6:71:0d: b9:65:8d:49:fc:a0:ca:f1:f5:cd:99:dc:07:f1:88: 43:2b:48:f8:55:71:16:8a:d1:0f:c8:24:b7:b6:82: ba:d6:ca:a5:d1:2f:f6:f0:4c:92:78:6b:73:8a:b1: 9b:b7Exponent: 1d:2d:2f:1f:17:3f:81:cf:36:8f:ec:06:d4:0d:47: fd:92:f8:61:5c:12:ee:c1:41:68:f2:88:42:79:52: b8:cf:5a:53:8f:70:ba:33:41:b6:a1:73:ae:80:37: 5a:96:b0:d3:84:d9:72:2b:19:14:9f:78:94:73:75: e0:a3:3d:f5:e6:93:ed:ab:d5:e4:d4:4c:ff:a9:e5: 25:ea:01:4f:3f:a4:99:b5:f7:b2:9b:21:9d:90:b8: 8d:a5:5a:ae:3a:08:63:73:38:d7:be:d0:56:e3:ae: c5:75:be:56:bb:de:53:4b:35:5a:2e:77:57:db:7a: ec:a9:6e:78:d6:7f:21:53:0b:7c:3e:c2:4a:c6:1f: 9b:47:4a:b2:83:22:0d:d9:54:51:35:d0:65:a7:24: ce:2f:8f:44:e3:2e:46:0e:ef:5f:99:58:00:9c:58: af:59:51:93:d7:7e:72:c2:5f:0c:b0:15:05:b9:93: c1:35:32:8b:11:b5:00:dc:ab:c9:55:c9:17:7f:83: 9d:d0:43:58:6e:25:a3:13:35:e7:d5:43:7d:c9:e6: cd:6d:4e:be:cb:29:37:e1:60:26:c2:79:2e:17:45: f4:4e:ed:54:11:be:aa:b5:5e:d0:90:5d:b9:19:8c: bd:43:11:11:be:87:46:2f:46:36:9e:31:d1:a4:61: 3fModulus=C20745223FF5B94B2CD8412166F7288A21F2187E1A421453918CAB03C80253451233EB1BDC2363744228AA8694A8C2CBC833F80DDF40831A68901B230B83F3F0FED4B72D0B942B5E95DEDAC8DCC0047A2AFB90C81ED72D3AD49B72FC8BD0D3167DDDAA6AB5167C058DF36AF190B216085BBD9D621F9BD23A093E4E3D9CC387B6274F2C339C88E1B2D908ACB33F4E20E647ABEE0714A3CCE4646E896294B78103DCC9A4DB7ED681164C6E6CC7FD33476E174A6C707037B250491365F9F0EB76AEABA07DB2F662D88048AF98C88C76C6710DB9658D49FCA0CAF1F5CD99DC07F188432B48F85571168AD10FC824B7B682BAD6CAA5D12FF6F04C92786B738AB19BB7 ​ 不会吧，不会吧，exponent 不会真的是指数吧？老 wiener 了，直接上板子得到 d 。 ​ 生成 private.pem，最后 exp： ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# -*- coding: utf-8 -*-from gmpy2 import *import gmpy2from Crypto.Util.number import long_to_bytesfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPdef continuedfra(x, y): cF = [] while y: cF += [x / y] x, y = y, x % y return cFdef simplify(ctnf): numerator = 0 denominator = 1 for x in ctnf[::-1]: numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator)def calculatefrac(x, y): cF = continuedfra(x, y) cF = map(simplify, (cF[0:i] for i in range(1, len(cF)))) return cFdef solve_pq(a, b, c): par = isqrt(b * b - 4 * a * c) return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerattack(e, n): for (d, k) in calculatefrac(e, n): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) / k p, q = solve_pq(1, n - phi + 1, n) if p * q == n: return abs(int(p)), abs(int(q)) print('not find!')n = 24493816160588971749455534346389861269947121809901305744877671102517333076424951483888863597563544011725032585417200878377314372325231470164799594965293350352923195632229495874587039720317200655351788887974047948082357232348155828924230567816817425104960545706688263839042183224681231800805037117758927837949941052360649778743187012198508745207332696876463490071925421229447425456903529626946628855874075846839745388326224970202749994059533831664092151570836853681204646481502222112116971464211748086292930029540995987019610460396057955900244074999111267618452967579699626655472948383601391620012180211885979095636919e = 3683191938452247871641914583009119792552938079110383367782698429399084083048335018186915282465581498846777124014232879019914546010406868697694661244001972931366227108140590201194336470785929194895915077935083045957890179080332615291089360169761324533970721460473221959270664692795701362942487885620152952927112838769014944652059440137350285198702402612151501564899791870051001152984815689187374906618917967106000628810361686645504356294175173529719443860140795170776862320812544438211122891112138748710073230404456268507750721647637959502454394140328030018450883598342764577147457231373121223878829298942493059211583c = 5005506188015283858618563146910806063877921793777978994915497795876938512755438407136257676431725794584739591081520092904805015329015078208120428335307568025626961078774464089850298597196144685189876104836723992575488792059316933286283680113304988491073245798629428127361669397770834108716291576117851676329812293116545555063668060753416820927621896648263794070909343393833391190511954243001173709216900016519978222229519537931075964991814352014046683068580265025109108417752977595495011359622930468690758616479580008393165416315936108980879332331515829028922252448286421964886808014893689612307271812468977429977314p, q = wienerattack(e, n)assert(p * q == n)assert(gmpy2.is_prime(p) == True)assert(gmpy2.is_prime(q) == True)d = invert(e, (p-1)*(q-1))rsakey=RSA.importKey(open(\"./private.pem\",\"r\").read())rsa = PKCS1_OAEP.new(rsakey)msg=rsa.decrypt(long_to_bytes(c))print(msg)\"\"\"In [45]: rsa = RSA.construct([n,e,d]) In [46]: rsa.exportKey() Out[46]: b'-----BEGIN RSA PRIVATE KEY-----\\nMIIEXgIBAAKCAQEAwgdFIj/1uUss2EEhZvcoiiHyGH4aQhRTkYyrA8gCU0USM+sb\\n3CNjdEIoqoaUqMLLyDP4Dd9AgxpokBsjC4Pz8P7Uty0LlCteld7ayNzABHoq+5DI\\nHtctOtSbcvyL0NMWfd2qarUWfAWN82rxkLIWCFu9nWIfm9I6CT5OPZzDh7YnTywz\\nnIjhstkIrLM/TiDmR6vuBxSjzORkbolilLeBA9zJpNt+1oEWTG5sx/0zR24XSmxw\\ncDeyUEkTZfnw63auq6B9svZi2IBIr5jIjHbGcQ25ZY1J/KDK8fXNmdwH8YhDK0j4\\nVXEWitEPyCS3toK61sql0S/28EySeGtzirGbtwKCAQAdLS8fFz+BzzaP7AbUDUf9\\nkvhhXBLuwUFo8ohCeVK4z1pTj3C6M0G2oXOugDdalrDThNlyKxkUn3iUc3Xgoz31\\n5pPtq9Xk1Ez/qeUl6gFPP6SZtfeymyGdkLiNpVquOghjczjXvtBW467Fdb5Wu95T\\nSzVaLndX23rsqW541n8hUwt8PsJKxh+bR0qygyIN2VRRNdBlpyTOL49E4y5GDu9f\\nmVgAnFivWVGT135ywl8MsBUFuZPBNTKLEbUA3KvJVckXf4Od0ENYbiWjEzXn1UN9\\nyebNbU6+yyk34WAmwnkuF0X0Tu1UEb6qtV7QkF25GYy9QxERvodGL0Y2njHRpGE/\\nAkAh+KKpFWG886QHeF2pJ1y02WI/ujRcTwcW8ua4XraWCV8QtzAJCoxhIAJ6XDOO\\nIu3YQ1lIecqwAV2pbZNMV38/AoGBAOkmqYadbPNvB9gWhZ7iAMgd2w804HJScDwq\\n+SNSv7XllNnh0CJDbY19G3nsfLQy+R2JqzCCdFmIsCJtBHRIvApMykPnsgG5Qfwj\\n/7XK77LGzb8P7X3mrK4eQrELRjpY8h0+YqMDxJ5OYsr8oVj6rD3QMfVu53XhgqoN\\nHD56lYD9AoGBANULF4Vk4SHNib8CbUL5UtBPEYiD7ePRUFvXmMLEA5MgtOfshpmp\\nBiSiXHW4abGnSO9pXUv0v+TW6VYyYbVDFmWH87vni6l6+QnUR6qKlegfBxrVL29y\\ncqFaJz+lt/Zo5QPwvr50mgjQ6hOtD+4SAVgk6a059VKyuTho56XcojfDAkAh+KKp\\nFWG886QHeF2pJ1y02WI/ujRcTwcW8ua4XraWCV8QtzAJCoxhIAJ6XDOOIu3YQ1lI\\necqwAV2pbZNMV38/AkAh+KKpFWG886QHeF2pJ1y02WI/ujRcTwcW8ua4XraWCV8Q\\ntzAJCoxhIAJ6XDOOIu3YQ1lIecqwAV2pbZNMV38/AoGBAJ/8/LizZOrBACJ8R1ma\\nUWAvuuxI7lGac2B+/A/EcwBJfOT/qLCPpvFhA0Qje1HqlNSXc9e/FGt1UwxZkJBJ\\nJNGhlKRKaB0RJgJW5dA1jfyYU8xpPsDxfdDzLf2y167IbfqNNmL7ZF8IHj5+hPsB\\n0oVAN0gvoLxcOM2qMOXIt6aM\\n-----END RSA PRIVATE KEY-----'In [47]: output = rsa.exportKey() In [48]: f=open(\"private.pem\",\"w\") ...: f.write(output.decode()) ...: f.close() \"\"\" ​ ​ ​ CTF小白的密码系统小白？非预期？离谱 。有一说一，这题也不难。 ​ 不懂可以先看一手 sm4 : https://buki-freak.github.io/2020/09/12/SM4-Algorithm-Learning/ ​ 审计代码。这题考点是 sm4 的 cbc 模式。首先生成一个 16 bytes 的 key，然后有一个 proof，proof 之后给 一个 menu，菜单功能依次如下： ​ Dragon King: 输出一串事先写好的字符，没有什么意义 encryption: 输入一串明文，远程加密之后返回 decryption: 输入 iv，然后远程用我们输入的 iv 解密 encryption 阶段产生的密文 getflag: 给出加密后的 flag exit: 退出 ​ 一时间想到的是 padding oracle，然后再看看 sm4_encryption.py，不得了，key 和 iv 是相同的。 ​ 画个图清理下思路： ​ ​ 图只画了一部分。分组大小是 16 bytes。现在我们假设传入一个 16 bytes 的明文 $M_0$ 加密，返回密文 $C_0$。 ​ 因为解密的 iv 是我们决定的，假设我们传入 $iv\\;=\\;0x00$，返回的明文为 $M_0’$，因为异或结果没有影响，因此 我们有中间值 $M_0’\\;=\\;SM4-De(C_0)$，同时得到 $key/iv\\;=\\;M_0’\\;\\oplus\\;M_0$。 ​ 得到 key 和 iv，可是不能直接在远程解密。用自己写的 sm4 解密一手，发现不对，自闭了一下午。 ​ 解铃还须系铃人，拿着给的 file 写解密脚本，终于出了。怀疑出题人的加密写错了。 ​ 赶时间写，乱。。 ​ ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188\"\"\"ip: 183.129.189.61port: 53800protocol: tcp\"\"\"import hashlibimport binasciifrom Crypto.Util.number import *class sm4_encryption: CK = [0x00070F15,0x1c232a31,0x383f464d,0x545b6269, 0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9, 0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249, 0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9, 0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229, 0x30373e45,0x4c535a61,0x686f767d,0x848b9299, 0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209, 0x10171e25,0x2c333a41,0x484f565d,0x646b7279] FK = [0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc] SboxTable = [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48] K = [] MK = [] key = 0 X = [] Y = [] txtstream = [] lenth = 0 def __init__(self,key): self.key = key self.K = [] # expand_key_box self.MK = [] self.X = [] self.Y = [] self.txtstream = [] self.lenth = 0 pass def __key__expand__(self): for i in range(0,13,4): self.MK.append(self.__union__hex__(self.key[i:i+4])) for i in range(4): self.K.append(self.MK[i] ^ self.FK[i]) for i in range(32): a = self.K[i+1] ^ self.K[i+2] ^ self.K[i+3] ^ self.getCK(i) b = self.__apart__hex__(a) c = [self.getSbox(i) for i in b] d = self.__union__hex__(c) e = d ^ (d &lt;&lt;13) ^ (d &lt;&lt; 23) self.K.append(self.K[i] ^ e) def __union__hex__(self,data): return int((data[0] &lt;&lt; 24) | (data[1] &lt;&lt; 16) | (data[2] &lt;&lt; 8) | (data[3])) def __apart__hex__(self,data): return [int((data &gt;&gt; 24) &amp; 0xff), int((data &gt;&gt; 16) &amp; 0xff), int((data &gt;&gt; 8) &amp; 0xff), int((data) &amp; 0xff)] def getSbox(self,i): return self.SboxTable[i] def getCK(self,i): return self.CK[i] def encrypt(self,bits,mk): self.X = [] self.Y = [] for p in range(0, len(bits), 16): # len(bits) is always 16 plaintxt = bits[p:p+16] self.X = [] for i in range(0,13,4): self.X.append(self.__union__hex__(plaintxt[i:i+4])) j = 4 for i in range(0,32): a = self.X[i+1] ^ self.X[i+2] ^ self.X[i+3] ^ self.K[j] j = j + 1 b = self.__apart__hex__(a) c = [self.getSbox(i) for i in b] d = self.__union__hex__(c) e = d ^ (d &lt;&lt; 2) ^ (d &lt;&lt; 10) ^ (d &lt;&lt; 18) ^ (d &lt;&lt; 24) self.X.append(self.X[i] ^ e) t = self.X[35] self.X[35] = self.X[32] self.X[32] = t t =self.X[34] self.X[34] = self.X[33] self.X[33] = t for i in range(32,36): self.Y.append(self.X[i]) byte=[] for i in self.Y: a = self.__apart__hex__(i) for j in a: byte.append(j) return byte def encrypt_cbc(self,Plaintext,Key): mk=bytes_to_long(Key) Plaintext_bytes=binascii.hexlify(bytes(Plaintext.encode('utf-8'))) # 16 hex Plaintext_str = str(Plaintext_bytes)[2:-1] iv=mk # key as iv if len(Plaintext_str)%32!=0: Plaintext_str+=hex((32-len(Plaintext_str)%32)//2)[2:].zfill(2)*((32-len(Plaintext_str)%32)//2) # padding Ciphertext='' for i in range(0,len(Plaintext_str),32): tmp=eval('0x'+Plaintext_str[i:i+32])^iv res=self.encrypt(long_to_bytes(tmp),mk) Ciphertext+=self.list_to_hex(res) iv=eval('0x'+self.list_to_hex(res)) return Ciphertext def list_to_hex(self,arr): hex_re=\"\" for i in arr: hex_re+=hex(i)[2:].zfill(2) return hex_re def decrypt_cbc(self,Plaintext,key): mk = bytes_to_long(key) Plaintext_bytes=binascii.hexlify(bytes(Plaintext.encode('utf-8'))) # 16 hex Plaintext_str = str(Plaintext_bytes)[2:-1] iv=mk # key as iv if len(Plaintext_str)%32!=0: Plaintext_str+=hex((32-len(Plaintext_str)%32)//2)[2:].zfill(2)*((32-len(Plaintext_str)%32)//2) # padding Ciphertext='' for i in range(0,len(Plaintext_str),32): tmp=eval('0x'+Plaintext_str[i:i+32])^iv res=self.encrypt(long_to_bytes(tmp),mk) Ciphertext+=self.list_to_hex(res) iv=eval('0x'+self.list_to_hex(res)) return Ciphertext # check pass\"\"\"key = b'\\xc0:\\x8dF3ll\\xd7\\x85\\xe0\\xd7\\x01\\x1c\\xe63\\x9c'sm = sm4_encryption(key) # initialsm.__key__expand__() # key generationmessage = '1234567812345678'en_message=sm.encrypt_cbc(message,key) # encrypt the messageprint(en_message)\"\"\"# test encryptkey = b'\\xc0:\\x8dF3ll\\xd7\\x85\\xe0\\xd7\\x01\\x1c\\xe63\\x9c'sm4d = sm4_encryption(key)sm4d.__key__expand__()sm4d.K = sm4d.K[:4] + sm4d.K[4:][::-1]sm4e = sm4_encryption(key)sm4e.__key__expand__()bc1 = b'\\x0f\\xb4&gt;\\xfc\\xaa\\x8f~\\x8b\\xc5l\\xbe\\x90Hl\\x9c\\x13'bp1 = sm4d.list_to_hex(sm4d.encrypt(bc1,key))bp1 = b'.7K\\x9f\\xeb\\x91H6O\\xb8\\xb7\\xd8y\\xbb^w'bc0 = b'L\\x02.\\xa6\\xdd\\xa6,KG\\xb0\\xbf\\xd0q\\xb3V\\x7f'bp1 = bytes_to_long(bc0) ^ bytes_to_long(bp1)bp1 = long_to_bytes(bp1)print(bp1)# input:1234567812345678# DASCTF&#123;0bb44fe8a9203b89b35d36585b5e967d&#125;\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08# en_flag: b\"@\\xdaq\\xa1\\x8cHa\\xafcv\\xe9#\\x8b'\\x96\\x00L\\x02.\\xa6\\xdd\\xa6,KG\\xb0\\xbf\\xd0q\\xb3V\\x7f\\x0f\\xb4&gt;\\xfc\\xaa\\x8f~\\x8b\\xc5l\\xbe\\x90Hl\\x9c\\x13\"# In [68]: cipher \"\"\" In [69]: key Out[69]: 255515793790139171964703183498104943516In [70]: plaintext Out[70]: 65392825175610104412159903676386129720\"\"\" ​ ​ 注意 sm4 的解密只需把子秘钥逆序。子秘钥是 32 组。 ​ ​ Crypto 3​ 题目名忘了，脚本写得都是啥。。。。等一手 wp。 ​ ​ 坚持！","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"SageMath-Learning-I","slug":"SageMath-Learning-I","date":"2020-09-25T01:16:54.000Z","updated":"2020-10-11T07:07:51.639Z","comments":true,"path":"2020/09/25/SageMath-Learning-I/","link":"","permalink":"https://buki-freak.github.io/2020/09/25/SageMath-Learning-I/","excerpt":"","text":"​ 学习完抽象代数部分，感觉不光要搞懂理论，还得搞好实践和运用，所以学习一下 Sage 的抽象代数部分。 ​ ​ Group Theory and Sage​ Basic properties of the integers​ 扩展欧几里得函数 xgcd ： ​ ​ 返回是一个三元组，第一个元素为 $a$ 和 $b$ 的 gcd ，第二个和第三个元素是 $r$ 和 $s$ 满足 $ra\\;+\\;sb\\;=\\;gcd(a,\\;b)$ 。 ​ 分解（decomposition）函数 factor ： ​ ​ factor 函数返回的是一个二元组的数组，但显示的时候会自动转换为数学公式形式。 ​ ​ factor 函数还可以用于分解多项式。 ​ 如果只想要提取某个数的因子，可以用 prime_divisors 函数。 ​ ​ 求逆元用 inverse_mod 函数，模幂运算用 power_mod 函数， 欧拉函数（Euler $\\phi$ function）用 euler_phi 函数。 ​ ​ Groups​ 好像没啥可看的，先留个坑。 ​ ​ Basic Rings​ 再来学习一下环。先搞清楚四种类型环的表示，偷个图： ​ ​ 整数环为 $ZZ$ ，有理数环为 $QQ$ ，实数环为 $RR$ ，复数环为 $CC$ 。 ​ Rings of integers module n​ 同余类，又称 ring of integers of modulo n ，记作 $\\Z/n\\Z$ 。 ​ 定义同余类的方法，有三种： ​ 123sage: Zmod(4) == Integers(4)sage: Zmod(4) == IntegerModRing(4)True ​ ​ Polynomial Rings​ Reference 里面大部分是多项式环的定义，并且分两种：单变量 和 多变量 。 ​ ​ 定义整数上的多项式环： ​ 1sage: retpoly.&lt;z&gt; = PolynomialRing(RR) ​ 一般情况下的定义： ​ ​ 再举几个例子： ​ 有理数上的多项式环： ​ 123sage: R.&lt;x&gt; = PolynomialRing(QQ)sage: RUnivariate Polynomial Ring in x over Rational Field ​ 欧几里得环： ​ 123sage: R.&lt;x&gt; = PolynomialRing(GF(3))sage: RUnivariate Polynomial Ring in x over Finite Field of size 3 ​ 在剩余类中的多项式： ​ 123sage: R = Zmod(123)['x']sage: RUnivariate Polynomial Ring in x over Ring of integers modulo 123 ​ Sage 中还有多项式其他的书写定义方式： ​ 123456sage: R.&lt;z&gt; = QQ[] # 方括号书写 1sage: RUnivariate Polynomial Ring in z over Rational Fieldsage: R = QQ['z'] # 方括号书写 2sage: RUnivariate Polynomial Ring in z over Rational Field ​ 123sage: R = PolynomialRing(QQ,'z,y,c') # 常规书写方式sage: RUnivariate Polynomial Ring in z, y, c over Rational Field ​ 带上第三个参数。 ​ 123sage: R = PolynomialRing(QQ,'z',10)sage: RMultivariate Polynomial Ring in z0, z1, z2, z3, z4, z5, z6, z7, z8, z9 over Rational Field ​ 更骚一点。 ​ 123sage: R = PolynomialRing(ZZ,['x%s'%p for p in primes(10)])sage: RMultivariate Polynomial Ring in x2, x3, x5, x7 over Integer Ring ​ PolynomialRing.inject_variables() 方法可以查看当前已经定义的变量。 ​ ​ 在不同数集的环，相同的计算会产生不同的结果。如： ​ 123456sage: ratpoly.&lt;t&gt; = PolynomialRing(QQ)sage: factor(t^2 - 2)t^2 - 2sage: retpoly.&lt;z&gt; = PolynomialRing(RR)sage: factor(z^2 - 2)(z - 1.41421356237310) * (z + 1.41421356237310) ​ 上面提到过 factor 可以分解多项式，上面的例子是一个很好的运用。 ​ 发现 Sage 中有一个查找变量类型的方法，parent 函数： ​ 123456sage: ratplot.&lt;t&gt; = PolynomialRing(CC)sage: ttsage: sage: parent(t)Univariate Polynomial Ring in t over Complex Field with 53 bits of precision ​ 求欧几里得环中的首一不可约多项式，使用 irreducible_element 函数， 第一个参数指定 degree 。 ​ 1234567sage: R = GF(47)['x']sage: R.irreducible_element(1)x + 46sage: R.irreducible_element(2)x^2 + 45*x + 5sage: R.irreducible_element(4)x^4 + 8*x^2 + 40*x + 5 ​ ​ Fields​ 定义有理域： ​ 12sage: RationalField()Rational Field ​ 定义整数有限域 $GF(p),\\;where\\;p\\;is\\;a\\;prime$ : ​ 12sage: R = GF(149);RFinite Field of size 149 ​ 定义有限域 $GF(p^e),\\;where\\;p\\;is\\;a\\;prime$ ，也就是欧几里得环下商环产生的域： ​ 12sage: R = GF(2^10,name='x',modulus=x^10 + x^6 + x^5 + x^3 + x^2 + x + 1);RFinite Field in x of size 2^10 ​ 由于是多项式，所以需要给出变量名，这里是 $x$ ，并且给出产生商环的 不可约多项式 $m$ ，这里是 $x^{10}\\;+\\;x^6\\;+\\;x^5\\;+\\;x^3\\;+\\;x^2\\;+\\;x +\\;1$ 。 ​ SageMath 会检测传入的 irreducible polynomial 是否为不可约。如果没有 指定不可约多项式和变量名，那么 Sage 会自动产生一个变量名和一个不可 约多项式。 ​ ​ ​ References​ https://doc.sagemath.org/html/en/thematic_tutorials/group_theory.html","categories":[],"tags":[{"name":"Sage","slug":"Sage","permalink":"https://buki-freak.github.io/tags/Sage/"}]},{"title":"An-Introduction-to-Mathematical-Cryptography-II","slug":"An-Introduction-to-Mathematical-Cryptography-II","date":"2020-09-25T01:11:11.000Z","updated":"2020-11-18T14:27:37.071Z","comments":true,"path":"2020/09/25/An-Introduction-to-Mathematical-Cryptography-II/","link":"","permalink":"https://buki-freak.github.io/2020/09/25/An-Introduction-to-Mathematical-Cryptography-II/","excerpt":"","text":"​ 椭圆曲线之前已经学习过部分，进行选择性阅读。 ​ Elliptic Curves and Cryptography​ ​ [TOC] Elliptic curves​ 椭圆曲线上的点满足 Weierstrass equations ，方程类似于为： ​ Y^2\\;=\\;X^3\\;+\\;AX\\;+\\;B​ 椭圆曲线上的两个不同点的加法之前已经学习过，从几何上来说，比如在椭圆曲线 $E$ 上有 $P$ 和 $Q$ 两点，$P$ 和 $Q$ 决定的直线 $L$ 和 椭圆曲线 $E$ 的另一交点 $C$ 关于 $x$ 轴的对称点 $C’$ 为 $P$ 和 $Q$ 加法的结果，写作： $P\\;+\\;Q\\;=\\;C’$。 ​ 从数学上来说，可以联立直线 $L$ 和 椭圆曲线方程 $E$ ，由于有两个点的 $x$ 坐标已知，所以可以写成关于 $x$ 的 一次多项式乘积的形式。 ​ ​ 对于两个相同点的加法，几何上来说是去切线交点对称。 ​ 按照这个方法进行加法会产生第二个问题。比如有一个点 $P$ 和它的 $x$ 轴对称点 $P’$ ，两者做加法，直线 $L$ 在 几何上垂直于 $x$ 轴，所以找不到第三个交点，所以需要再定义一个不存在于 $X-Y$ 轴的点 $\\mathcal{0}$ ，并且规定他 在任意一条垂直于 $x$ 轴并且与椭圆曲线 $E$ 相交的直线上。 ​ 按照上面的规定，$P\\;\\oplus\\;\\mathcal{0}\\;=\\;P$ 成立，$\\mathcal{0}$ 的作用类似于加法中的 $0$ 。 ​ ​ 再看一下椭圆曲线的定义： ​ ​ 重点是这个后面的判别式，因为 $\\delta\\;=4A^{3}\\;+\\;27B^{2}\\;\\neq\\;0$ 是为了确保三次多项式 $X^3\\;+\\;AX\\;+\\;B$ 有不 重复的根。 ​ ​ 椭圆曲线下的加法规则满足： ​ ​ 椭圆曲线上的点集以及它特定的加法规则结合起来是一个阿贝尔群，或者是交换群。 ​ ​ ​ Elliptic curves over finite fields​ 有限域的椭圆曲线的简单定义： ​ ​ 这个定义有点类似于欧几里得环。 ​ 有限域下的椭圆曲线 $E(F_{p})$ 也满足 Theorem 5.5 的运算规则。 ​ Hasse Theorem 可以估计有限域 $F_p$ 下椭圆曲线点的数量，但只是一个区间： ​ ​ ​ ​ The elliptic curve discrete logarithm problem​ 对于有限域 $F_p^{*}$ 下的 DLP，我们有： ​ h\\equiv g^x\\;(mod\\;p)​ 对于椭圆曲线 $E(F_p)$，可以定义一个对应的 DLP： ​ ​ 其中公钥是 $P$ ，私钥为 $n$ ，并且它是计算困难的。 ​ 关于私钥 $n$，由于 $P\\in E(F_p)$ ，所以 $n$ 可能会有多个值，假设满足上面等式的最小值为 $n_0$ ，那么关于 $n$ 我们有： ​ n\\;=\\;n_0\\;+\\;ks,\\;i\\in\\Z​ 其中 s 为 $P$ 点的 order ，这个 order 可能会比 $#E(F_p)$ 要小，即椭圆曲线上的所有点可能不全是 $P$ 点 的“积”。 ​ ​ ​ The Double-and-Add Algorithm​ 模幂运算也有一个 square-and-multipy algorihtm，这里椭圆曲线也整一个类似的，只不过这里是作加法， 大致的运算过程： ​ ​ ​ ​ Elliptic curve cryptography​ 跟普通的 DLP 类似，ECDLP 可以运用于DHKE 以及 Elgamal，贴两张 flow chart 以便复习。 ​ Elliptic Diffie–Hellman key exchange​ 以 Alice 和 Bob 的传输为例： ​ ​ ​ 有一个小细节，在共享秘钥的时候，$Q_A$ 或者 $Q_B$ 仅需要分享 $x$ 坐标。由于椭圆曲线是提前确定的，所以对 于同一个 $x$ 坐标，仅仅会有两个不同的 $y$ 值，这样减少了传送的长度。 ​ ​ Elliptic ElGamal public key cryptosystem​ ​ 相对于普通有限域下的椭圆曲线，密文与明文相比多了四倍。类似于前面的 ECDHKE，这里也可以只发送 $C_1$ 和 $C_2$的 $x$ 坐标，但是 $y$ 需要精确正负，所以需要附加一个 $y$ 的 $sign\\;bit$ 。 ​ ​ ​ Lenstra’s elliptic curve factorization algorithm​ ​ Lenstra’s 根据椭圆曲线上有限域的性质提出了另外一种分解质数的方法。 ​ 这种分解方法十分有趣，它基于椭圆曲线上的计算 error（计算 point addition 的时候找不到某个数对应 的逆元，因为目标分解数是合数），来得到目标分解数的一个因子。算法的思想很简单。 ​ 具体过程： ​ ​ ​ 这种算法的时间复杂度取决于 $N$ 的最小素因子的大小，而不是传统算法所要求的 $N$ 的大小，所以这种分解方 法对于两个大小接近的素数乘积几乎不起作用。 ​ ​ ​ 剩下的部分留到以后再仔细阅读吧，之后再写一个关于椭圆曲线的 SageMath 使用方法。 ​ ​ Elliptic curves over $F_2$ and over $F_{2^k}$​ Bilinear pairings on elliptic curves​ The Weil pairing over fields of prime power order​ ​ ​ Reference​ ​ An Introduction to Mathematical Cryptography ​ ​ ​ 坚持！","categories":[],"tags":[{"name":"Textbook","slug":"Textbook","permalink":"https://buki-freak.github.io/tags/Textbook/"}]},{"title":"An-Introduction-to-Mathematical-Cryptography-I","slug":"An-Introduction-to-Mathematical-Cryptography-I","date":"2020-09-14T08:19:33.000Z","updated":"2020-09-22T13:05:28.634Z","comments":true,"path":"2020/09/14/An-Introduction-to-Mathematical-Cryptography-I/","link":"","permalink":"https://buki-freak.github.io/2020/09/14/An-Introduction-to-Mathematical-Cryptography-I/","excerpt":"","text":"​ An Introduction to Mathematical Cryptography 读书笔记。由于之前看过 Introduction to Cryptography， 所以打算选择性阅读（陌生以及忘却的知识。 ​ ​ Chapter TwoAn overview of the theory of groups先学习交换群（commutative group），或者叫阿贝尔群（abelian group）。 ​ 交换群的属性，以乘法（multiplication）群 $F^{*}_{p}$ 为例： ​ ​ 满足四个条件： 存在一个单位元 1 对于 group 内每一个元素，存在一个唯一的逆元（群内每一个元素都与 $p$ 互质） 结合律 交换律 ​ 如果是加法（addition）群 $F_p$，则有以下性质： ​ ​ 也满足四个条件： 存在一个单位元 0 对于 group 内每一个元素，存在一个唯一的逆元 结合律 交换律 ​ ​ 上面两个属于特殊的群，不失一般性，给出一般群的定义： ​ ​ ​ 同时满足四个条件： 对于 group 内每一个元素，存在一个单位元 $e$ 满足 $e\\;*\\;a\\;=\\;a$ 。 对于 group 内每一个元素，对应存在一个唯一的逆元 $a^{-1}$ 满足 $a\\;*\\;a^{-1}\\;=\\;1$ 。 结合律，即 $for\\;all\\;a,b,c\\;\\in\\;G,\\;satisfying\\;a·(b·c)\\;=\\;(a·b)·c$ 。 交换律，即 $for\\;all\\;a,b\\;\\in\\;G,\\;satisfying\\;a·b\\;=\\;b·a$ ​ 若交换群 $G$ 的元素数量有限，则这个群又称为有限群（finite group）, 群内的元素数量记作 $|G|$或 $#G$ 。 ​ 再记两个特殊的交换群，存个图： ​ ​ (b) 中 $Z/NZ$ ，group 中元素个数为 $N$，所以同时也是有限群，举例： $G\\;=\\;\\{-3,-2,-1,0,1,2,3\\}$ 。 (c) 中 $Z$，group 中元素个数无限（所有整数）。 ​ 元素的 order ： ​ ​ ​ 对于元素的 order 有 Lagrange’s Theorem： ​ ​ ​ Solving congruence with composite moduli计算 $F_p^{*}$ 下的二次根： ​ ​ ​ 如果模数 $p$ 为合数，则先分解 $p$ ，然后分别化简不同因子下的同余方程，然后使用中国剩余定理计算不同因子 下的同余方程组。 ​ ​ The Pohlig-Hellman Algorithm​ Pohlig-Hellman 解决 DLP 的方法使用了中国剩余定理。对于 $F_{p}^{*}$ 下的 DLP 问题，通过分解 $p\\;-\\;1$ 来解 决，所以其算法复杂度是由分解难度决定的。 ​ ​ 对于 $|G|\\;=\\;N\\;=\\;q_1^{e_1}·q_2^{e_2}···q_t^{e_t}$ ，Pohlig-Hellman 方法的计算时间复杂度为： ​ ​ 对于所有 $q_i$ 都特别小的情况，计算时间会明显缩短。 ​ 在相同情况下，对比下两种算法的时间复杂度： ​ ​ ​ 再贴一下 Shank’s Babystep-Giantstep Algorithm 的， ​ ​ 对于同一 $order\\;q^{e},\\;e\\;\\geq\\;1$ ，PH 的时间复杂度大约为： $O(e\\sqrt{q}）$ ，而 BSGS 的时间复杂度大约为： $O(\\sqrt{q^{e}})$， 当 $e\\;\\geq\\;2$ 的时候，PH 的计算时间要小得多。 ​ 证明过程大概就是计算的过程，下面进行详细学习： ​ 对于单个素数或者其幂的情况： ​ g^{x}\\;=\\;h,\\;where\\;the\\;order\\;of\\;g\\;is\\;q^{e}\\;with\\;e\\;\\geq\\;1​ 先将 $x$ ，写成 $x\\;=\\;x_{0}\\;+\\;x_{1}q\\;+\\;x_2q^{2}\\;+\\;···\\;+x_{e-1}q^{e-1}\\;\\;with\\;0\\;\\leq\\;x_i\\;&lt;\\;q$ ， 然后计算 $x_0,\\;x_1,\\;x_2,\\;….\\;x_{e-1}$ 的确切值。这里需要用到 $g’\\;=\\;g^{q^{e-1}}$ 的 order 为 $q$ 的性质，直接截个图： ​ ​ ​ 由于 $0\\;\\leq\\;x_0\\;&lt;\\;q$ ，所以这里就转换为另一个 order 为 $q$ 的 DLP 问题。认真的读还是会发现， 这里还是需要使用 BSGS 算法，所以时间复杂度为： $O(\\sqrt{q})$ 。再利用相似的方法计算 $x_1$ ： ​ ​ 同样地，得到： ​ (g^{q^{e-1}})^{x_1}\\;=\\;(h\\;·\\;g^{-x_0})^{q^{e-2}}​ 由于 $x_0$ 已知，这里又转化为另一个 DLP 问题，使用 BSGS 算法可以计算出 $x_1$ ，时间复杂度为 $O(\\sqrt{q})$ 。 ​ 从上面两条式子我们找出一般性： ​ (g^{q^{e-1}})^{x_i}\\;=\\;(h\\;·\\;g^{-x_0-x_1-···-x_{i-1}q^{i-1}})^{q^{e-i-1}}\\;\\;in\\;\\;G.​ 由于每一个解 $x_i$ 的时间复杂度为 $O(\\sqrt{q})$ ，所以计算 $x$ 的总时间复杂度为：$O(eS_q)\\;=\\;O(e\\sqrt{q})$ 。 ​ 证明完成。剩下的就是将计算结果交给中国剩余定理，其时间复杂度为： $O(log_{2}N)$ ，其中 $N$ 为$|G|$ 。 ​ 计算步骤： ​ ​ 注意这里的 $N$ 为 $|G|$ 。计算 $g_i\\;=\\;g^{N/q_{i}^{e_i}}$ 是为了得到 $g_i\\;with\\;order\\;q_i^{e_i}$ 。 ​ 再贴一次 PH 算法的时间复杂度： ​ ​ ​ 顺便提一下， sageMath 中的 discrete_log 函数使用的就是 Pohlig-Hellman Algorithm 和 Baby Step Giant Step Algorithm 的结合。 ​ ​ ​ Rings, quotient rings, polynomial rings, and finite fields​ Rings​ 对总结一下这一章的知识和之后密码体系的关联： ​ Cryptosystem Knowledge Elliptic Curve Cryptography Finite Fields Lattice-based NTRU Cryptosystem Quetients of polynomial rings ​ ​ 普通的环（Ring）： ​ ​ 同时满足下面条件： ​ 对于 “+” operation： ​ 存在一个单位元，对于所有元素，满足 $0\\;+\\;a\\;=\\;a\\;+\\;0\\;=\\;a$ 。 对于所有元素 $a$，存在对应的逆元 $b$ ，满足 $a\\;+\\;b\\;=\\;b\\;+\\;a\\;=\\;0$ 。 对于所有元素，满足结合律。 对于所有元素，满足交换律。 ​ Ring 上的元素加上 “+” operation 可以看成是一个交换群。 ​ 对于 “*” operation，这里由于显示问题，我将其写成 “·”： ​ 存在一个单位元，对于所有元素满足 $1\\;·\\;a\\;=\\;a\\;·\\;1\\;=\\;a$ 。 对于所有元素，满足结合律。 对于所有元素，满足交换律。 ​ RIng 上的元素加上 “*” operation 可以看成是一个幺半群。 ​ 对于两个 operation： ​ 满足分配律， $a\\;·\\;(b\\;+\\;c)\\;=\\;a\\;·\\;b\\;+\\;a\\;·\\;c$ 。 ​ 上面这个环实际上属于交换环，但是由于我们经常会碰到这个类型的环，所以我们简称之为环。 ​ 下面记一个环的例子： ​ ​ ​ 如果对环再加上要求，可能就是域了，看看 field 和 ring 之间的关系： ​ ​ 仔细一下其实也就多了一个乘法的逆元。 ​ ​ Divisibility and Quotients Rings​ 先看一下什么是 Divisibility： ​ ​ 环上的 Divisibility 和整数的整除性基本相同。 ​ 回忆一下，如果一个数除了 $-1$ 和 $1$ 因子以外，没有其他多余的（trivial）因子，那么这个数为质数。 原因是 $1$ 和 $-1$ 都存在乘法逆元（本身）。所以在环的定义上，如果一个元素存在乘法逆元，那么这个元素称为 unit。 ​ 再看一下 unit 的定义： ​ ​ 如果 $u\\;\\in\\;R$ ，且 $u$ 有乘法上的逆元，则 $u$ 被称为 unit，这里 unit 就相当于前面提到的 $1$ 和 $-1$ 。 如果 $u$ 不是 unit 并且它的二元分解中有一个是 unit，它就是不可约的。这里不可约的相当于前面提到的质数。 ​ 看一下环上的同余定义： ​ ​ 对于同一模数的两个环，两个环上的同余式可以进行加法，减法和乘法。 ​ 下面学习下商环，简单地看下定义： ​ ​ 商环又称为剩余类环，它也满足加法，减法和乘法的性质。 ​ ​ 利用上面的方法我们可以生成一个新的环。 ​ Polynomial rings and the Euclidean algorithm​ 看一下多项式环简单的定义： ​ ​ coefficients 也可以从 $Q,\\;R,\\;C$ 或者是有限域 $F_p$ 中取。密码学中 $F_p$ 中出现的情况比较多，这种 类型的环我们称之为 Euclidean Ring （欧几里得环）。 ​ 再认识几个关于多项式的概念： ​ ​ 对于一个非零的多项式，最高次项的幂被称为 degree 。对于多项式 $a(x)$ ，其 degree 可以记为 $deg(a)$ 。 最高次项的系数被称为 leading coefficient 。如果 leading coefficient 为 $1$ ，我们称这个多项式 为 monic polynomial 。 ​ 再看一下 $F_p$ 下的环，也就是 Euclidean Ring 的定义： ​ ​ 其中，$k$ 被称为商，$r$ 被称为剩余。 ​ Euclidean Ring 下最大公因数的定义： ​ ​ 定义很容易理解，因为在有限域内，通常我们将取 monic 的那个 gcd。 ​ 再学习一下 Euclidean Ring 下的扩展欧几里得定理： ​ 感觉这是一个扩展欧几里得定理的变体，这个定理有两个用途： ​ 计算同一 Euclidean Ring 下两个多项式的 gcd 因式分解 Euclidean RIng 下的多项式 ​ 先看计算 gcd 的方法： ​ 大前提： ​ ​ 计算方法： ​ ​ 步骤看懂了，可是原理看得不太懂？反正一直计算到 $r_{t+1}$ 就 ok 。 ​ ​ 再看分解的方法： ​ 大前提： ​ ​ Euclidean Ring 下的任何一个非零多项式，都可以唯一地被分解成不同的首一不可约多项式和常量的乘积。 ​ Quotients of polynomial rings​ 有点拗口，前面学得剩余类环（Quotients Rings），现在又整一个 Quotients of polynomial rings ， 说白了就是 Polynomial Rings 产生的剩余类环。整一个定义： ​ ​ 重点学习 Euclidean RIng 的剩余类环。 ​ Euclidean Rings 产生的剩余类环依然满足剩余类环的某些性质，即加法、减法和乘法。 ​ Euclidean Rings 产生的剩余类环的 unit 有如下性质： ​ ​ ​ Euclidean RIngs 产生的剩余类环同时是域， 需要满足的条件： ​ ​ 对于产生的剩余类环 $F[x]/(m)$ ，如果 $m$ 是不可约多项式，因为： ​ for\\;every\\;a\\in F[x]/(m),\\;gcd(a,m)\\;=\\;1​ 那么剩余类环中每个元素都存在一个乘法逆元，这时候 $F[x]/(m)$ 就是一个域。 ​ 这个产生的 $F[x]/(m)$ 域有如下性质： ​ ​ 很容易理解，就是有 $d$ 个项（$a_0\\;\\sim\\;a_{d-1}$），因为每个项有 $p$ 个可能取值，并且这些所有可能的 取值都在这个域中，所以这个域中有 $p^d$ 个元素。这个域就是有名的 Galois Fields，可记为 $GF(p^d)$ ， 或者记为 $F_{p^d}$ ，说明这个域有 $p^d$ 个元素。 ​ 这个跟整数的有限域 $GF(p)$ 有几分神似： ​ 比如： ​ ​ 还有： ​ ​ ​ ​ 最后补充一些性质： ​ ​ 最后一点提到，如果两个有限域的元素个数相同，那么就称这两个有限域同构。 ​ 对于两个域 $F_{p^e}$ 和 $F_{p^d}$ ，如果有 $e\\;|\\;d$ ，那么称 $F_{p^e}$ 为 $F_{p^d}$ 的子域。 ​ ​ Reference: An Introduction to Mathematical Cryptography ​ ​ 坚持！","categories":[],"tags":[{"name":"Textbook","slug":"Textbook","permalink":"https://buki-freak.github.io/tags/Textbook/"}]},{"title":"SM4-Algorithm-Learning","slug":"SM4-Algorithm-Learning","date":"2020-09-12T01:06:44.000Z","updated":"2020-09-14T08:07:35.925Z","comments":true,"path":"2020/09/12/SM4-Algorithm-Learning/","link":"","permalink":"https://buki-freak.github.io/2020/09/12/SM4-Algorithm-Learning/","excerpt":"","text":"最近在看差分分析，碰到了 SM4 算法，学习一下。 ​ Introduction先看一下 SM4 的特点： ​ subjects length key length 128 bits block length 128 bits rounds 32 ​ 对于 SM4 算法，定义以下符号： $\\oplus$ 为 32 bits 异或，$&lt;&lt;&lt; i$ 为 32 bits 循环左移 i 位。 ​ Encryption&amp;Decryption贴个图。 ​ ​ ​ 加密算法由 32 次迭代运算 和一次 反序变换 构成，其中： ​ 32 次迭代运算： $X_{i+4}\\;=\\;F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_i),\\;i=0,1,…,31$ 反序变换：$(Y_0,Y_1,Y_2,Y_3)\\;=\\;R(X_{32},X_{33},X_{34},X_{35})\\;=\\;(X_{35},X_{34},X_{33},X_{32})$ ​ 解密算法和加密算法的结构相同，不同的是解密使用倒序的子秘钥序。 ​ 先看一下 F 函数。 ​ F Function​ 轮函数的结构跟 DES、AES 的区别还是挺大的。 ​ 输入 : 密文分组 $(X_0,X_1,X_2,X_3)\\;\\in\\;(Z_{2}^{32})^4$，轮秘钥 $rk\\;\\in\\;Z_{2}^{32}$ 输出 : $F(X_0,X_1,X_2,X_3)\\;=\\;X_0\\oplus T(X_1\\oplus X_2\\oplus X_3\\oplus rk)$ ​ 其中 T 函数为合成置换，合成置换可逆，它由非线性变换 $\\tau$ 和 线性变换 $L$ 复合而成。 ​ 非线性变换 $\\tau$$\\tau$ 由四个 parallel 的 S-box 组成，简单易懂。 ​ 输入： $A\\;=\\;(a_0,a_1,a_2,a_3)\\;\\in\\;(Z_{2}^{8})^4$ 输出： $B\\;=\\;(b_0,b_1,b_2,b_3)\\;=\\;\\tau(A)\\;=\\;(Sbox(a_0),Sbox(a_1),Sbox(a_2),Sbox(a_3))\\;\\in\\;(Z_{2}^{8})^4$ ​ S-box： ​ ​ 线性变换 $L$​ 线性变换需要用到上面定义的逻辑位移运算。 ​ 输入： $B\\;\\in\\;Z_{2}^{32}$ 输出： $C\\;=\\;L(B)\\;=\\;B\\oplus(B&lt;&lt;&lt;2)\\oplus(B&lt;&lt;&lt;10)\\oplus(B&lt;&lt;&lt;18)\\oplus(B&lt;&lt;&lt;24)\\;\\in\\;Z_{2}^{32}$ ​ ​ Key Generation​ SM4 的秘钥扩展算法和 encryption 的过程大致相同。 ​ 设 $MK$ 为加密秘钥。 ​ 输入： $MK\\;=\\;(MK_0,MK_1,MK_2,MK_3)\\;\\in\\;(Z_{2}^{32})^4$ 输出： $rk_i\\;=\\;K_{i+4}\\;=\\;K_i\\oplus T’(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i),\\;i=0,1,…,31$ ​ 其中， $K_0,K_1,K_2,K_3\\;=\\;(MK_0\\oplus FK_0,MK_1\\oplus FK_1,MK_2\\oplus FK_2,MK_3\\oplus FK_3)$ ​ $T’$ 是将合成置换 $T$ 的线性变换 $L$ 替换为 $L’$ : $L’(B)\\;=\\;B\\oplus(B&lt;&lt;&lt;13)\\oplus(B&lt;&lt;&lt;23)$ ​ 系统参数 $FK$ 的取值为： ​ $FK_i$ Value 0 0xA3B1BAC6 1 0x56AA3350 2 0x677D9197 3 0xB27022DC ​ 固定参数 $CK_i$ 的取值方法为： ​ ​ ​ Realisation​ 自己实现一波，发现还是挺简单的。 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#! /usr/bin/python3.7# -*- coding: utf-8 -*-# Module request: Util(self)# Author: w366er\"\"\"Descrition:1. Implement of normal SM4 algorithm2. Reference: https://raw.githubusercontent.com/fengkx/sm4/master/SM4.pdf \"\"\"class new: def __init__(self,key): self.key_box = [] self.SBOX = [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48 ] self.CK = [ 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 ] self.FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC] self.BLOCK_SIZE = 32 self.gen_key(key) def non_linear_transpose(self,A): # check pass B = 0 for i in range(4): A_ = A &amp; 0xff B += (self.SBOX[((A_&amp;0xf0) &gt;&gt; 4) * 16 + (A_&amp;0x0f)] &lt;&lt; (i * 8)) A &gt;&gt;= 8 return B def lls(self,x,sign): # check pass hb = x &gt;&gt; (self.BLOCK_SIZE - sign) return (x &lt;&lt; sign) &amp; 0xffffffff | hb def linear_transpose(self,B): # check pass return B ^ self.lls(B,2) ^ self.lls(B,10) ^ self.lls(B,18) ^ self.lls(B,24) def linear_transpose_key(self,B): # check pass return B ^ self.lls(B,13) ^ self.lls(B,23) def Block2Int(self,B): # check pass return sum([B[i] &lt;&lt; ((3 - i) * self.BLOCK_SIZE) for i in range(4)]) def Int2Block(self,I): # check pass return [I &gt;&gt; (self.BLOCK_SIZE*3), (I &amp; 0xffffffff0000000000000000) &gt;&gt; (self.BLOCK_SIZE*2), (I &amp; 0xffffffff00000000) &gt;&gt; self.BLOCK_SIZE, I &amp; 0xffffffff] def gen_key(self,key): # check pass MK = self.Int2Block(key) K = [MK[i] ^ self.FK[i] for i in range(4)] for i in range(32): next_K = K[1] ^ K[2] ^ K[3] ^ self.CK[i] next_K = K[0] ^ self.linear_transpose_key(self.non_linear_transpose(next_K)) self.key_box.append(next_K) K = [K[1], K[2], K[3], next_K] def F(self,X_0,X_1,X_2,X_3,rk): # check pass return X_0 ^ self.linear_transpose(self.non_linear_transpose(X_1^X_2^X_3^rk)) def encrypt(self,plaintext): # check pass \"\"\" Encryption for SM4 :param plaintext: plaintext --&gt; int :return cipher: cipher --&gt; int \"\"\" X = self.Int2Block(plaintext) for i in range(32): next_X = self.F(X[0],X[1],X[2],X[3],self.key_box[i]) X = [X[1],X[2],X[3],next_X] X = X[::-1] # reverse transpose return self.Block2Int(X) def decrypt(self,cipher): # check pass \"\"\" Decryption for SM4 :cipher: cipher text --&gt; int :return: plaintext --&gt; int \"\"\" X = self.Int2Block(cipher) for i in range(31,-1,-1): next_X = self.F(X[0],X[1],X[2],X[3],self.key_box[i]) X = [X[1],X[2],X[3],next_X] X = X[::-1] # reverse transpose return self.Block2Int(X) # test# plaintext: 0x0123456789ABCDEFFEDCBA9876543210# cipher: 0x681edf34d206965e86b3e94f536e4246 ​ Analysis​ 证明加密与解密的对称性。先从特殊性开始： ​ 令 $i\\;=\\;35$，加密过程中有： ​ $X_{35}\\;=\\;F(X_{31},X_{32},X_{33},X_{34},rk_{31})\\;=X_{31}\\oplus T(X_{32}\\oplus X_{33}\\oplus X_{34}\\oplus rk_{31})$， 进一步写成 $X_{35}\\;=\\;X_{31}\\oplus D_{35}$。 ​ 解密过程中，由于密文在最后一轮进行的 reverse，所以有： ​ $X_{31}\\;=\\;F(X_{35},X_{34},X_{33},X_{32},rk_{31})\\;=\\;X_{35}\\oplus T(X_{34}\\oplus X_{33}\\oplus X_{32}\\oplus rk_{31})$ ​ 这里后面的 $T(X_{34}\\oplus X_{33}\\oplus X_{32}\\oplus rk_{31})$ 和 $D_{35}$ 相同，特殊性证明完成。 ​ 再从一般性出发。 ​ 对于加密，有： ​ ​ $X_{i+4}\\;=\\;F(X_i,X_{i+1},X_{i+2},X_{i+3},rk_{i})\\;=\\;X_{i}\\oplus T(X_{i+1},X_{i+2},X_{i+3},rk_{i})$，同样地， 写成： $X_i \\oplus D_{i+4}$，其中 $i\\;=\\;0,1,2,…,31$ ​ 对于解密，有： ​ $X_{i-4}\\;=\\;F(X_i,X_{i-1},X_{i-2},X_{i-3},rk_i)\\;=\\;X_i\\oplus T(X_{i-1},X_{i-2},X_{i-3},rk_{i-4})$， 其中 $i\\;=\\;35,34,…,4$。再写成： $X_{i}\\oplus D_{i}$ ​ 一般性证明完成。 ​ ​ 再证明子秘钥的安全性。 ​ 生成秘钥扩展算法中，有： ​ $rk_i\\;=\\;K_{i+4}\\;=\\;K_i\\oplus T’(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i)$，$i\\;=\\;0,1,…,31$ 需要留意的是， $(K_0,K_1,K_2,K_3)\\;=\\;(MK_0\\oplus FK_0,MK_1\\oplus FK_1,MK_2\\oplus FK_2,MK_3\\oplus FK_3)$ ​ 和加密解密原理相同地，改写成 $K_{i-4}\\;=\\;K_{i}\\oplus T’(K_{i-1},K_{i-2},K_{i-3},CK_{i-4})$， 其中 $i\\;=\\;35,34,…,4$。如果泄露了四个子秘钥，我们完全可以恢复出加密秘钥以及全部子密钥。 相比于 DES，子密钥的安全性高许多。下面尝试一下四个子秘钥恢复出加密密钥： ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#! /usr/bin/python3.7# -*- coding: utf-8 -*-# Module request: # Author: w366er\"\"\"Descrition:1. Implement of normal SM4 algorithm2. References: https://raw.githubusercontent.com/fengkx/sm4/master/SM4.pdf \"\"\"class new: def __init__(self,key): self.key_box = [] self.SBOX = [ 0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84, 0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48 ] self.CK = [ 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 ] self.FK = [0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC] self.BLOCK_SIZE = 32 self.gen_key(key) def non_linear_transpose(self,A): # check pass B = 0 for i in range(4): A_ = A &amp; 0xff B += (self.SBOX[((A_&amp;0xf0) &gt;&gt; 4) * 16 + (A_&amp;0x0f)] &lt;&lt; (i * 8)) A &gt;&gt;= 8 return B def lls(self,x,sign): # check pass hb = x &gt;&gt; (self.BLOCK_SIZE - sign) return (x &lt;&lt; sign) &amp; 0xffffffff | hb def linear_transpose(self,B): # check pass return B ^ self.lls(B,2) ^ self.lls(B,10) ^ self.lls(B,18) ^ self.lls(B,24) def linear_transpose_key(self,B): # check pass return B ^ self.lls(B,13) ^ self.lls(B,23) def Block2Int(self,B): # check pass return sum([B[i] &lt;&lt; ((3 - i) * self.BLOCK_SIZE) for i in range(4)]) def Int2Block(self,I): # check pass return [I &gt;&gt; (self.BLOCK_SIZE*3), (I &amp; 0xffffffff0000000000000000) &gt;&gt; (self.BLOCK_SIZE*2), (I &amp; 0xffffffff00000000) &gt;&gt; self.BLOCK_SIZE, I &amp; 0xffffffff] def gen_key(self,key): # check pass MK = self.Int2Block(key) K = [MK[i] ^ self.FK[i] for i in range(4)] for i in range(32): next_K = K[1] ^ K[2] ^ K[3] ^ self.CK[i] next_K = K[0] ^ self.linear_transpose_key(self.non_linear_transpose(next_K)) self.key_box.append(next_K) K = [K[1], K[2], K[3], next_K] def F(self,X_0,X_1,X_2,X_3,rk): # check pass return X_0 ^ self.linear_transpose(self.non_linear_transpose(X_1^X_2^X_3^rk)) def encrypt(self,plaintext): # check pass X = self.Int2Block(plaintext) for i in range(32): next_X = self.F(X[0],X[1],X[2],X[3],self.key_box[i]) X = [X[1],X[2],X[3],next_X] X = X[::-1] # reverse transpose return self.Block2Int(X) def decrypt(self,cipher): # check pass X = self.Int2Block(cipher) for i in range(31,-1,-1): next_X = self.F(X[0],X[1],X[2],X[3],self.key_box[i]) X = [X[1],X[2],X[3],next_X] X = X[::-1] # reverse transpose return self.Block2Int(X)if __name__ == \"__main__\": print(\"---------- Expected result ----------\") print(0x0123456789ABCDEFFEDCBA9876543210) sm4 = new(0x0123456789ABCDEFFEDCBA9876543210) key = [0,0,0,0,sm4.key_box[0],sm4.key_box[1],sm4.key_box[2],sm4.key_box[3]] for i in range(7,3,-1): t = key[i-1] ^ key[i-2] ^ key[i-3] ^ sm4.CK[i-4] key[i-4] = key[i] ^ sm4.linear_transpose_key(sm4.non_linear_transpose(t)) print(\"---------- My result ----------\") key = key[:4] key = [key[i] ^ sm4.FK[i] for i in range(4)] key = sm4.Block2Int(key) print(key)#---------- Expected result ----------# 1512366075204170947332355369683137040#---------- My result ----------# 1512366075204170947332355369683137040 ​ ​ 子密钥的长度为 32 bits，在知道三个子密钥的情况下，爆破方法在多项式时间也是完全可以恢复出子密钥 的，时间复杂度为： $O(2^{32})$ 。 ​ ReferenceSM4 block cipher algorithm ​ ​ 坚持！ ​","categories":[],"tags":[{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"}]},{"title":"differential attack learning","slug":"differential-attack-learning","date":"2020-09-10T12:48:14.000Z","updated":"2020-09-11T14:23:56.199Z","comments":true,"path":"2020/09/10/differential-attack-learning/","link":"","permalink":"https://buki-freak.github.io/2020/09/10/differential-attack-learning/","excerpt":"","text":"学习一下差分攻击，最近比赛出现得有点多。 ​ 原理剖析先花个 30 分钟看个视频，看一下差分攻击到底是个啥。英语有点撇脚，勉强听一下。 顺便记录一下 non-generic attack 的分类： ​ linear attack differential attack slide-channel attack related key attack &nbsp; &nbsp; 借个图，虽然有点糊。差分攻击基于选择明文攻击，并且前提是 $\\alpha\\;-\\;\\beta$ 具有 high-probability。解释一下，$\\alpha$ 是一对 明文，或者进入 F function 前中间值的异或值（差值），$\\beta$ 是经过 $r-1$ round F Function 之后的对应的密文对的异或 值。​​ 对于 $\\alpha$， \\alpha\\;=\\;x_1\\;\\oplus\\;x_2​ 对于 $\\beta$， y_1\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_1)\\\\ y_2\\;=\\;F_{r}^{-1}(K_r^{i},\\;C_2)\\\\ \\beta\\;=\\;y_1\\;\\;\\oplus\\;y_2​ ​ 那么 $\\alpha$，$\\beta$ 怎么用呢？我们先假设 $\\alpha$ 和 $\\beta$ 是确定的并具有 high-probability，那么对于一个 n bits 的 key，对于所有可能 的值，我们建立一个表： ​ Potential r-th round Key K0 K1 … Ki Kn-2 Kn-1 Kn Count 0 0 0 0 0 0 0 ​ ​ 对于所有差值为 $\\alpha$ 的明文对，我们用 $K_i$ 计算对应的 $\\beta’$。对于每一个 $K_i$ ，如果产生的差值为 $\\beta$ ，那么 count 自增。最 后 count 为 maximum 的 potential r-th round key 很可能为 real key。 ​ 那么如何找出最佳的 $\\alpha$，$\\beta$ 呢？这里先抛开 potential r-th key，对于每一个可能的 $\\alpha$，$\\beta$，建立一个表格（假设这里取值范围为 0x04）: ​ B/A 0x01 0x02 0x03 0x04 0x01 0 0 0 0 0x02 0 0 0 0 0x03 0 0 0 0 0x04 0 0 0 0 ​ 设 $\\alpha$ 的值为 $\\alpha_i$，对应表格上的每一列，对所有差值为 $\\alpha_i$ 的明文对，计算其 $\\beta$ 值并且在表格上记录出现频率，频率最高的 $\\alpha-\\beta$ 为最佳 characteristic。 ​ ​ 看懂原理之后，跟着 soreatu 大佬复现一波题目。 ​ ​ WMCTF- idiot box​ ​ 题目给出的远程文件。 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import itertoolsfrom binascii import hexlify, unhexlifyimport Crypto.Random.random as randomfrom Crypto.Util.number import bytes_to_long, long_to_bytes, getRandomNBitIntegerfrom secret import flagbanner = '''__ __ _ _ __ ____ __ ____ _____ _____\\ \\ / /__| | ___ ___ _ __ ___ ___ | |_ ___ \\ \\ / / \\/ |/ ___|_ _| ___| \\ \\ /\\ / / _ \\ |/ __/ _ \\| '_ ` _ \\ / _ \\ | __/ _ \\ \\ \\ /\\ / /| |\\/| | | | | | | \\ V V / __/ | (_| (_) | | | | | | __/ | || (_) | \\ V V / | | | | |___ | | | _| \\_/\\_/ \\___|_|\\___\\___/|_| |_| |_|\\___| \\__\\___/ \\_/\\_/ |_| |_|\\____| |_| |_|'''sbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30, 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]keys = []pc_key = [2, 13, 16, 37, 34, 32, 21, 29, 15, 25, 44, 42, 18, 35, 5, 38, 39, 12, 30, 11, 7, 20, 17, 22, 14, 10, 26, 1, 33, 46, 45, 6, 40, 41, 43, 24, 9, 47, 4, 0, 19, 28, 27, 3, 31, 36, 8, 23]def gen_key(): global keys key = getRandomNBitInteger(49) &amp; ((1 &lt;&lt; 48) - 1) key_bin = bin(key)[2:].rjust(48, '0') for i in range(6): key_bin = ''.join([key_bin[pc_key[j]] for j in range(48)]) sub_key = int(key_bin, 2) keys.append(sub_key)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 print(y_bin) return int(y_bin, 2)def F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef enc_block(x): x_bin = bin(x)[2:].rjust(64, '0') l, r = int(x_bin[:32], 2), int(x_bin[32:], 2) for i in range(6): l, r = r, l ^ F(r, keys[i]) y = (l + (r &lt;&lt; 32)) &amp; ((1 &lt;&lt; 64) - 1) return ydef enc(pt): pad_len = (8 - len(pt) % 8) % 8 pt = pt.encode() pt += b'\\x00' * pad_len ct = b'' for i in range(0, len(pt), 8): ct_block = long_to_bytes(enc_block(bytes_to_long(pt[i:i+8]))).rjust(8, b'\\x00') ct += ct_block return ctif __name__ == '__main__': print(banner) gen_key() print(keys) cipher = hexlify(enc(flag)).decode('utf8') print('[++++++++++++++++] FLAG [++++++++++++++++]') print(cipher) print('[+] You have up to 65537 chances to obtain the ct corresponding to the pt your input(&lt;= 64 bits and hex required).') for i in range(65537): pt = input() try: pt = unhexlify(pt) assert(len(pt) &lt;= 8) ct = enc(pt) print(hexlify(ct).decode('utf8')) except: print('[*] Read the above carefully!') break ​ ​ 分析源码，题目给出了是一个自己实现的 DES，测试一下 F Function 的 characteristic： ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from collections import Counterfrom Crypto.Util.number import getRandomNBitIntegersbox = [[11, 10, 1, 3, 8, 3, 14, 13, 0, 3, 9, 2, 4, 2, 11, 4, 6, 1, 6, 13, 6, 7, 7, 0, 10, 5, 4, 5, 9, 5, 10, 10, 6, 7, 15, 4, 7, 9, 15, 12, 1, 15, 14, 11, 14, 13, 1, 13, 8, 8, 9, 2, 12, 2, 0, 12, 8, 3, 0, 15, 11, 12, 5, 14], [0, 15, 2, 8, 3, 8, 12, 12, 9, 10, 14, 13, 4, 13, 14, 14, 2, 1, 15, 1, 1, 7, 3, 1, 10, 15, 6, 4, 6, 8, 5, 15, 4, 5, 7, 11, 7, 2, 5, 9, 11, 7, 11, 14, 6, 2, 11, 3, 12, 13, 9, 3, 9, 12, 4, 8, 10, 0, 5, 0, 0, 10, 6, 13], [5, 10, 3, 12, 3, 0, 6, 15, 13, 2, 0, 15, 8, 2, 3, 13, 9, 11, 0, 6, 14, 11, 2, 10, 1, 4, 12, 1, 7, 4, 7, 15, 5, 8, 7, 12, 5, 11, 0, 12, 14, 6, 9, 8, 14, 6, 9, 3, 4, 10, 1, 2, 10, 8, 7, 13, 15, 13, 4, 1, 5, 9, 14, 11], [4, 0, 7, 7, 7, 5, 4, 1, 10, 12, 11, 11, 11, 10, 15, 3, 12, 8, 3, 0, 2, 14, 14, 13, 2, 10, 6, 4, 6, 10, 2, 3, 14, 15, 8, 15, 9, 1, 11, 7, 5, 5, 6, 13, 6, 8, 0, 1, 3, 14, 0, 2, 9, 15, 8, 12, 1, 4, 9, 13, 9, 13, 5, 12], [\\ 9, 10, 3, 4, 2, 10, 12, 4, 5, 12, 5, 11, 5, 9, 13, 10, 7, 11, 7, 11, 1, 3, 2, 3, 3, 7, 1, 5, 15, 13, 9, 7, 12, 8, 8, 15, 0, 6, 0, 14, 15, 8, 8, 1, 0, 1, 0, 10, 14, 2, 14, 9, 13, 11, 6, 12, 15, 13, 14, 6, 4, 6, 4, 2], [0, 8, 12, 15, 0, 8, 3, 6, 7, 15, 9, 9, 2, 15, 9, 9, 1, 12, 13, 10, 5, 10, 12, 14, 5, 7, 14, 6, 4, 7, 5, 2, 1, 6, 4, 12, 0, 1, 14, 4, 3, 13, 11, 7, 3, 6, 11, 10, 1, 14, 2, 13, 13, 8, 15, 11, 11, 0, 5, 10, 2, 4, 8, 3], [9, 15, 3, 1, 15, 1, 7, 15, 10, 4, 0, 1, 0, 0, 3, 6, 9, 10, 12, 3, 3, 1, 12, 7, 8, 5, 2, 14, 2, 9, 2, 14, 6, 12, 13, 10, 11, 13, 9, 8, 6, 8, 5, 4, 11, 8, 14, 4, 12, 7, 13, 2, 10, 7, 13, 14, 6, 5, 5, 11, 4, 0, 15, 11], [13, 3, 1, 7, 1, 12, 10, 3, 14, 12, 14, 7, 10, 15, 5, 0, 2, 4, 13, 4, 13, 0, 8, 9, 11, 9, 10, 15, 3, 9, 12, 9, 11, 2, 8, 6, 10, 14, 11, 6, 2, 0, 6, 15, 12, 15, 6, 14, 7, 4, 13, 11, 0, 4, 7, 3, 2, 5, 1, 1, 5, 8, 8, 5]]pbox = [19, 14, 15, 3, 10, 25, 26, 20, 23, 24, 7, 2, 18, 6, 30,\\ 29, 1, 4, 9, 8, 27, 5, 13, 0, 21, 16, 17, 22, 12, 31, 11, 28]def e(x): x_bin = bin(x)[2:].rjust(32, '0') y_bin = '' idx = -1 for i in range(8): for j in range(idx, idx + 6): y_bin += x_bin[j % 32] idx += 4 # print(y_bin) return int(y_bin, 2)def s(x, i): row = ((x &amp; 0b100000) &gt;&gt; 4) + (x &amp; 1) col = (x &amp; 0b011110) &gt;&gt; 1 return sbox[i][(row &lt;&lt; 4) + col]def p(x): x_bin = [int(_) for _ in bin(x)[2:].rjust(32, '0')] y_bin = [x_bin[pbox[i]] for i in range(32)] y = int(''.join([str(_) for _ in y_bin]), 2) return ydef F(x, k): x_in = bin(e(x) ^ k)[2:].rjust(48, '0') y_out = '' for i in range(0, 48, 6): x_in_i = int(x_in[i:i+6], 2) y_out += bin(s(x_in_i, i // 6))[2:].rjust(4, '0') y_out = int(y_out, 2) y = p(y_out) return ydef gen_diff_output(diff): p1 = getRandomNBitInteger(32) p2 = p1 ^ diff key = getRandomNBitInteger(48) c1, c2 = F(p1, key), F(p2, key) return c1^c2, (p1,p2,c1,c2)counter = Counter()for i in range(10000): P_ = 0x00002002 # \\alpha X_, _ = gen_diff_output(P_) counter[X_] += 1X_, freq = counter.most_common(1)[0]print(hex(X_)[2:].rjust(8,'0'), freq / 10000.0) # \\beta, probability# [0x00000000 0x00000000 1.0] # 0 is assure to be output 0# [0x00000002 0x00030005 0.2163]# [0x00000040 0x00000000 0.2554] # seems to be the best# [0x00002000 0x00000000 0.2492]# [0x00002002 0x00030005 0.052] ​ ​ $\\alpha\\;=\\;0x00000040$，$\\beta\\;=\\;0x00000000$ 的 high-probability 比较明显，取一下数据。借了下师傅的代码，Counter 包真好用 😳。 ​ ​ ​ 再抄一幅图，嘿嘿~ 这里我刚开始进入了一个误区，如果遍历所有 potential key 的话，复杂度必大于 $O(2^{48})$，但是如果将 48-bits 的 potential key 分成 8 个 6-bits 的 S-boxes，复杂度可以降到 $10000*O(2^{6+3})$，大概是 $O(2^{22})$，完全没有毛病。 ​ 再贴一个 F Function 的 schedule： ​ ​ ​ DES 的 F Function 流程如下： ​ Expansion D-box : E( ) function XOR - key S-boxes : S( ) function Straight D-box : D( ) function ​ 大概就是一个两边从中间靠的过程，写出来就是 : ​ S(E(T\\_R{'})\\;\\oplus\\;K_i)\\;=\\;D^{-1}(F')\\;=\\;D^{-1}(T\\_L'\\;\\oplus\\;0x00000040)​ 自己写的 exp 就不贴出来了，仔细看了一下大佬的，tql！ ​ References:Breaking DES using Differential Cryptanalysis Case Study: Differetial Cryptanalysis Attack Differential Cryptanalysis ​ 特别致谢： soreatu 大佬","categories":[],"tags":[]},{"title":"强网杯-2020-Review","slug":"强网杯-2020-Review","date":"2020-09-09T00:52:19.000Z","updated":"2020-09-09T01:34:48.306Z","comments":true,"path":"2020/09/09/强网杯-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/09/强网杯-2020-Review/","excerpt":"","text":"baby_crt&nbsp;Infective CRT-RSA，看一下大概的加密流程：&nbsp;&nbsp;&nbsp;在看一下部分参数的设置要求：&nbsp;$N, p, q, e, d$ 常规 RSA 生成。&nbsp;&nbsp;&nbsp;&nbsp;选择两个足够大的素数 $t1, t2$，bit_length 在 $60~80$。题目给出的 $t1, t2$ 过小，存在问题。&nbsp;有几个参数上面没写，补充： d_p\\equiv\\;d\\mod\\;\\varphi(p\\;·\\;t_1)\\\\ d_q\\equiv\\;d\\mod\\;\\varphi(q\\;·\\;t_2)\\\\ d\\;·\\;e_{t_1}\\mod\\;\\varphi(t_1)\\\\ d\\;·\\;e_{t_2}\\mod\\;\\varphi(t_2)&nbsp;&nbsp;继续往下看，看到一点东西了:&nbsp;&nbsp;&nbsp;&nbsp;这里 $c1$ 范围为: 1~2^{16}&nbsp;就这，就这？&nbsp;exp: 123456789101112131415161718import gmpy2e = 65537n = 26318358382258215770827770763384603359524444566146134039272065206657135513496897321983920652242182112479484135343436206815722605756557098241887233837248519031879444740922789351356138322947108346833956405647578838873425658405513192437479359531790697924285889505666769580176431360506227506064132034621123828090480606055877425480739950809109048177976884825589023444901953529913585288143291544181183810227553891973915960951526154469344587083295640034876874318610991153058462811369615555470571469517472865469502025030548451296909857667669963720366290084062470583318590585472209798523021029182199921435625983186101089395997m = 26275493320706026144196966398886196833815170413807705805287763413013100962831703774640332765503838087434904835657988276064660304427802961609185997964665440867416900711128517859267504657627160598700248689738045243142111489179673375819308779535247214660694211698799461044354352200950309392321861021920968200334344131893259850468214901266208090469265809729514249143938043521579678234754670097056281556861805568096657415974805578299196440362791907408888958917063668867208257370099324084840742435785960681801625180611324948953657666742195051492610613830629731633827861546693629268844700581558851830936504144170791124745540p,q = 0,0sig = 20152941369122888414130075002845764046912727471716839854671280255845798928738103824595339885345405419943354215456598381228519131902698373225795339649300359363119754605698321052334731477127433796964107633109608706030111197156701607379086766944096066649323367976786383015106681896479446835419143225832320978530554399851074180762308322092339721839566642144908864530466017614731679525392259796511789624080228587080621454084957169193343724515867468178242402356741884890739873250658960438450287159439457730127074563991513030091456771906853781028159857466498315359846665211412644316716082898396009119848634426989676119219246sig_e = pow(sig,e,n)# print(sig_e,n) check passfor i in range(65537): # print(i) # check pass p = gmpy2.gcd(pow(m,i,n) - sig_e,n) if p != 1: print(p) breakq = n // pprint(q)# flag&#123;601cb6f6d990ed5b89cf0de60508a95c07543793&#125; modestudy&nbsp;给的 file 啥玩意儿，环境关了555，以后一定不鸽比赛！","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"gactf-2020-Review","slug":"gactf-2020-Review","date":"2020-09-06T12:09:10.000Z","updated":"2020-09-08T08:24:54.505Z","comments":true,"path":"2020/09/06/gactf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/09/06/gactf-2020-Review/","excerpt":"","text":"比赛期间打工，所以没怎么看题，回顾一下。&nbsp; da vinci after rsayafu 分解 n 可以得到三个质数，计算 $\\varphi$ 发现 $e | \\varphi$，于是化简：&nbsp;$ e’\\;\\;=\\;\\;e\\;//\\;gcd(e,\\varphi(n))\\;=\\;5\\;,\\;d’\\;=\\;invert(e’,\\varphi(n)) $，得到：$c^{d’}\\;\\equiv\\;m^5\\mod\\;n$ 。&nbsp;看大佬的博客可以用 AMM，自己实现了一遍发现只能求一个根，直接上 sage。&nbsp;&nbsp;1234567891011121314151617181920212223from Crypto.Util.number import long_to_bytesimport itertoolsc = 421363015174981309103786520626603807427915973516427836319727073378790974986429057810159449046489151pa = 9749pb = 11237753507624591pc = 9127680453986244150392840833873266696712898279308227257525736684312919750469261# factor with yafumas = GF(pa)(c).nth_root(5, all=True) # find 5-th root in modulus pa, so do belowmbs = GF(pb)(c).nth_root(5, all=True)mcs = GF(pc)(c).nth_root(5, all=True)# algl = True, which means find all roots, otherwise...# all = False is default# find all possible mms = [] for ma, mb, mc in itertools.product(mas, mbs, mcs): m = ZZ(crt(list(map(ZZ,[ma,mb,mc])), [pa,pb,pc])) mi = long_to_bytes(m) if mi[:4] == b'flag': flag = mi[5:-1]# b'weadfa9987_adwd23123_454f' &nbsp;&nbsp;后面是一个斐波那契数列，秘钥是一段乱序的斐波那契数列，加密解密的过程是秘钥和原斐波那契数列的映射关系。这里是把 flag 按照 encryption 中的 key 再加密一遍。&nbsp;&nbsp;123456789101112# decrypt da vinci encryptionfb = [1,1]LEN = len(flag)while len(fb) &lt; LEN: fb.append(fb[-1] + fb[-2])fb[0] = 0enc = [0,28657,2,1,3,17711,5,8,13,21,46368,75025,34,55,89,610,377,144,233,1597,2584,4181,6765,10946,987]r_flag = [flag[fb.index(enc[i])] for i in range(LEN)]for i in r_flag: print(chr(i),end='') # w5aed4fa994f87_dwad3123_2 &nbsp;&nbsp;&nbsp; what_r_the_noise&nbsp;求平均值。。。&nbsp; elgamal_rsa&nbsp;&nbsp;yafu 分解 secret，得到一堆数。。。最高幂的素数为：$653551912583^{15}$ 。&nbsp;ws 分析一波，flag 的长度：$2^{36*8} $ 比最高幂的素数要小，舒服，跟上题一样，走 AMM，但还是要求多个根，学一手。&nbsp;取最高幂的素数为 $n$，$e’\\;=\\;e\\;//\\;gcd(e,\\;\\varphi(n))\\;=\\;2379$ ，$d’\\;=\\;invert(e’,\\;\\varphi(n))$ ，$c’\\;\\equiv\\;c^{d’}\\;\\equiv\\;m^{gcd(e,\\;\\varphi(n))}\\mod\\;n$&nbsp;借了一部分 tb师傅的exp&nbsp;师傅 tql！&nbsp;exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from gmpy2 import gcd, invertfrom Crypto.Util.number import *import randome = 0x1296c = 255310806360822158306697936064463902328816816156848194779397173946813224291656351345682266227949792774097276485816149202739762582969208376195999403112665514848825884325279574067341653685838880693150001066940379902609411551128810484902428845412055387955258568610350610226605230048821754213270699317153844590496606931431733319116866235538921198147193538906156906954406577796507390570080177313707462469835954564824944706687157852157673146976402325057144745208116022973614795377968986322754779469798013426261911408914756488145211933799442123449261969392169406969410065018032795960230701484816708147958190769470879211953704222809883281592308316942052671516609231501663363123562942# factor through yafufac = [(42044128297, 6), (232087313537, 5), (653551912583, 15), (802576647765917, 7), (28079229001363, 14), (104280142799213, 6)]def AMM(q, r, delta, k=1): \"\"\" Adleman-Manders-Miller r-th Root Extraction Algorithm in F_q * Attention: - r and q satisfy r | q - 1 :param q: modulus q --&gt; int :param r: exponent r --&gt; int :param delta: remain --&gt; int :param k: the exponent of k, default is 1 --&gt; int :return: a r-th root of delta \"\"\" phi = pow(q, k-1)*(q-1) mod = pow(q, k) while True: # step1 &amp; step2 rho = random.getrandbits(mod.nbits()) % mod if pow(rho, phi//r, mod) == 1: break # step 3 s = phi t = 0 while s % r == 0: s //= r t += 1 assert(gcd(s, r) == 1) # check if s is coprimed with r assert(pow(r, t) * s == phi) alpha = invert(r, s) a, b, c, h = pow(rho, phi//r, mod), pow(delta, r * alpha-1, mod), pow(rho, s, mod), 1 # step 4 j, k = 0, phi // (r * s) for i in range(1, t): k //= r d = pow(b, k, mod) if d == 1: j = 0 else: j = - discrete_log(phi, d, a) b, h, c = b*(pow(c, r*j, mod)) % mod, h * \\ pow(c, j, mod) % mod, pow(c, r, mod) # step 5 return pow(delta, alpha, mod) * h % moddef allroot(root, r, q, k = 1): # find all roots phi = (q - 1) * q**(k - 1) mod = q ** k all_root = set() all_root.add(root) while len(all_root) &lt; r: new_root = root unity = pow(getRandomRange(2, mod), phi // r, mod) for i in range(r - 1): new_root = (new_root * unity) % mod all_root.add(new_root) return all_root# since 653551912583**15 &gt; 2**(36*8)n0 = 653551912583n = pow(653551912583, 15)phi = n * (653551912583 - 1) // 653551912583e_p = e // gcd(e, phi)d = invert(e_p, phi)c_p = pow(c, d, n)ar = allroot(AMM(n0,2,c_p,15),2,n0,15)for i in ar: print(long_to_bytes(i))# b'you_4re_good_at_b0th_el94mal_and_rs4' &nbsp;不用 AMM 的话，直接上 sage 也可。&nbsp;&nbsp; square&nbsp;平方数求和公式化简成：$6x^{2}\\;=\\;(y\\;+\\;1)(2y\\;+\\;1)$，然后再转换成 pell 方程: $(4y\\;+\\;3)^2\\; -\\; 48x^{2} \\;=\\; 1$。&nbsp;&nbsp;再令 $t\\;=\\;4y\\;+\\;3$，有：$t^2\\;-\\;48x^{2}\\;=\\;1$。爆破走出前四位：$1,\\;7,\\;97,\\;1351$，然后在 oeis 找到递归式: a(m) = 14a(m-1) - a(m-2)&nbsp;找到所有满足 $t,\\;y$ 的pell 方程的解，然后再根据 $t,\\;x$ 的关系求出 $x,\\;y$，oeis 是个好东西。&nbsp;exp 如下：&nbsp;12345678910111213141516171819202122232425262728293031323334353637383940414243444546# We can get something like pell equation: (4*y+3)^2 - 48*x^2 == 1# Write it into t^2 - 48*x^2 == 1\"\"\"for i in range(10000): for j in range(10000): if i ** 2 - 48 * j ** 2 == 1: print(i,j)Output:1 07 197 141351 195Formula: a(m) = 14a(m-1) - a(m-2)\"\"\"import gmpy2a = [1,7,97,1351]x = [1,7,97,1351]y = [0,1,14,195]while len(x) &lt; 120: ta = 14 * a[-1] - a[-2] a.append(ta) if ta % 4 == 3: x.append(ta)for i in range(4,len(x)): y.append(gmpy2.iroot((x[i]**2-1) // 48,2)[0])for i in range(4,120): x[i] = (x[i] - 3) // 4x = x[4:]y = y[4:]for i,j in zip(x,y): print(i,j)# check passfor i,j in zip(x,y): assert((4*i+3)**2 - 48*j**2 == 1) &nbsp;坚持！","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"CISCN2020-初赛-Writeup","slug":"CISCN2020-初赛-Writeup","date":"2020-08-24T07:00:22.000Z","updated":"2020-09-08T12:57:19.202Z","comments":true,"path":"2020/08/24/CISCN2020-初赛-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/08/24/CISCN2020-初赛-Writeup/","excerpt":"","text":"这次比赛难度算是中等，神仙题和简单题参半。。。&nbsp;&nbsp; bd签到题，老 wiener 了，计算 d 的上界大概为 256 bits，题目给的 d 为 200 bits，直接上脚本：&nbsp;&nbsp;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: utf-8 -*-from gmpy2 import *from Crypto.Util.number import long_to_bytesdef continuedfra(x, y): cF = [] while y: cF += [x / y] x, y = y, x % y return cFdef simplify(ctnf): numerator = 0 denominator = 1 for x in ctnf[::-1]: numerator, denominator = denominator, x * denominator + numerator return (numerator, denominator)def calculatefrac(x, y): cF = continuedfra(x, y) cF = map(simplify, (cF[0:i] for i in range(1, len(cF)))) return cFdef solve_pq(a, b, c): par = isqrt(b * b - 4 * a * c) return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerattack(e, n): for (d, k) in calculatefrac(e, n): if k == 0: continue if (e * d - 1) % k != 0: continue phi = (e * d - 1) / k p, q = solve_pq(1, n - phi + 1, n) if p * q == n: return abs(int(p)), abs(int(q)) print('not find!')n = 86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289e = 46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249c = 37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066p, q = wienerattack(e, n)d = invert(e, (p-1)*(q-1))m = pow(c,d,n)print(long_to_bytes(m))#flag&#123;d3752538-90d0-c373-cfef-9247d3e16848&#125; &nbsp;&nbsp;&nbsp; lfsr&nbsp;&nbsp;state 以及 keystream 给出 10000 bits，flag 为 mask。&nbsp;尝试分析不同 cipher 和 output bits 的关系，构建关于 mask GF(2) 下的方程，未果。&nbsp;在网上找到一个类似的题目，是 SJTU-CTF-2019的一道: 题目 :&nbsp;这题只是原题的其中一步。有一个 Berlekamp-Massey Algorithm 算法，用于构造一个最短的 LFSR 以满足给定的二进制输出序列。于是使用给出的 10000 bits中的前 200 bits。Berlekamp-Massey Algorithm ，这玩意儿有现成的在线工具 。 算出最短的 mask，然后去掉首一，转为十进制，正是 flag。&nbsp;&nbsp;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960In [15]: s= s[1:] In [16]: s Out[16]: ['99', '97', '95', '94', '91', '90', '89', '86', '84', '82', '76', '75', '74', '73', '66', '64', '62', '61', '60', '59', '58', '57', '56', '55', '52', '51', '46', '44', '43', '40', '38', '36', '32', '30', '29', '27', '26', '23', '22', '19', '18', '17', '15', '14', '13', '11', '5', '4']In [34]: res Out[34]: '1010110011100101010000011110000001010111111110011000010110010101000101101100110011101110100000110000'In [35]: int(res,2) Out[35]: 856137228707110492246853478448#flag&#123;856137228707110492246853478448&#125; &nbsp;由于当时急急忙忙先把题目做出来了。。现在学习一下原理。&nbsp;&nbsp;&nbsp;Berlekamp-Massy Algorithm 可以根据给出的 keystream， 找出能生成这个keystream 的最短 LFSR/Tap。理论上给出的 keystream 远大于 tap 的长度时，准确度极高。&nbsp;这个算法也可以在任意的 field 中找到线性递归序列的最小多项式。&nbsp;&nbsp;看一下 wiki 的描述：&nbsp;&nbsp;&nbsp;$S_n$ 在这里是 LFSR 的 keystream，$C_n$ 则是 LFSR 的 tap。整条式子的意思是，假设 tap 的长度为 $L$，那么第 $L+1$ 个值与前 $L$ 位产生的 output 的异或值为0。而算法的目的是找到这个长度为 $L$ 的 $C_n$。&nbsp;&nbsp;我们着重看一下 binary field/GF(2) 的基本运算。&nbsp;&nbsp;&nbsp;先回顾一下二进制运算。GF(2) 中 运算 操作 加法/减法 异或 乘法 逻辑与 除法 单位元运算/定义为’x/1=x’ &nbsp;&nbsp;详细看一下算法步骤：&nbsp;&nbsp;有点懵逼啊。。。先留个坑&nbsp; rsa&nbsp;神仙题，听说 32 核几秒 factor success？？？自己尝试了一下发现不太行。。。tcl 等一手 wp&nbsp;&nbsp; Reference&nbsp; https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm&nbsp;&nbsp;","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"RSA-Learning","slug":"RSA-Learning","date":"2020-08-03T13:22:37.000Z","updated":"2020-08-07T09:18:40.543Z","comments":true,"path":"2020/08/03/RSA-Learning/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/RSA-Learning/","excerpt":"","text":"今天看了一篇 RSA 的paper，总结的不错，简单地做下笔记。 RSA 是基于 Factoring Large Integers Problem 的公钥密码体制。 Elementary AttacksCommon Modulus…. Blinding出现在不经 padding 和 check 的 RSA signiture 中，如果签名方不仔细审查明文，攻击者可以伪造某人对于任何内容的签名。 cheat 大致过程如下： 整个过程称为 blinding，是因为 Bob 没能得知他要签名的内容。签名方在签名前检查内容能够防止这个问题。 Low Private Exponent低解密指数攻击。 d 的大小会影响解密的时长。为了速度上的要求，有人会将 d 设置的更小。M.Wiener 提出的攻击方法对很小的 d 的 RSA 系统带来威胁。 Theorem 2(M. Wiener): Proof:证明过程利用连分数。因为 $ed\\;\\equiv\\;1\\mod\\;\\varphi(N)$，所以存在一个 k 满足: $ed\\;-\\;k\\varphi(N)\\;=\\;1$， 因此有： \\left|\\frac{e}{\\varphi(N)}\\;-\\;\\frac{k}{d}\\right|\\;=\\;\\frac{1}{d\\varphi(N)}所以可以把 $\\frac{k}{d}$ 看成是 $\\frac{e}{\\varphi(N)}$ 的大概值。然后因为 $\\varphi(N)\\;=\\;N\\;-\\;p\\;-\\;q\\;+\\;1$ 以及 $p\\;+\\;q\\;-\\;1\\;&lt;\\;3\\sqrt{N}$ 所以有： 计算 $\\frac{e}{N}$ 的连分数，其中有一个解等于 $\\frac{k}{d}$，由于 $ed\\;-\\;k\\varphi(N)\\;=\\;1$，所以 $gcd(k, d)\\;=\\;1$ ，即 $\\frac{k}{d}$ 为真分数。线性时间可以解得 d。 LimitsLarge e:对解密指数进行改进，令 $e’\\;=\\;e\\;+\\;t\\varphi(N), t\\;is\\;large\\;enough$，$e’$ 作为新的加密指数: Using CRT保证 d 的 bit size 的同时，使用 CRT 对解密来提升解密速度。计算： d_p\\;\\equiv\\;d\\;\\mod(p\\;-\\;1)\\\\ d_q\\;\\equiv\\;d\\;\\mod(q\\;-\\;1)并且 $d_q$ 和 $d_p$ 足够小(128 bits each)。然后计算： M_p\\;\\equiv\\;C^{d_p}\\mod\\;p\\\\ M_q\\;\\equiv\\;C^{d_q}\\mod\\;q最后 CRT： \\begin{cases} M\\;\\equiv\\;C^{d_p}\\mod\\;p \\\\\\\\ M\\;\\equiv\\;C^{d_q}\\mod\\;q \\end{cases}$d_p$ 和 $d_q$ 过小会导致 N 容易分解。 Boneh and Durfee 方法可以将上界提到 $d &lt; N^{0.292}$ Low Public Exponent数字签名中，e 的大小会影响验证的计算时长。e 过小会导致低加密指数攻击。 Coppersmith’s TheoremTheorem 3(Coppersmith) Coppersmith 提供了一个快速寻找 $f(x_0)\\;\\equiv\\;0\\;\\mod\\;N$ 根的方法。 Lemma 4 Proof由 Schwarz inequality 可得： \\left|h(x_0)\\right|\\;=\\;\\left|\\sum{a_i}x_{0}^{i}\\right|\\;=\\;\\left|\\sum{a_i}X^{i}(\\frac{x_0}{X})^{i}\\right|\\;\\leq\\;\\sum\\left|a_{i}X^{i}(\\frac{x_0}{X})^i\\right|\\\\ \\leq\\;\\sum\\left|a_{i}X^{i}\\right|\\;\\leq\\;\\sqrt{d}||h(xX)||\\;\\leq\\;N由于 $h(x_0)\\;\\equiv\\;0\\;\\mod\\;N$，所以有 $h(x_0)\\;=\\;0$ 。前提是 h 的范数足够小。 因此，我们需要找到另外一个范数更小的多项式。满足上面的条件。 Coppersmith 提供了一个方法： m 是未知的常量。我们从 $g_{u,v}(x)\\;\\equiv\\;0\\;\\mod\\;N^m$ 中找到符合 $norm(h(xX))\\;&lt;\\;N^m$ 的多项式。m 足够大的时候有多个解。 找到这个合适的多项式需要构造格： Hermite’s bound 说明 $m$ 足够大的时候，可以找到 $ norn(v) &lt; N^m$ 的向量。 Fact 5(LLL) LLL 满足 Lemma 4 的条件： 2^{\\frac{w}{4}}det(L)^{\\frac{1}{w}}\\;","categories":[],"tags":[{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"}]},{"title":"De1ta-CTF-2020-Review","slug":"De1ta-CTF-2020-Review","date":"2020-08-03T03:40:01.862Z","updated":"2020-08-03T07:05:31.815Z","comments":true,"path":"2020/08/03/De1ta-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. nlfsr(unsolved)This challenge consists of 4 linear feedback shift registers (below I use LFSR instead), with accordingly 19 bits, 19 bits, 6 bits and 3 bits state length. Here is the given file: quiz.py 12345678910111213141516171819202122232425262728from flag import a, b, c, d, flagassert flag == \"De1CTF&#123;\" + ''.join([hex(i)[2:] for i in [a, b, c, d]]) + \"&#125;\"assert [len(bin(i)[2:]) for i in [a, b, c, d]] == [19, 19, 13, 6]ma, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def combine(): global a, b, c, d a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [i &amp; 1 for i in [a, b, c, d]] return (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ dodef genkey(nb): s = '' for i in range(nb*8): s += str(combine()) open(\"data\", \"w+\").write(s)genkey(128*1024) data 1a string that comprises of 128*1024*8 bits(only zero or one) ExplanationThere are four LFSR in quiz.py and each round, four LFSR simultaneously compute four according output. Then the combination function combines these four bits and output the combination result into file data. ConditionSince LFSR is the basic knowledge for us, there will more no more explanation on it. So let’s see what we have got from the files. the initial state length of each LFSR the taps of each LFSR a combination function many rounds combination results It seems to be a simple quiz because we have already known the taps of each LFSR. However, each output of four LFSR is combined as one bit, from which we can hardly retrieve the outputs of four LFSR. If we use pure brute-force attack method, the complexity would be: O(2^{47}) Such a large scale. We must relate one or some output of four LFSR to the combination result and solve the each state independently. We can use a strategies called correlation attack in stream cipher. DetailsWe first look into each possible situation of four LFSR and write down the result. ao bo co do combine 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 0 1 0 0 0 0 1 0 1 0 0 1 1 0 0 0 1 1 1 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 In the table, ao represents the single output of LFSR-1 and so on. It is very obvious that ao has 75% correlation with the combination output, and we also know that if we have the correct initial state of LFSR-1, three out of four output of LFSR-1 will be the same as the combination bits. As a result, we can independently search the initial state of LFSR-1, and the correct initial state should be the fittest one. Now the complexity comes down to: O(2^{19}+2^{28})=O({2^{28}})This is already considerable in brute-force attack method (I use approximately 3 hours with C++, half a day with python to solve). But sadly, outputs of other LFSR just has 50% correlation with the combination output (actually no correlation). We can look into the combination function: 1(ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do And interestingly it can be transformed into: 1(ao*bo) ^ ((bo^1) * (co^do)) Calculating the XOR result of co and do by ourselves, we can surprisingly find that there is correlation between (co^do) and the combination result. Try to write down the table again. ao bo co^do combine 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 Again we can know from the table that (co^do) has 75% correlation with the combination output, which is the same as ao. There the complexity comes down again to: O(2^{19}+2^{9}+2^{19})=O(2^{20})The complexity is very considerable now. RealizationOfficial realization 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# coding:utf8import timema, mb, mc, md = 0x505a1, 0x40f3f, 0x1f02, 0x31key = open(\"data\").read()def lfsr(r, m): return ((r &lt;&lt; 1) &amp; 0xffffff) ^ (bin(r &amp; m).count('1') % 2)def calcR(x, y): assert len(x) == len(y) cnt = 0.0 for i, j in zip(x, y): cnt += (i == j) return cnt / len(x)def brutea(nb): relation, reala = 0, 0 for i in range(0, 2 ** 19): s = '' a = i for j in range(nb * 8): a = lfsr(a, ma) s += str(a &amp; 1) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, reala = r, i print(reala, relation) return realadef brutecd(nb): relation, realc, reald = 0, 0, 0 for i in range(0, 2 ** 6): d = i for j in range(0, 2 ** 13): c = j s = '' for k in range(nb * 8): c = lfsr(c, mc) d = lfsr(d, md) s += str((c &amp; 1) ^ (d &amp; 1)) r = calcR(s, key[:nb * 8]) if relation &lt; r: relation, realc, reald = r, j, i print(realc, reald, relation) return realc, realddef bruteb(nb, a_, c_, d_): for i in range(0, 2 ** 19): b = i a, c, d = a_, c_, d_ s = '' for j in range(nb * 8): a = lfsr(a, ma) b = lfsr(b, mb) c = lfsr(c, mc) d = lfsr(d, md) [ao, bo, co, do] = [k &amp; 1 for k in [a, b, c, d]] s += str((ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do) if s == key[:nb * 8]: print(i) return iif __name__ == \"__main__\": start_time = time.time() print(start_time) a = brutea(20) c, d = brutecd(20) b = bruteb(20, a, c, d) \"De1CTF&#123;%s&#125;\" % (''.join([hex(i)[2:] for i in [a, b, c, d]])) end_time = time.time() print(\"Used time:\", end_time - start_time)# De1CTF&#123;58bb578d5611363f&#125; Other challenges still remain confused. What I have doneI spent half of my afternoon writing this article, and I still have a long way to go. Keep on learning IELTS and number theory. Things to Learn and Improve How to use sage Do a review on wangdibei References https://en.wikipedia.org/wiki/Correlation_attack","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"天翼杯-2020-Writeup","slug":"天翼杯-2020-Writeup","date":"2020-07-31T15:00:19.000Z","updated":"2020-08-24T03:28:24.850Z","comments":true,"path":"2020/07/31/天翼杯-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/07/31/天翼杯-2020-Writeup/","excerpt":"","text":"比赛排得很密，gkd 把 writeup 写了。 easyRSA签到题，对于每一次加密，明文空间小，于是直接遍历。 1234567891011121314n = ...cipher = ...import stringe = 11299plaintext = ''for i in range(len(cipher)): for s in string.printable: if pow(ord(s),e,n) == cipher[i]: plaintext += s print(plaintext) break hardRSA已知 d 低 539 位，q 为 510 位，计算低位 q 的方法可以直接获得 q。 12345678910111213141516171819202122232425262728import gmpy2from Crypto.Util.number import long_to_bytesdef find_q(d0, kbits, e, n, p): X = var('X') for k in range(1, e+1): results = solve_mod([e*d0*X - k*(p-1)*X*(n//p-X+1) + (p-1)*k*(n//p) == X], 2^kbits) for x in results: q0 = ZZ(x[0]) if n % q0 == 0: return q0if __name__ == '__main__': n = 12723332779402711330767180202990021139894727917028981722242076998825097254419567024122271773380821224949951558669351311750240296591612098048129709925844660421849429715755474874708286508736369884566273719494870891070006251521469139401722700298201541140391493575314714966432624976434199682124684035067305114749262672684081617896579640435891181745346695293618235303178334371123418790204709073465264408888007492994820133128499094347122686903153588634296508454120927 e = 7 p = 3141886348112988339174865432179206412942588390228169645162293920470188882447855208783220899752887620221059861467348059334030873350571979462363834615231089 c = 8696771272015513736887843395612361647314297287781507609196936354183211655364744684164300710583625473872942712063309507651496314800393009480421886926137403759228421858414833429980059903049311837014449093365911603108158352871851677457256058510822509157407703210866317472894586087554001158540951787167699161720491198674848526093644131709561995379565643716017359731201935855247285498574923656191121426618306186331615280461405913653781283860760013215603007314688132 d0 = 0x414946b9c40728f9801e61e98ec6d17525cbe4163a5ffb8367b65c652ae4cc3abce62e70afbfb84fcf937b3119953b48922be19ef4312c4f3a88313368ca6c9b1d658b7 nbits = n.nbits() kbits = d0.nbits() q = find_q(d0, kbits, e, n, p) r = n // q // p phi = (r - 1) * (p - 1) * (q - 1) d = gmpy2.invert(e,phi) print(long_to_bytes(pow(c,d,n))) 忽略一下推导过程了。。 AliceHomeworkLLL 没跑出来，疑惑.jpg PolyCrypto没时间看题。。。tcl","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"3kctf-2020-Review","slug":"3kctf-2020-Review","date":"2020-07-27T06:21:11.000Z","updated":"2020-08-03T03:26:54.575Z","comments":true,"path":"2020/07/27/3kctf-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/","excerpt":"","text":"pyzzle1Given a cst tree code, use libcst package in python to transform it into source code: 123456from libcst import *abc = Module(....)with open('...','w') as f: f.write(str(abc.code)) Here is the source code in python: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import binasciiplaintext = \"REDACTED\"def exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempdef BinaryToDecimal(binary): string = int(binary, 2) return string# encryptionPT_Ascii = [ord(x) for x in plaintext]PT_Bin = [format(y, '08b') for y in PT_Ascii]PT_Bin = \"\".join(PT_Bin)n = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showL1 = PT_Bin[0:n]R1 = PT_Bin[n::]f1 = exor(R1, K1)R2 = exor(f1, L1)L2 = R1f2 = exor(R2, K2)R3 = exor(f2, L2)L3 = R2R3 = '''''' # Too long to showL3 = '''''' # Too long to showcipher = L3+R3# # decryption (redacted)# plaintext = L6+R6# plaintext = int(plaintext, 2)# plaintext = binascii.unhexlify('%x' % plaintext)# print(plaintext) This is a pretty easy structure, we can easily recover plaintext by: 1234567891011121314151617181920212223242526272829import binasciidef exor(a, b): temp = \"\" for i in range(n): if (a[i] == b[i]): temp += \"0\" else: temp += \"1\" return tempn = 26936K1 = '''''' # Too long to showK2 = '''''' # Too long to showR3 = '''''' # Too long to showL3 = '''''' # Too long to showR2 = L3L2 = exor(exor(K2, R2), R3)R1 = L2L1 = exor(exor(K1, R1), R2)plaintext = L1+R1plaintext = int(plaintext, 2)plaintext = binascii.unhexlify('%x' % plaintext)plaintext = binascii.unhexlify(plaintext)print(plaintext) The flag is : 3k{almost_done_shizzle_up_my_nizzle} Once_upon_a_timeGiven a program and encrypted flag: scss : program entrance main.c cipher.c flag_encrypted … Excellent realization of LFSR and block cipher encryption in C. We notice that the initial vector is fixed, 0xa2 :) Addtionally, the key is fixed too, which means we can always get the same key stream. Moreover, I find something wired in cipher.c: 123case ECB: temp_ciphertext = temp_keystream ^ temp_plaintext; break; We can create a file with only ‘\\x00’ and encrypt it in ECB mode to get the keystream. Since there are five modes, we can only try every situations. Woooool, finally catch ya! OFB! 12345678910In [20]: plaintext = '' In [21]: for i in range(113): ...: iv = iv ^ keystream[i] ...: temp = iv ^ cipher[i] ...: plaintext += chr(temp) ...: In [22]: plaintext Out[22]: '3k&#123;my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail&#125;' The flag is : 3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail} You shall not get my cookiesGiven an example cipher, and if the cipher can be correctly decrypted, it will send “Nop” back. I follow the write up here: https://ctftime.org/writeup/22602 Notice that there is an error in the write up above: if the length of a block is 16 bytes, it will be appended a block of sixteen ‘\\x16’ according to PKCS#7 padding principle. Here is my exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-from pwn import *from Crypto.Util.number import bytes_to_long# context.log_level = 'debug'target = 'youshallnotgetmycookies.3k.ctf.to'port = 13337cipher = \"6F6A6A2C6E780D070A19001707060C0D\"suffix = ''fake_iv = ''dc = ''try: for i in range(1,17): assert(len(dc) == 2*(i-1)) for j in range(0x100): guess = hex(j)[2:].upper().zfill(2) fake_iv = '00' * (16-i) + guess + suffix print('[-]' + fake_iv) p = remote(target, port) p.sendlineafter('So... whats your cookie: ', fake_iv + cipher) res = p.recvall(timeout=4) p.close() res = res.decode() if len(res) == 11: pad = bytes([i]) dc = hex(int(guess, 16) ^ bytes_to_long(pad))[2:].upper().zfill(2) + dc suffix = hex(int(dc, 16) ^ bytes_to_long(bytes([(i+1)]) * i))[2:].upper().zfill(i*2) print('[-] D(C1) '+ dc) break print('[-] D(C1) '+ dc)except pwnlib.exception.PwnlibException: pass# 1C091F451A0B070D00130A1D0D0C0607 for the first block to be d(C2)# B0A608DDC37A458EEC0B74D37E888E8A for the second block# ...3B143145885BB42C94 for the third block# C2# 90C560B2A01529EF986E54B016E1FEAA# C1# 6F6A6A2C6E780D070A19001707060C0D# Calculate d(C1)# 218A7AEECEFB49CADF3D227AD84A21CF# Calculate C0# 6CEB0A82ABDB06ABAB50471BB46A63A6# The whole fake cipher:# 6CEB0A82ABDB06ABAB50471BB46A63A66F6A6A2C6E780D070A19001707060C0D90C560B2A01529EF986E54B016E1FEAA It cost 2 hours running this script twice.","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-First-Half-Review","slug":"2020-First-Half-Review","date":"2020-06-30T15:23:46.000Z","updated":"2020-07-17T02:47:27.086Z","comments":true,"path":"2020/06/30/2020-First-Half-Review/","link":"","permalink":"https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/","excerpt":"","text":"2020 已经过半，新年的钟声仿佛仍然萦绕在耳边。时间过得太快，留下的太少。 回顾今年真的很特别啊，二月份的时候还抱着回学校上课的想法，现在已经上了一学期的网课。对于网课和回学校上课，我是偏后者的。要知道，待在家里学习效率不到学校的十分之一：）不过还好，现在好像慢慢习惯下去了 hhhhh 本来是二月底开学的，不过学校说推迟开学（不带网课的那种）。好吧，等到三月份，盼了许久谁知改成网课（直接裂开&gt;_&lt;，网课==自学。不得不说，这半年处于真·白学阶段，白学能力提高了不少。 一月主要在学了 Matlab 编程和 Latex，从基本语法到画图，再到如何用 Latex 写出一篇 nice 的论文。学这个主要是为了准备数模，不过听说毕业论文要用 Latex 2333。因为寒假前有个朋友拉数模美赛，自己感觉想试试（说不定好好学能拿个奖。于是就报名去了，报名费也不便宜。后面去听了听那边的基础课，建模对数学要求还是挺高的，有点懵。后面朋友说让我学学 Matlab 编程。基础学下来其实也不用花很长时间，但是拖着拖着到二月份去了。不过回想那个时候，自己跟着网上教程走，还是不错的。 美赛在三月份，基础搞好了以后就开始放飞自我了（真就只搞了基础 wdt。其实主要是发现自己太久没搞学科了，于是又跑来这边学学。掏出一个《快乐的 Linux 命令行》，也忘了是谁发给我的了，系统地过一遍 Linux。从文件系统跳转到 vim 处理文本 再到软件包管理，最后 shell 编程，途中顺便捡回了正则表达式。看的时候其实真的有很大感触。看懂命令，提高主动性，这是我悟出的一点。最近选课突然发现下学期有一门叫《操作系统实践》的课，讲得就是 Linux 命令2333 美赛那三天每天只睡了6个小时，负责编程。另外两个大佬建模分析等等（这里的等等省略了许多…… wtcl 代码都是队友帮我找的。当时其实挺自责的，到后两天我才开始发挥作用。最终还是两位大佬带着我一个菜鸡勉强拿了个奖。求下年别再拉我了。 到了三月底就开始上课了，通常第一个星期都是介绍课程，必须要听啊，种种原因。一开始的那几个星期还是很认真的听课的，后面就不忍直视了。school 特色原因，水课很多。这时候网课的优势就凸显出来了。话虽这么说，但是英语还是得好好学。 四月份开始准备学校的新生赛。Crypto 不会出题。于是直接用了上一年校赛的模板，一波三折，最后强行凑出三道题，难度还不小，直接丢到平台，没人做出来 555 大概四月中旬，家里人出事情了，心态有点崩，之后算是勉勉强强地在学习吧。 到了五月份，整个人勤快了，学得挺快。把 Crypto 的基础过了一遍，打下了几场比赛，看了不少paper，收获还是挺大的，可惜没有进到线下。一个队伍，三缺一，加上进线下的种种困难，离目标还是很远啊。 六月份主要在准备各科的考试，全力复习，毕竟还是想混个奖学金。现在想想，不知不觉，已经在家半年。。。希望快快开学。 感想大学已经过去一半，庆幸自己这一年没有浪费，但也很可惜，没有达到自己预期的目标。怎么说呢，自己当初的目标其实已经改变了吧，现实中的变化的太快，而且自己当初的决心似乎也没有那么坚定。走一步看一步吧，毕竟不想浪费这几年宝贵的时间。 展望用某人的话：”少说话，多做事。光说不练假把式，要勤奋，勇于实践。”","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"das-CTF&GK-CTF-2020-Writeup","slug":"das-CTF-GK-CTF-2020-Writeup","date":"2020-05-24T01:30:24.000Z","updated":"2020-08-03T03:26:26.371Z","comments":true,"path":"2020/05/24/das-CTF-GK-CTF-2020-Writeup/","link":"","permalink":"https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/","excerpt":"","text":"Only writeup in Crypto. GKCTF小学生的密码学(Solved)Pretty easy affince cipher. Both keys are given. babycrypto(Solved)Partial high bits of p is known. 123456789101112131415161718192021222324# Use sage to run the script# Reference: https://www.jianshu.com/p/1a0e876d5929from sage.all import *from Crypto.Util.number import long_to_bytes# All variables are in hexn = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005# Padding zeros to p --&gt; p4p4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000cipher = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361e2 = 65537kbits = 128 # kbits represent the loss bitsPR.&lt;x&gt; = PolynomialRing(Zmod(n)) # Create a polynomial ringf = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4 + int(roots[0]) assert n % p == 0 q = n / int(p) phin = (p-1)*(q-1) d = inverse_mod(e2,phin) flag = pow(cipher,d,n) print long_to_bytes(flag) 汉字的密码(Solved)当铺密码+Substitution Cipher 123456dic = [66, 74, 62, 67, 118, 83, 72, 77, 86, 55, 71, 57, 82, 57, 64, 63, 51, 107]delta = 1for i in dic: print(chr(i+delta), end=\"\") delta += 1# FLAG&#123;YOU_ARE_GOOD&#125; Backdoor(Unsolved)Remain confused DASCTFbbcrypto(Solved)quiz.py 1234567891011121314151617181920212223# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=\"\" for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return cif __name__ == \"__main__\": m = 'flag&#123;********************************&#125;' a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(\"明文内容为：\") print(m) print(\"加密后的密文为：\") c=encrypt(m, a, si) print(c) #加密后的密文为： #177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d The length of salt is 3 and we have already known that the plain starts with “flag{“. Solve linear congruent equations to get the salt. 123456789101112131415161718192021222324c = \"177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d\"li_c = [int(c[i:i+2], 16) for i in range(0, len(c), 2)]# print(li_c)m = \"flag&#123;\"d_c = li_c[3] - li_c[0]# print(d_c)d_m = ord(m[3]) - ord(m[0])# print(d_m) # a = 57 mod 128a = 57# print((li_c[0] - a * ord(m[0])) % 128)# print(chr(97)) y1 = 'a'# print((li_c[1] - a * ord(m[1])) % 128)# print(chr(104)) y2 = 'h'# print((li_c[2] - a * ord(m[2])) % 128)# print(chr(104)) # y3 = 'h'# print((li_c[3] - a * ord(m[3])) % 128)m = \"\"from gmpy2 import invertimport itertoolsinv_a = invert(a, 128)key = itertools.cycle(\"ahh\")for i in li_c: m += chr(((i - ord(next(key))) * inv_a) % 128)print(m) encrypt_img(Solved)quiz.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from numpy import arrayfrom PIL import Imagefrom secret import KeyPlaintext1 = \"RC4IsInteresting\"Plaintext2 = \"ThisIsAEasyGame\"cnt = 0class RC4(): def __init__(self, Key): self.S = [i for i in range(256)] # 0 - 255 self.K = [ord(Key[i % len(Key)])*2 for i in range(256)] # KEY * 2(0-255) self.I, self.J = 0, 0 self.KSA() def KSA(self): for i in range(256): j = (i+self.K[i]+self.S[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def next(self): self.I = (self.I+1) % 256 self.J = (self.J+self.S[self.I]) % 256 self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J] tmp = (self.S[self.J] + self.S[self.I]) % 256 return self.S[tmp]class Encrypt(): def __init__(self, plain): global cnt cnt += 1 self.rc4 = RC4(Key) self.testRC4(plain) flag_file = Image.open(r\"flag.png\") img = array(flag_file) self.enc(img) def testRC4(self, plain): ciphertext = 0 for i in plain: ciphertext = (ciphertext &lt;&lt; 8)+ord(i) ^ self.rc4.next() print(\"ciphertext&#123;&#125; = &#123;&#125;\".format(cnt, ciphertext)) def enc(self, img): a, b, _ = img.shape for x in range(0, a): for y in range(0, b): pixel = img[x, y] for i in range(0, 3): pixel[i] = pixel[i] ^ self.rc4.next() img[x][y] = pixel enc = Image.fromarray(img) enc.save(\"enc&#123;&#125;.png\".format(cnt))Encrypt(Plaintext1)Encrypt(Plaintext2)# ciphertext1 = 12078640933356268898100798377710191641# ciphertext2 = 79124196547094980420644350061749775 enc1.png enc2.png Stream Cipher Insertion Attack Such a pity that I didn’t figure it out at that time. From two groups of plaintexts and ciphertexts we can recover keystream at the start. However, the second keystream has one bit less than the first one, from which we easily can retrieve m0, then k1, after that m1 and so on. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748'''plaintext1 = \"RC4IsInteresting\"plaintext2 = \"ThisIsAEasyGame\"ciphertext1 = 12078640933356268898100798377710191641ciphertext2 = 79124196547094980420644350061749775key1 = []for i in range(len(plaintext1) - 1, -1, -1): key1 = [ord(plaintext1[i]) ^ (ciphertext1 &amp; 0xff)] + key1 ciphertext1 &gt;&gt;= 8print(key1)key2 = []for i in range(len(plaintext2) - 1, -1, -1): key2 = [ord(plaintext2[i]) ^ (ciphertext2 &amp; 0xff)] + key2 ciphertext2 &gt;&gt;= 8print(key2)# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106, 126]# [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106]'''# Suppose the bit length of the flag.png is n bits, key1 and key2 can be written like:# key1: k1, k2, ..., kn# key2: k0, k1, ..., k(n-1)# Above we have already known k0 is 126, which is the last key of plaintext2,# we can retrieve m0, then k1, after that m1 and so onfrom PIL import Imagefrom numpy import arrayimg1 = array(Image.open(r\"./enc1.png\"))img2 = array(Image.open(r\"./enc2.png\"))def recovery_img(im1, im2, k): x1, y1, z1 = im1.shape for i in range(x1): for j in range(y1): pixel1 = im1[i, j] pixel2 = im2[i, j] for _ in range(3): pixel2[_] = pixel2[_] ^ k k = pixel1[_] ^ pixel2[_] im2 = Image.fromarray(im2) im2.save(\"dec.png\")recovery_img(img1, img2, 126) babyLCG(Solved)quiz.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Util.number import*from secret import flagclass LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = getRandomNBitInteger(128) self.m = getPrime(256) self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)DH = DH()flag = bytes_to_long(flag)print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"Cipher = &#123;&#125;\".format(flag ^ DH.key))'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' LCG+Diffie Hellman Exchange Key The seed is too small ,as a result, we use brute-force attack to get the seed and recover the key. When we XOR the cipher with the key, the plain is figured out. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475'''a = 3844066521b = 3316005024m = 2249804527'''class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 714405490 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(\"a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;\".format(self.a, self.b, self.m)) print(\"state1 = &#123;&#125;\".format(self.next())) print(\"state2 = &#123;&#125;\".format(self.next()))class DH: def __init__(self): self.lcg = LCG() self.lcg.output() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() # a private key self.B, self.b = self.gen_AB() # b private key self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = '' for _ in range(64): x += '1' if self.lcg.next() % 2 else '0' return pow(self.g, int(x, 2), self.m), int(x, 2)'''def next(x): return (x * a + b) % mdef brute_force(): for i in range(1&lt;&lt;32): if i % 10000000 == 0: print(\"count:\", i) res = next(i) if (res &gt;&gt; 16) == 16269 and (next(res) &gt;&gt; 16) == 4249: print(i) break'''DH = DH()cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703print(\"g = &#123;&#125;\\nA = &#123;&#125;\\nB = &#123;&#125;\\nM = &#123;&#125;\".format(DH.g, DH.A, DH.B, DH.m))print(\"flag = &#123;&#125;\".format(cipher ^ DH.key))# flag = 13040004482819966666226297285938773653367957972934959074317939536564198335643452104954492541# flag&#123;4dfe14e0c6c21ffcf5a3b4f0ed1911f6&#125;'''a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249g = 183096451267674849541594370111199688704A = 102248652770540219619953045171664636108622486775480799200725530949685509093530B = 74913924633988481450801262607456437193056607965094613549273335198280176291445M = 102752586316294557951738800745394456033378966059875498971396396583576430992701Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703''' Knapsack(Solved)quiz.py 123456789101112131415161718192021222324252627282930from Crypto.Util.number import *from functools import reducedef genKey(length): A, B = getPrime(64), getPrime(1025) Rn = getPrime(1024) key1 = [Rn//2**i for i in range(1, length+1)] key2 = [i*A % B for i in key1] return key1,key2def encrypt(text,key): Sum=0 for i in range(len(text)): Sum+=int(text[i])*key[i] return Sumdef save(Ciper,Key): f1=open(\"pub.txt\",\"w\") for i in range(len(Key)): f1.write(str(Key[i])+'\\n') f2=open(\"cip.txt\",\"w\") f2.write(hex(Ciper))FLAG = bin(bytes_to_long(flag.encode()))[2:]Key1,Key2 = genKey(len(FLAG))Ciper = encrypt(FLAG,Key1)save(Ciper,Key2) cip.txt 1a long hex string pub.txt 11015 public keys The last few key in pub.txt is too small, which actually is the original private key. We can use them to recover the original private key. backpacker(Unsolved)Remain confused What I have doneFinish learning symmetric cipher and the first chapter of Network Introduction. Things to Improve Don’t be panic when encountering a challenge that is never met Be more concentrated on study LLL algorithm","categories":[],"tags":[{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"}]},{"title":"Npu-CTF-2020-Review","slug":"Npu-CTF-2020-Review","date":"2020-05-12T13:20:15.000Z","updated":"2020-08-03T03:26:42.361Z","comments":true,"path":"2020/05/12/Npu-CTF-2020-Review/","link":"","permalink":"https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/","excerpt":"","text":"Only review in Crypto. What does the tag mean Status Description Solved Solved in the competition Unlved Unsolved in the competition Mersenne Twister(unsolved)This challenge is related to Mersenne Twister Encryption. However, there are differences between them exactly. Here is the file: Mersenne Twiser.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from hashlib import *from itertools import *from binascii import hexlify , unhexlifyfrom flag import flag ,seedassert len(flag) == 26assert flag[:7] == 'npuctf&#123;'assert flag[-1] == '&#125;'XOR = lambda s1 ,s2 : bytes([x1 ^ x2 for x1 ,x2 in zip(s1 , s2)])class mt73991: def __init__(self , seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i+1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i+1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i+1)%233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4 , 'big') self.flag += 1 return bits def Next(self , tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef encrypt(key , plain): tmp = md5(plain).digest() return hexlify(XOR(tmp , key))if __name__ == \"__main__\": flag = flag.encode() random = mt73991(seed) f = open('./cipher.txt' , 'wb') for i in flag: key = b''.join([random.getramdanbits() for _ in range(4)]) cipher = encrypt(key , chr(i).encode()) f.write(cipher) cipher.txt 1an 832 bytes long hex string ExplanationMersenne Twister is a kind of PRNG, whose derives from the fact that its period length is chosen to be a Mersenne Prime. This Mersenne Twister challenge has a 32-bit length. ConditionOnly a few conditions are given. the encryption result in cipher.txt the period length partial flag the length of the flag encryption function DetailsGiven that the first part of the flag is “npuctf{“, which is a 7 bytes long string, we can retrieve the first 28 generated states with the according cipher in cipher.txt. Since we also know the last byte of the string(“}”) and the length of the string, we can easily retrieve the 100th~103th generated states. Then we look into the generate function. 12345678def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp Suppose that i equals to 103, we try to write down that situation. 12345678def generate(self): for i in range(233): y = (self.state[103] &amp; 0x80000000) | (self.state[(104) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 # 1 temp ^= self.state[(0) % 233] # 2 if y &amp; 1: temp ^= 0x9908f23f self.state[103] = temp # 3 In this situation, it is possible for us to retrieve the104th initial state, which means that we can get the seed through inversing. There are two possibilities in this situation(state[104] is odd or even). We try to draw a table. possibilites hb(1) hb(2) hb(3) even 0 0 0 odd 0 0 1 hb in the table above means the highest bit of the value in the line #n. Based on the fact that the true hb(3) is 0, which is the highest bit of the 103th generated state, it is impossible for the 104th initial state to be odd. Therefore, we can retrieve y and the low 31 bits of the 104 initial state. Since the highest bit is unknown, we can guess it (zero or one). Therefore, there are two possible seeds, which can be judged in the end. Because the seed is retrieved, we can decrypt the cipher easily.(Something just like Symmetric Cipher) By the way, the md5 function in encrypt function seems to be useless because it only encrypts one character, for which we can correspondingly generate an md5 dictionary of all printable characters and print the corresponding characters. RealizationHere is my realization. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import hashlibimport binasciifrom Cryptodome.Util.number import *import stringXOR = lambda s1, s2: bytes([x1 ^ x2 for x1, x2 in zip(s1, s2)])initial_state = [0] * 233initial_state2 = [0] * 233cipher = ['cef4876036ee8b55aa59bca043725bf3', '50a5e491debdef7ef7d63e9609a288ca', '1e2c82a7fe566bd8709e73c8d495ea50', '4a486ed11189faf8e6fb35617e47d2d1', 'ad5e4783e96afeaae9f7104ec477fb39', 'fe4ec619bf58289709e15c4449f03fc5', '1cba918cd0ebfdc12376b41e78154064', '82733b3b200826b6c78d86563edaea94', 'dccf459a4291517a4b8367d7b4a53aee', 'cd7e0accf661bfc726f5ba62e1c0e041', '00108ad32e7d5711f780185cba5cf31d', '328bee84066be4ab9582cf9d4bfe3c6f', '96a7732e1c37d800c90fd46277147f0a', '26c149dcd5eeb0f2df0c075627bc220b', 'e5eefdd67186056ac28c21e155a7f247', '664aaecdb498134de274df10114d1f06', 'f84dd21820f150d69c9439d909dec0f5', 'ccfeab61b62db2ea91d31bc8163ff16c', '7f458006bd5ac4a5f5bfae2770b23ccf', 'b7195b76aa0a9aa146831667a7b9fe08', 'c19e691afadccb3ca5169ef3fabaa3da', 'd47d536e89ed4cee6f788bc969c3ad31', '37850ebfc46a73af2b0c036c3da4b4a1', '6506f499445c604dd73eeb846a52f881', '515a3ad0ab448b4f9ed3e0ab1fffac60', 'b223dde6450ba6198e90e14de107aaf2']starts = \"npuctf&#123;\"ends = \"&#125;\"class mt73991: def __init__(self, seed): self.state = [seed] + [0] * 232 self.flag = 0 self.srand() self.generate() def srand(self): for i in range(232): self.state[i + 1] = 1812433253 * (self.state[i] ^ (self.state[i] &gt;&gt; 27)) - i self.state[i + 1] &amp;= 0xffffffff def generate(self): for i in range(233): y = (self.state[i] &amp; 0x80000000) | (self.state[(i + 1) % 233] &amp; 0x7fffffff) temp = y &gt;&gt; 1 temp ^= self.state[(i + 130) % 233] if y &amp; 1: temp ^= 0x9908f23f self.state[i] = temp def getramdanbits(self): if self.flag == 233: self.generate() self.flag = 0 bits = self.Next(self.state[self.flag]).to_bytes(4, 'big') self.flag += 1 return bits def Next(self, tmp): tmp ^= (tmp &gt;&gt; 11) tmp ^= (tmp &lt;&lt; 7) &amp; 0x9ddf4680 tmp ^= (tmp &lt;&lt; 15) &amp; 0xefc65400 tmp ^= (tmp &gt;&gt; 18) &amp; 0x34adf670 return tmpdef USMR(x, shift, mask): res = x for i in range(32): res = x ^ (res &gt;&gt; shift &amp; mask) return resdef USML(x, shift, mask): res = x for i in range(32): res = x ^ (res &lt;&lt; shift &amp; mask) return resdef inv_Next(x): x = USMR(x, 18, 0x34adf670) x = USML(x, 15, 0xefc65400) x = USML(x, 7, 0x9ddf4680) x = USR(x, 11, 0xffffffff) return xdef inv_srand(value, index): for i in range(index-1, -1, -1): value += i value *= inverse(1812433253, 0x100000000) value = USR(value, 27, 0xffffffff) value &amp;= 0xffffffff return valuedef USR(value, shift, mask): i = 0 res = 0 while i * shift &lt; 32: partMask = ((0xffffffff &lt;&lt; (32 - shift)) &amp; 0xffffffff) &gt;&gt; (shift * i) part = value &amp; partMask value ^= (part &gt;&gt; shift) &amp; mask res |= part i += 1 return res# hash all known charactershash_starts = []for i in starts: hash_starts.append(hashlib.md5(i.encode()).digest())# print(hash_starts)hash_ends = hashlib.md5(ends.encode()).digest()state = [0] * 233# first 7 charactersfor i in range(len(starts)): key = XOR(hash_starts[i], binascii.unhexlify(cipher[i])) for j in range(4): tmp = inv_Next(bytes_to_long(key[4*j:4*j+4])) state[4*i+j] = tmp# print(state[:28]) # check passdef decrypt(key, cipher): cipher = binascii.unhexlify(cipher) temp = XOR(key, cipher) for i in md5_dic: if temp == i: print(string.printable[md5_dic.index(i)], end=\"\")# the last characterkey = XOR(hash_ends, binascii.unhexlify(cipher[-1]))for i in range(4): tmp = inv_Next(bytes_to_long(key[4*i:4*i+4])) state[100+i] = tmp# print(state[100:104]) # check pass# Since it can be simplified, there are only two situations of old_state[104]# old_state[104] is eveny = (state[0] ^ state[103]) &lt;&lt; 1 # recover y# print(y) # check passposs_1 = y &amp; 0x7fffffffposs_2 = (y &amp; 0x7fffffff) | 0x80000000# print(poss_1)# print(poss_2)# check pass# get the seed of each situationposs_1 = inv_srand(poss_1, 104)poss_2 = inv_srand(poss_2, 104)print(poss_1)print(poss_2)# generate md5 dictionarymd5_dic = []for i in string.printable: md5_dic.append(hashlib.md5(i.encode()).digest())random_1 = mt73991(poss_1)random_2 = mt73991(poss_2)# recover the flag from random_1flag = \"\"for i in range(26): key = b''.join([random_1.getramdanbits() for _ in range(4)]) decrypt(key, cipher[i])# Since random_1 is the correct one, random_2 can be ignored. 这题一开始出题人搞错了。。。自闭了一下午 认清形势，建立信心After observing the task.py, we can find that this is a classical discrete logarithm problem. Let’s see the file. task.py 12345678910111213141516171819202122from Crypto.Util.number import *from gmpy2 import *from secret import flagp = getPrime(25)e = # Hiddenq = getPrime(25)n = p * qm = bytes_to_long(flag.strip(b\"npuctf&#123;\").strip(b\"&#125;\"))c = pow(m, e, n)print(c)print(pow(2, e, n))print(pow(4, e, n))print(pow(8, e, n))'''169169912654178128509160179202518818742414340358553002064450''' ExplanationThere are many methods to solve discrete logarithm problems, BSGS(Baby Steps Giant Steps), SPH method and so on. ConditionThere are four equations in task.py and the remains of four equations are given. The flag is in the first equations. Here is what we have known. The length of q and p remains of four equations My idea is that n is possible to be solved and after that we can use the second equation to calculate e, using discrete logarithm calculation methods. DetailsWe can notice that: n\\;|\\;gcd(c1^{3}\\;-\\;c3,\\;c1^{2}\\;-\\;c2)From this character and another character that n is the product of two big prime number, we can get n. After that, it is really convenient that we can use discrete_log() function in Sage to calculate e. Luckily, e is coprime with n, so the inverse exists. The decryption is the similar with rsa. RealizationMy realization. 1234567891011121314151617181920212223242526272829303132#! /usr/bin/env sagefrom Crypto.Util.number import long_to_bytesimport gmpy2def gcd(a, b):tureif b == 0:tureturereturn a, 0turea, b = gcd(b, a % b)turereturn a, bc = 169169912654178c_1 = 128509160179202c_2 = 518818742414340c_3 = 358553002064450dc_1 = c_1 ** 2 - c_2dc_2 = c_1 ** 3 - c_3n = gcd(dc_1, dc_2)[0] / 2# print(n) # check passn.factor()p = 18195301q = 28977097phi = (p - 1) * (q - 1)e = discrete_log(Mod(c_1, n), Mod(2, n))# print(e) # check pass# print(gcd(e, phi)[0]) # check passd = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m)) Referenceshttps://en.wikipedia.org/wiki/Mersenne_Twister","categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"}]},{"title":"2020-05-03","slug":"2020-05-03","date":"2020-05-03T14:44:24.000Z","updated":"2020-05-03T14:50:02.431Z","comments":true,"path":"2020/05/03/2020-05-03/","link":"","permalink":"https://buki-freak.github.io/2020/05/03/2020-05-03/","excerpt":"","text":"What I Have DoneSadly, the quiz yesterday is still unsolved. It seems that z3-solver doesn’t work. As a result, I study Correlation Attack which is a kind of brute-force attack method. The method seems to work now and I am trying to understanding the codes written by others. Daily IELTS exercises have been done. What a day! Things to Learn and Improve Stream Cipher - Correlation Attack Method","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"2020-05-02","slug":"2020-05-02","date":"2020-05-02T13:12:07.000Z","updated":"2020-05-02T13:22:44.870Z","comments":true,"path":"2020/05/02/2020-05-02/","link":"","permalink":"https://buki-freak.github.io/2020/05/02/2020-05-02/","excerpt":"","text":"What I Have DoneA competition is held in these days, exciting and also exhausting! I am confident on a quiz about LFSR, which I have lately learned. However, things always does go in the right way, isn’t it? After being trapped for over five hours, I went to sleep… While I did several IELTS reading exercises, oh of course, I have finished The End of the fxxking world Season One just for fun ha ha ha! Things to Learn and Improve z3-solver English reading speed Be easygoing","categories":[],"tags":[{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]},{"title":"Greeting","slug":"Greeting","date":"2020-05-01T12:33:15.000Z","updated":"2020-05-01T12:57:56.341Z","comments":true,"path":"2020/05/01/Greeting/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/Greeting/","excerpt":"","text":"Today, I have deleted all blogs deployed before. My greeting is below. The Past​ For a so-called loser, it is always mournful to talk about his or her past. Actually, I am one of them, after failing the college entrance examination. What’s more, things go wrong in these university days. It seems that I have have been trapped for such a long time, or have had a nightmare. Families, friends, mates, the environment, …, everything goes in a wrong way. However, Mama usually tells me to be positive, which merely works at some time I think. Well, as is told, if you don’t like this world, you can just try to leave it and choose your life. It will be alright, since seldom people can live for 100 years. I mean I should do what I really want to do in limited time. Therefore, stop to complain about the past, leave that fxxking world and alter a world that you want. Present Days​ Well, all roads lead to Rome. There are many ways to achieve your ambition and I choose that one that I have lately planned. Once the goal is settled, you only need to: Focus Focus Focus FutureFuture is unpredictable, but we should be hopeful. Look at the sky, and you will find how lovely it is to see the past of others. They are shining for you.","categories":[],"tags":[{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-01T12:30:10.251Z","updated":"2019-08-27T01:03:22.557Z","comments":true,"path":"2020/05/01/hello-world/","link":"","permalink":"https://buki-freak.github.io/2020/05/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Review","slug":"Review","permalink":"https://buki-freak.github.io/tags/Review/"},{"name":"Writeup","slug":"Writeup","permalink":"https://buki-freak.github.io/tags/Writeup/"},{"name":"Sage","slug":"Sage","permalink":"https://buki-freak.github.io/tags/Sage/"},{"name":"Textbook","slug":"Textbook","permalink":"https://buki-freak.github.io/tags/Textbook/"},{"name":"Paper","slug":"Paper","permalink":"https://buki-freak.github.io/tags/Paper/"},{"name":"Personal Development","slug":"Personal-Development","permalink":"https://buki-freak.github.io/tags/Personal-Development/"},{"name":"Daily Post","slug":"Daily-Post","permalink":"https://buki-freak.github.io/tags/Daily-Post/"}]}