<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>buk1</title>
  
  <subtitle>Every day is my last day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://buki-freak.github.io/"/>
  <updated>2020-08-06T08:50:28.601Z</updated>
  <id>https://buki-freak.github.io/</id>
  
  <author>
    <name>buki</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RSA-Learning</title>
    <link href="https://buki-freak.github.io/2020/08/03/RSA-Learning/"/>
    <id>https://buki-freak.github.io/2020/08/03/RSA-Learning/</id>
    <published>2020-08-03T13:22:37.000Z</published>
    <updated>2020-08-06T08:50:28.601Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了一篇 RSA 的paper，总结的不错，简单地做下笔记。</p><p>RSA 是基于 Factoring Large Integers Problem 的公钥密码体制。</p><h1 id="Elementary-Attacks"><a href="#Elementary-Attacks" class="headerlink" title="Elementary Attacks"></a>Elementary Attacks</h1><h2 id="Common-Modulus"><a href="#Common-Modulus" class="headerlink" title="Common Modulus"></a>Common Modulus</h2><p>….</p><h2 id="Blinding"><a href="#Blinding" class="headerlink" title="Blinding"></a>Blinding</h2><p>出现在不经 padding 和 check 的 RSA signiture 中，如果签名方不仔细审查明文，攻击者可以伪造某人对于任何内容的签名。</p><p>cheat 大致过程如下：</p><p><img src="https://s1.ax1x.com/2020/08/06/agFLoF.jpg" alt="agFLoF.jpg"></p><p>整个过程称为 blinding，是因为 Bob 没能得知他要签名的内容。签名方在签名前检查内容能够防止这个问题。</p><h1 id="Low-Private-Exponent"><a href="#Low-Private-Exponent" class="headerlink" title="Low Private Exponent"></a>Low Private Exponent</h1><p>低解密指数攻击。</p><p>d 的大小会影响解密的时长。为了速度上的要求，有人会将 d 设置的更小。M.Wiener 提出的攻击方法对很小的 d 的 RSA 系统带来威胁。</p><h2 id="Theorem-2-M-Wiener"><a href="#Theorem-2-M-Wiener" class="headerlink" title="Theorem 2(M. Wiener):"></a>Theorem 2(M. Wiener):</h2><p><img src="https://s1.ax1x.com/2020/08/06/agF7LV.jpg" alt="agF7LV.jpg"></p><h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof:"></a>Proof:</h2><p>证明过程利用连分数。<br>因为 $ed\;\equiv\;1\mod\;\varphi(N)$，所以存在一个 k 满足:  $ed\;-\;k\varphi(N)\;=\;1$，因此有：</p><script type="math/tex; mode=display">\left|\frac{e}{\varphi(N)}\;-\;\frac{k}{d}\right|\;=\;\frac{1}{d\varphi(N)}</script><p>所以可以把 $\frac{k}{d}$ 看成是 $\frac{e}{\varphi(N)}$ 的大概值。<br>然后因为 $\varphi(N)\;=\;N\;-\;p\;-\;q\;+\;1$ 以及 $p\;+\;q\;-\;1\;&lt;\;3\sqrt{N}$ 所以有：</p><p><img src="https://s1.ax1x.com/2020/08/06/agFbZT.jpg" alt="agFbZT.jpg"></p><p>计算 $\frac{e}{N}$ 的连分数，其中有一个解等于 $\frac{k}{d}$，由于 $ed\;-\;k\varphi(N)\;=\;1$，所以 $gcd(k, d)\;=\;1$ ，即 $\frac{k}{d}$ 为真分数。线性时间可以解得 d。</p><h2 id="Limits"><a href="#Limits" class="headerlink" title="Limits"></a>Limits</h2><h3 id="Large-e"><a href="#Large-e" class="headerlink" title="Large e:"></a>Large e:</h3><p>对解密指数进行改进，令 $e’\;=\;e\;+\;t\varphi(N), t is large enough$，e’ 作为新的加密指数:</p><p><img src="https://s1.ax1x.com/2020/08/06/agFqdU.jpg" alt="agFqdU.jpg"></p><h3 id="Using-CRT"><a href="#Using-CRT" class="headerlink" title="Using CRT"></a>Using CRT</h3><p>保证 d 的 bit size 的同时，使用 CRT 对解密来提升解密速度。<br>计算：</p><script type="math/tex; mode=display">d_p\;\equiv\;d\;\mod(p\;-\;1)\\d_q\;\equiv\;d\;\mod(q\;-\;1)</script><p>并且 $d_q$ 和 $d_p$ 足够小(128 bits each)。<br>然后计算：</p><script type="math/tex; mode=display">M_p\;\equiv\;C^{d_p}\mod\;p\\M_q\;\equiv\;C^{d_q}\mod\;q</script><p>最后 CRT：</p><script type="math/tex; mode=display">\begin{cases}M\;\equiv\;C^{d_p}\mod\;p \\\\M\;\equiv\;C^{d_q}\mod\;q\end{cases}</script><p>$d_p$ 和 $d_q$ 过小会导致 N 容易分解。</p><p>Boneh and Durfee 方法可以将上界提到 $d &lt; N^{0.292}$</p><h1 id="Low-Public-Exponent"><a href="#Low-Public-Exponent" class="headerlink" title="Low Public Exponent"></a>Low Public Exponent</h1><p>数字签名中，e 的大小会影响验证的计算时长。e 过小会导致低加密指数攻击。</p><h2 id="Coppersmith’s-Theorem"><a href="#Coppersmith’s-Theorem" class="headerlink" title="Coppersmith’s Theorem"></a>Coppersmith’s Theorem</h2><h3 id="Theorem-3-Coppersmith"><a href="#Theorem-3-Coppersmith" class="headerlink" title="Theorem 3(Coppersmith)"></a>Theorem 3(Coppersmith)</h3><p><img src="https://s1.ax1x.com/2020/08/06/agFoMq.jpg" alt="agFoMq.jpg"></p><p>Coppersmith 提供了一个快速寻找 $f(x_0)\;\equiv\;0\;\mod\;N$ 根( $X\;=\;N^{\frac{1}{d}}$ )的方法。</p><h3 id="Lemma-4"><a href="#Lemma-4" class="headerlink" title="Lemma 4"></a>Lemma 4</h3><p><img src="https://s1.ax1x.com/2020/08/06/agFTs0.jpg" alt="agFTs0.jpg"></p><h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>由 Schwarz inequality 可得：</p><script type="math/tex; mode=display">\left|h(x_0)\right|\;=\;\left|\sum{a_i}x_{0}^{i}\right|\;=\;\left|\sum{a_i}X^{i}(\frac{x_0}{X})^{i}\right|\;\leq\;\sum\left|a_{i}X^{i}(\frac{x_0}{X})^i\right|\\\leq\;\sum\left|a_{i}X^{i}\right|\;\leq\;\sqrt{d}||h(xX)||\;\leq\;N</script><p>由于 $h(x_0)\;\equiv\;0\;\mod\;N$，所以有 $h(x_0)\;=\;0$ 前提是 h 的范数足够小。<br>因此，我们需要找到另外一个范数更小的多项式。满足上面的条件。</p><p>Coppersmith 提供了一个方法：</p><p><img src="https://s1.ax1x.com/2020/08/06/agFXi4.jpg" alt="agFXi4.jpg"></p><p>m 是未知的常量。我们从 $g_{u,v}(x)\;equiv\;0\;\mod\;N^m 中找到符合 $norm(h(xX))\;&lt;\;N^m$ 的多项式。m 足够大的时候有多个解。</p><p>找到这个合适的多项式需要构造格：</p><p><img src="https://s1.ax1x.com/2020/08/06/agFxzR.jpg" alt="agFxzR.jpg"></p><p>Hermite’s bound 说明m 足够大的时候，可以找到  $ norn(v) &lt; N^m$ 的向量。</p><h3 id="Fact-5-LLL"><a href="#Fact-5-LLL" class="headerlink" title="Fact 5(LLL)"></a>Fact 5(LLL)</h3><p><img src="https://s1.ax1x.com/2020/08/06/agFjJJ.jpg" alt="agFjJJ.jpg"></p><p>LLL 满足 Lemma 4 的条件：</p><script type="math/tex; mode=display">2^{\frac{w}{4}}det(L)^{\frac{1}{w}}\;<\;\frac{N^m}{\sqrt{w}},\;where\;w\;=\;d(m+1)\;is\;the\;dimension\;of\;L</script><h2 id="Hastad’s-Broadcast-Attack"><a href="#Hastad’s-Broadcast-Attack" class="headerlink" title="Hastad’s Broadcast Attack"></a>Hastad’s Broadcast Attack</h2><p>Hastad 第一次运用了 Coppersmith’s theorem。</p><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p><img src="https://s1.ax1x.com/2020/08/06/agFvW9.jpg" alt="agFvW9.jpg"></p><p>如果 $k\;\req\3;$，Marvin 可以恢复明文，假设我们有 $e_i\;=\;1,2,3….$，</p><script type="math/tex; mode=display">C_1\;\equiv\;M^3\;\mod\;N_1,\\C_2\;\equiv\;M^3\;\mod\;N_2,\\C_3\;\equiv\;M^3\;\mod\;N_3</script><p>如果对于所有  $N, i\;\neq\;j $，有  $gcd(N_i,\;N_j)\;=\;1$，那么使用 CRT 可以解除 $M^3$ 在整数上的值，开三次方根可以求出 M。</p><h3 id="Limits-1"><a href="#Limits-1" class="headerlink" title="Limits"></a>Limits</h3><p>所有的加密指数需要相同，并且需要满足 $k\;\geq\;e$。</p><p>Hastad 对于 pad 的改进了攻击方法。</p><h3 id="Theorem-6-Hastad"><a href="#Theorem-6-Hastad" class="headerlink" title="Theorem 6(Hastad)"></a>Theorem 6(Hastad)</h3><p><img src="https://s1.ax1x.com/2020/08/06/agkSQ1.jpg" alt="agkSQ1.jpg"></p><h3 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h3><p>设 $\bar{N}\;=\;N1\;\cdots\;N_k$，其中 N_i 互质。如果 $g_i$ 中的高次项系数在 $\Z^{*<br>}_{N_i}$ 不可逆，则 $N_i$ 的可以被容易分解。构造多项式：</p><p><img src="https://s1.ax1x.com/2020/08/06/agkpsx.jpg" alt="agkpsx.jpg"></p><p>$T_{i}$ 作为 Chinese Remainder Coefficients。$g(x)$ 是一元多项式，度为 d，并且 $g(M)\;\equiv\;0\;\mod\bar{N}$。</p><p>Theorem 6 符合 Theorem 3。</p><p>设 $g_i\;\equiv\;f_{i}^{e_i}\;-\;C_{i}\;\mod\;N_{i}$，我们可以恢复出明文。前提：<br>parties 的数量 k 需要大于 $max(e_{i}deg(f_i)), i\;=\;1,\cdots\;,k$。<br>特殊情况：所有加密指数相同，并且 pad 的 f 为线性函数（ $deg(f_i)\;=\;1$ ）时，满足 $ k\;&gt;\;e$ 即可。</p><h2 id="Franklin-Reiter-Related-Message-Attack"><a href="#Franklin-Reiter-Related-Message-Attack" class="headerlink" title="Franklin-Reiter Related Message Attack"></a>Franklin-Reiter Related Message Attack</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="https://crypto.stanford.edu/~dabo/pubs/papers/RSA-survey.pdf" target="_blank" rel="noopener">https://crypto.stanford.edu/~dabo/pubs/papers/RSA-survey.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看了一篇 RSA 的paper，总结的不错，简单地做下笔记。&lt;/p&gt;
&lt;p&gt;RSA 是基于 Factoring Large Integers Problem 的公钥密码体制。&lt;/p&gt;
&lt;h1 id=&quot;Elementary-Attacks&quot;&gt;&lt;a href=&quot;#Eleme
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>De1ta-CTF-2020-Review</title>
    <link href="https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/"/>
    <id>https://buki-freak.github.io/2020/08/03/De1ta-CTF-2020-Review/</id>
    <published>2020-08-03T03:40:01.862Z</published>
    <updated>2020-08-03T07:05:31.815Z</updated>
    
    <content type="html"><![CDATA[<p>Only review in Crypto.</p><h1 id="nlfsr-unsolved"><a href="#nlfsr-unsolved" class="headerlink" title="nlfsr(unsolved)"></a>nlfsr(unsolved)</h1><p>This challenge consists of 4 linear feedback shift registers (below I use LFSR instead), with accordingly 19 bits, 19 bits, 6 bits and 3 bits state length. Here is the given file:</p><p><strong>quiz.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> a, b, c, d, flag</span><br><span class="line"><span class="keyword">assert</span> flag == <span class="string">"De1CTF&#123;"</span> + <span class="string">''</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]) + <span class="string">"&#125;"</span></span><br><span class="line"><span class="keyword">assert</span> [len(bin(i)[<span class="number">2</span>:]) <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]] == [<span class="number">19</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">ma, mb, mc, md = <span class="number">0x505a1</span>, <span class="number">0x40f3f</span>, <span class="number">0x1f02</span>, <span class="number">0x31</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(r, m)</span>:</span> <span class="keyword">return</span> ((r &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span>) ^ (bin(r &amp; m).count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a, b, c, d</span><br><span class="line">    a = lfsr(a, ma)</span><br><span class="line">    b = lfsr(b, mb)</span><br><span class="line">    c = lfsr(c, mc)</span><br><span class="line">    d = lfsr(d, md)</span><br><span class="line">    [ao, bo, co, do] = [i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]</span><br><span class="line">    <span class="keyword">return</span> (ao*bo) ^ (bo*co) ^ (bo*do) ^ co ^ do</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genkey</span><span class="params">(nb)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nb*<span class="number">8</span>):</span><br><span class="line">        s += str(combine())</span><br><span class="line">    open(<span class="string">"data"</span>, <span class="string">"w+"</span>).write(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">genkey(<span class="number">128</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p><strong>data</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span> <span class="keyword">string</span> that comprises <span class="keyword">of</span> <span class="number">128</span>*<span class="number">1024</span>*<span class="number">8</span> bits(only <span class="literal">zero</span> <span class="keyword">or</span> <span class="literal">one</span>)</span><br></pre></td></tr></table></figure><h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>There are four LFSR in quiz.py and each round, four LFSR simultaneously compute four according output. Then the combination function combines these four bits and output the combination result into file data.</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Since LFSR is the basic knowledge for us, there will more no more explanation on it. So let’s see what we have  got from the files.</p><blockquote><p>the initial state length of each LFSR</p><p>the taps of each LFSR</p><p>a combination function</p><p>many rounds combination results</p></blockquote><p>It seems to be a simple quiz because we have already known the taps of each LFSR. However, each output of four LFSR is combined as one bit, from which we can hardly retrieve the outputs of four LFSR. If we use pure brute-force attack method, the complexity would be:</p><script type="math/tex; mode=display">O(2^{47})</script><p> Such a large scale. We must relate one or some output of four LFSR to the combination result and solve the each state independently. We can use a strategies called <strong>correlation attack</strong> in stream cipher.</p><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>We first look into each possible situation of four LFSR and write down the result.</p><div class="table-container"><table><thead><tr><th>ao</th><th>bo</th><th>co</th><th>do</th><th>combine</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>In the table, ao represents the single output of LFSR-1 and so on. It is very obvious that ao has 75% correlation with the combination output, and we also know that if we have the correct initial state of LFSR-1,  three out of four output of LFSR-1 will be the same as the combination bits. As a result, we can independently search the initial state of LFSR-1, and the correct initial state should be the fittest one. Now the complexity comes down to:</p><script type="math/tex; mode=display">O(2^{19}+2^{28})=O({2^{28}})</script><p>This is already considerable in brute-force attack method (I use approximately 3 hours with C++, half a day with python to solve). But sadly, outputs of other LFSR just has 50% correlation with the combination output (actually no correlation). We can look into the combination function:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ao*<span class="keyword">bo</span>) ^ (<span class="keyword">bo</span>*<span class="keyword">co</span>) ^ (<span class="keyword">bo</span>*<span class="keyword">do</span>) ^ <span class="keyword">co</span> ^ <span class="keyword">do</span></span><br></pre></td></tr></table></figure><p>And interestingly it can be transformed into:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ao*<span class="keyword">bo</span>) ^ ((<span class="keyword">bo</span>^<span class="number">1</span>) * (<span class="keyword">co</span>^<span class="keyword">do</span>))</span><br></pre></td></tr></table></figure><p>Calculating the XOR result of co and do by ourselves, we can surprisingly find that there is correlation between (co^do) and the combination result. Try to write down the table again.</p><div class="table-container"><table><thead><tr><th>ao</th><th>bo</th><th>co^do</th><th>combine</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>Again we can know from the table that (co^do) has 75% correlation with the combination output, which is the same as ao. There the complexity comes down again to:</p><script type="math/tex; mode=display">O(2^{19}+2^{9}+2^{19})=O(2^{20})</script><p>The complexity is very considerable now.</p><h2 id="Realization"><a href="#Realization" class="headerlink" title="Realization"></a>Realization</h2><p>Official realization</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ma, mb, mc, md = <span class="number">0x505a1</span>, <span class="number">0x40f3f</span>, <span class="number">0x1f02</span>, <span class="number">0x31</span></span><br><span class="line">key = open(<span class="string">"data"</span>).read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lfsr</span><span class="params">(r, m)</span>:</span> <span class="keyword">return</span> ((r &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xffffff</span>) ^ (bin(r &amp; m).count(<span class="string">'1'</span>) % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcR</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(x) == len(y)</span><br><span class="line">    cnt = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(x, y):</span><br><span class="line">        cnt += (i == j)</span><br><span class="line">    <span class="keyword">return</span> cnt / len(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brutea</span><span class="params">(nb)</span>:</span></span><br><span class="line">    relation, reala = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">19</span>):</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        a = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(nb * <span class="number">8</span>):</span><br><span class="line">            a = lfsr(a, ma)</span><br><span class="line">            s += str(a &amp; <span class="number">1</span>)</span><br><span class="line">        r = calcR(s, key[:nb * <span class="number">8</span>])</span><br><span class="line">        <span class="keyword">if</span> relation &lt; r:</span><br><span class="line">            relation, reala = r, i</span><br><span class="line">    print(reala, relation)</span><br><span class="line">    <span class="keyword">return</span> reala</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brutecd</span><span class="params">(nb)</span>:</span></span><br><span class="line">    relation, realc, reald = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">6</span>):</span><br><span class="line">        d = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">13</span>):</span><br><span class="line">            c = j</span><br><span class="line">            s = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(nb * <span class="number">8</span>):</span><br><span class="line">                c = lfsr(c, mc)</span><br><span class="line">                d = lfsr(d, md)</span><br><span class="line">                s += str((c &amp; <span class="number">1</span>) ^ (d &amp; <span class="number">1</span>))</span><br><span class="line">            r = calcR(s, key[:nb * <span class="number">8</span>])</span><br><span class="line">            <span class="keyword">if</span> relation &lt; r:</span><br><span class="line">                relation, realc, reald = r, j, i</span><br><span class="line">    print(realc, reald, relation)</span><br><span class="line">    <span class="keyword">return</span> realc, reald</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bruteb</span><span class="params">(nb, a_, c_, d_)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span> ** <span class="number">19</span>):</span><br><span class="line">        b = i</span><br><span class="line">        a, c, d = a_, c_, d_</span><br><span class="line">        s = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(nb * <span class="number">8</span>):</span><br><span class="line">            a = lfsr(a, ma)</span><br><span class="line">            b = lfsr(b, mb)</span><br><span class="line">            c = lfsr(c, mc)</span><br><span class="line">            d = lfsr(d, md)</span><br><span class="line">            [ao, bo, co, do] = [k &amp; <span class="number">1</span> <span class="keyword">for</span> k <span class="keyword">in</span> [a, b, c, d]]</span><br><span class="line">            s += str((ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do)</span><br><span class="line">        <span class="keyword">if</span> s == key[:nb * <span class="number">8</span>]:</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(start_time)</span><br><span class="line">    a = brutea(<span class="number">20</span>)</span><br><span class="line">    c, d = brutecd(<span class="number">20</span>)</span><br><span class="line">    b = bruteb(<span class="number">20</span>, a, c, d)</span><br><span class="line">    <span class="string">"De1CTF&#123;%s&#125;"</span> % (<span class="string">''</span>.join([hex(i)[<span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> [a, b, c, d]]))</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(<span class="string">"Used time:"</span>, end_time - start_time)</span><br><span class="line"><span class="comment"># De1CTF&#123;58bb578d5611363f&#125;</span></span><br></pre></td></tr></table></figure><p>Other challenges still remain confused.</p><h1 id="What-I-have-done"><a href="#What-I-have-done" class="headerlink" title="What I have done"></a>What I have done</h1><p>I spent half of my afternoon writing this article, and I still have a long way to go. Keep on learning IELTS and number theory.</p><h1 id="Things-to-Learn-and-Improve"><a href="#Things-to-Learn-and-Improve" class="headerlink" title="Things to Learn and Improve"></a>Things to Learn and Improve</h1><ul><li>How to use sage</li><li>Do a review on wangdibei</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://en.wikipedia.org/wiki/Correlation_attack" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Correlation_attack</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Only review in Crypto.&lt;/p&gt;
&lt;h1 id=&quot;nlfsr-unsolved&quot;&gt;&lt;a href=&quot;#nlfsr-unsolved&quot; class=&quot;headerlink&quot; title=&quot;nlfsr(unsolved)&quot;&gt;&lt;/a&gt;nlfsr(unsolve
      
    
    </summary>
    
    
    
      <category term="Review" scheme="https://buki-freak.github.io/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>天翼杯-2020-Writeup</title>
    <link href="https://buki-freak.github.io/2020/07/31/%E5%A4%A9%E7%BF%BC%E6%9D%AF-2020-Writeup/"/>
    <id>https://buki-freak.github.io/2020/07/31/%E5%A4%A9%E7%BF%BC%E6%9D%AF-2020-Writeup/</id>
    <published>2020-07-31T15:00:19.000Z</published>
    <updated>2020-08-03T03:24:09.259Z</updated>
    
    <content type="html"><![CDATA[<p>比赛排得很密，gkd 把 writeup 写了。</p><h1 id="easyRSA"><a href="#easyRSA" class="headerlink" title="easyRSA"></a>easyRSA</h1><p>签到题，对于每一次加密，明文空间小，于是直接遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n = ...</span><br><span class="line">cipher = ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">e = <span class="number">11299</span></span><br><span class="line">plaintext = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)):</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> string.printable:</span><br><span class="line">        <span class="keyword">if</span> pow(ord(s),e,n) == cipher[i]:</span><br><span class="line">            plaintext += s</span><br><span class="line">            print(plaintext)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="hardRSA"><a href="#hardRSA" class="headerlink" title="hardRSA"></a>hardRSA</h1><p>已知 d 低 539 位，q 为 510 位，计算低位 q 的方法可以直接获得 q。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_q</span><span class="params">(d0, kbits, e, n, p)</span>:</span></span><br><span class="line">    X = var(<span class="string">'X'</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, e+<span class="number">1</span>):</span><br><span class="line">        results = solve_mod([e*d0*X - k*(p<span class="number">-1</span>)*X*(n//p-X+<span class="number">1</span>) + (p<span class="number">-1</span>)*k*(n//p) == X], <span class="number">2</span>^kbits)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> results:</span><br><span class="line">            q0 = ZZ(x[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> n % q0 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> q0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    n = <span class="number">12723332779402711330767180202990021139894727917028981722242076998825097254419567024122271773380821224949951558669351311750240296591612098048129709925844660421849429715755474874708286508736369884566273719494870891070006251521469139401722700298201541140391493575314714966432624976434199682124684035067305114749262672684081617896579640435891181745346695293618235303178334371123418790204709073465264408888007492994820133128499094347122686903153588634296508454120927</span></span><br><span class="line">    e = <span class="number">7</span></span><br><span class="line">    p = <span class="number">3141886348112988339174865432179206412942588390228169645162293920470188882447855208783220899752887620221059861467348059334030873350571979462363834615231089</span></span><br><span class="line">    c = <span class="number">8696771272015513736887843395612361647314297287781507609196936354183211655364744684164300710583625473872942712063309507651496314800393009480421886926137403759228421858414833429980059903049311837014449093365911603108158352871851677457256058510822509157407703210866317472894586087554001158540951787167699161720491198674848526093644131709561995379565643716017359731201935855247285498574923656191121426618306186331615280461405913653781283860760013215603007314688132</span></span><br><span class="line">    d0 = <span class="number">0x414946b9c40728f9801e61e98ec6d17525cbe4163a5ffb8367b65c652ae4cc3abce62e70afbfb84fcf937b3119953b48922be19ef4312c4f3a88313368ca6c9b1d658b7</span></span><br><span class="line">    </span><br><span class="line">    nbits = n.nbits()</span><br><span class="line">    kbits = d0.nbits()</span><br><span class="line"></span><br><span class="line">    q = find_q(d0, kbits, e, n, p)</span><br><span class="line">    r = n // q // p</span><br><span class="line">    phi = (r - <span class="number">1</span>) * (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    d = gmpy2.invert(e,phi)</span><br><span class="line">    print(long_to_bytes(pow(c,d,n)))</span><br></pre></td></tr></table></figure><p><strong>ps：之后把推导过程补上</strong></p><h1 id="AliceHomework"><a href="#AliceHomework" class="headerlink" title="AliceHomework"></a>AliceHomework</h1><p>LLL 没跑出来，疑惑.jpg</p><h1 id="PolyCrypto"><a href="#PolyCrypto" class="headerlink" title="PolyCrypto"></a>PolyCrypto</h1><p>没时间看题。。。tcl</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比赛排得很密，gkd 把 writeup 写了。&lt;/p&gt;
&lt;h1 id=&quot;easyRSA&quot;&gt;&lt;a href=&quot;#easyRSA&quot; class=&quot;headerlink&quot; title=&quot;easyRSA&quot;&gt;&lt;/a&gt;easyRSA&lt;/h1&gt;&lt;p&gt;签到题，对于每一次加密，明文空间小，
      
    
    </summary>
    
    
    
      <category term="Writeup" scheme="https://buki-freak.github.io/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>3kctf-2020-Review</title>
    <link href="https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/"/>
    <id>https://buki-freak.github.io/2020/07/27/3kctf-2020-Review/</id>
    <published>2020-07-27T06:21:11.000Z</published>
    <updated>2020-08-03T03:26:54.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pyzzle1"><a href="#pyzzle1" class="headerlink" title="pyzzle1"></a>pyzzle1</h1><p>Given a cst tree code, use libcst package in python to transform it into source code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libcst <span class="keyword">import</span> *</span><br><span class="line">abc = Module(....</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'...'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(str(abc.code))</span><br></pre></td></tr></table></figure><p>Here is the source code in python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">"REDACTED"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    temp = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i]):</span><br><span class="line">            temp += <span class="string">"0"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp += <span class="string">"1"</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinaryToDecimal</span><span class="params">(binary)</span>:</span></span><br><span class="line">    string = int(binary, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># encryption</span></span><br><span class="line">PT_Ascii = [ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> plaintext]</span><br><span class="line"></span><br><span class="line">PT_Bin = [format(y, <span class="string">'08b'</span>) <span class="keyword">for</span> y <span class="keyword">in</span> PT_Ascii]</span><br><span class="line">PT_Bin = <span class="string">""</span>.join(PT_Bin)</span><br><span class="line"></span><br><span class="line">n = <span class="number">26936</span></span><br><span class="line">K1 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">K2 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line"></span><br><span class="line">L1 = PT_Bin[<span class="number">0</span>:n]</span><br><span class="line">R1 = PT_Bin[n::]</span><br><span class="line"></span><br><span class="line">f1 = exor(R1, K1)</span><br><span class="line">R2 = exor(f1, L1)</span><br><span class="line">L2 = R1</span><br><span class="line"></span><br><span class="line">f2 = exor(R2, K2)</span><br><span class="line">R3 = exor(f2, L2)</span><br><span class="line">L3 = R2</span><br><span class="line"></span><br><span class="line">R3 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">L3 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">cipher = L3+R3</span><br><span class="line"></span><br><span class="line"><span class="comment"># # decryption (redacted)</span></span><br><span class="line"><span class="comment"># plaintext = L6+R6</span></span><br><span class="line"><span class="comment"># plaintext = int(plaintext, 2)</span></span><br><span class="line"><span class="comment"># plaintext = binascii.unhexlify('%x' % plaintext)</span></span><br><span class="line"><span class="comment"># print(plaintext)</span></span><br></pre></td></tr></table></figure><p>This is a pretty easy structure, we can easily recover plaintext by:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exor</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    temp = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i]):</span><br><span class="line">            temp += <span class="string">"0"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp += <span class="string">"1"</span></span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">26936</span></span><br><span class="line">K1 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">K2 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">R3 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line">L3 = <span class="string">''''''</span> <span class="comment"># Too long to show</span></span><br><span class="line"></span><br><span class="line">R2 = L3</span><br><span class="line">L2 = exor(exor(K2, R2), R3)</span><br><span class="line"></span><br><span class="line">R1 = L2</span><br><span class="line">L1 = exor(exor(K1, R1), R2)</span><br><span class="line"></span><br><span class="line">plaintext = L1+R1</span><br><span class="line">plaintext = int(plaintext, <span class="number">2</span>)</span><br><span class="line">plaintext = binascii.unhexlify(<span class="string">'%x'</span> % plaintext)</span><br><span class="line">plaintext = binascii.unhexlify(plaintext)</span><br><span class="line">print(plaintext)</span><br></pre></td></tr></table></figure><p>The flag is : 3k{almost_done_shizzle_up_my_nizzle}</p><h1 id="Once-upon-a-time"><a href="#Once-upon-a-time" class="headerlink" title="Once_upon_a_time"></a>Once_upon_a_time</h1><p>Given a program and encrypted flag:</p><blockquote><p>scss : program entrance</p><p>main.c</p><p>cipher.c</p><p>flag_encrypted</p><p>…</p></blockquote><p>Excellent realization of LFSR and block cipher encryption in C. </p><p>We notice that the initial vector is fixed, 0xa2 :) Addtionally, the key is fixed too, which means we can always get the same key stream. Moreover, I find something wired in cipher.c:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">ECB:</span></span><br><span class="line">    temp_ciphertext = temp_keystream ^ temp_plaintext;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>We can create a file with only ‘\x00’ and encrypt it in ECB mode to get the keystream. </p><p>Since there are five modes, we can only try every situations.</p><p>Woooool, finally catch ya! OFB!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: plaintext = <span class="string">''</span>                                                         </span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">113</span>): </span><br><span class="line">    ...:     iv = iv ^ keystream[i] </span><br><span class="line">    ...:     temp = iv ^ cipher[i] </span><br><span class="line">    ...:     plaintext += chr(temp) </span><br><span class="line">    ...:                                                                        </span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: plaintext                                                              </span><br><span class="line">Out[<span class="number">22</span>]: <span class="string">'3k&#123;my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail&#125;'</span></span><br></pre></td></tr></table></figure><p>The flag is : 3k{my_hands_are_registered_as_lethal_weapons_that_means_we_get_into_a_fight_i_accidentally_kill_you_i_go_to_jail}</p><h1 id="You-shall-not-get-my-cookies"><a href="#You-shall-not-get-my-cookies" class="headerlink" title="You shall not get my cookies"></a>You shall not get my cookies</h1><p>Given an example cipher, and if the cipher can be correctly decrypted, it will send “Nop” back.</p><p>I follow the write up here: <a href="https://ctftime.org/writeup/22602" target="_blank" rel="noopener">https://ctftime.org/writeup/22602</a></p><p>Notice that there is an error in the write up above: if the length of a block is 16 bytes, it will be appended a block of sixteen ‘\x16’ according to PKCS#7 padding principle.</p><p>Here is my exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">target = <span class="string">'youshallnotgetmycookies.3k.ctf.to'</span></span><br><span class="line">port = <span class="number">13337</span></span><br><span class="line"></span><br><span class="line">cipher = <span class="string">"6F6A6A2C6E780D070A19001707060C0D"</span></span><br><span class="line"></span><br><span class="line">suffix = <span class="string">''</span></span><br><span class="line">fake_iv = <span class="string">''</span></span><br><span class="line">dc = <span class="string">''</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">17</span>):</span><br><span class="line">        <span class="keyword">assert</span>(len(dc) == <span class="number">2</span>*(i<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">            guess = hex(j)[<span class="number">2</span>:].upper().zfill(<span class="number">2</span>)</span><br><span class="line">            fake_iv = <span class="string">'00'</span> * (<span class="number">16</span>-i) + guess + suffix</span><br><span class="line">            print(<span class="string">'[-]'</span> + fake_iv)</span><br><span class="line">            p = remote(target, port)</span><br><span class="line">            p.sendlineafter(<span class="string">'So... whats your cookie: '</span>, fake_iv + cipher)</span><br><span class="line">            res = p.recvall(timeout=<span class="number">4</span>)</span><br><span class="line">            p.close()</span><br><span class="line">            res = res.decode()</span><br><span class="line">            <span class="keyword">if</span>  len(res) == <span class="number">11</span>:</span><br><span class="line">                pad = bytes([i])</span><br><span class="line">                dc = hex(int(guess, <span class="number">16</span>) ^ bytes_to_long(pad))[<span class="number">2</span>:].upper().zfill(<span class="number">2</span>) + dc</span><br><span class="line">                suffix = hex(int(dc, <span class="number">16</span>) ^ bytes_to_long(bytes([(i+<span class="number">1</span>)]) * i))[<span class="number">2</span>:].upper().zfill(i*<span class="number">2</span>)</span><br><span class="line">                print(<span class="string">'[-]  D(C1) '</span>+ dc)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'[-]  D(C1) '</span>+ dc)</span><br><span class="line"><span class="keyword">except</span> pwnlib.exception.PwnlibException:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1C091F451A0B070D00130A1D0D0C0607  for the first block to be d(C2)</span></span><br><span class="line"><span class="comment"># B0A608DDC37A458EEC0B74D37E888E8A  for the second block</span></span><br><span class="line"><span class="comment"># ...3B143145885BB42C94 for the third block</span></span><br><span class="line"><span class="comment"># C2</span></span><br><span class="line"><span class="comment"># 90C560B2A01529EF986E54B016E1FEAA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C1</span></span><br><span class="line"><span class="comment"># 6F6A6A2C6E780D070A19001707060C0D</span></span><br><span class="line"><span class="comment"># Calculate d(C1)</span></span><br><span class="line"><span class="comment"># 218A7AEECEFB49CADF3D227AD84A21CF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate C0</span></span><br><span class="line"><span class="comment"># 6CEB0A82ABDB06ABAB50471BB46A63A6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The whole fake cipher:</span></span><br><span class="line"><span class="comment"># 6CEB0A82ABDB06ABAB50471BB46A63A66F6A6A2C6E780D070A19001707060C0D90C560B2A01529EF986E54B016E1FEAA</span></span><br></pre></td></tr></table></figure><p>It cost 2 hours running this script twice.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pyzzle1&quot;&gt;&lt;a href=&quot;#pyzzle1&quot; class=&quot;headerlink&quot; title=&quot;pyzzle1&quot;&gt;&lt;/a&gt;pyzzle1&lt;/h1&gt;&lt;p&gt;Given a cst tree code, use libcst package in pytho
      
    
    </summary>
    
    
    
      <category term="Review" scheme="https://buki-freak.github.io/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>2020-First-Half-Review</title>
    <link href="https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/"/>
    <id>https://buki-freak.github.io/2020/06/30/2020-First-Half-Review/</id>
    <published>2020-06-30T15:23:46.000Z</published>
    <updated>2020-07-17T02:47:27.086Z</updated>
    
    <content type="html"><![CDATA[<p>2020 已经过半，新年的钟声仿佛仍然萦绕在耳边。时间过得太快，留下的太少。</p><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>今年真的很特别啊，二月份的时候还抱着回学校上课的想法，现在已经上了一学期的网课。对于网课和回学校上课，我是偏后者的。要知道，待在家里学习效率不到学校的十分之一：）不过还好，现在好像慢慢习惯下去了 hhhhh</p><p>本来是二月底开学的，不过学校说推迟开学（不带网课的那种）。好吧，等到三月份，盼了许久谁知改成网课（直接裂开&gt;_&lt;，网课==自学。不得不说，这半年处于真·白学阶段，白学能力提高了不少。</p><p>一月主要在学了 Matlab 编程和 Latex，从基本语法到画图，再到如何用 Latex 写出一篇 nice 的论文。学这个主要是为了准备数模，不过听说毕业论文要用 Latex 2333。因为寒假前有个朋友拉数模美赛，自己感觉想试试（说不定好好学能拿个奖。于是就报名去了，报名费也不便宜。后面去听了听那边的基础课，建模对数学要求还是挺高的，有点懵。后面朋友说让我学学 Matlab 编程。基础学下来其实也不用花很长时间，但是拖着拖着到二月份去了。不过回想那个时候，自己跟着网上教程走，还是不错的。</p><p>美赛在三月份，基础搞好了以后就开始放飞自我了（真就只搞了基础 wdt。其实主要是发现自己太久没搞学科了，于是又跑来这边学学。掏出一个《快乐的 Linux 命令行》，也忘了是谁发给我的了，系统地过一遍 Linux。从文件系统跳转到 vim 处理文本 再到软件包管理，最后 shell 编程，途中顺便捡回了正则表达式。看的时候其实真的有很大感触。看懂命令，提高主动性，这是我悟出的一点。最近选课突然发现下学期有一门叫《操作系统实践》的课，讲得就是 Linux 命令2333</p><p>美赛那三天每天只睡了6个小时，负责编程。另外两个大佬建模分析等等（这里的等等省略了许多…… wtcl 代码都是队友帮我找的。当时其实挺自责的，到后两天我才开始发挥作用。最终还是两位大佬带着我一个菜鸡勉强拿了个奖。求下年别再拉我了。</p><p>到了三月底就开始上课了，通常第一个星期都是介绍课程，必须要听啊，种种原因。一开始的那几个星期还是很认真的听课的，后面就不忍直视了。school 特色原因，水课很多。这时候网课的优势就凸显出来了。话虽这么说，但是英语还是得好好学。</p><p>四月份开始准备学校的新生赛。Crypto 不会出题。于是直接用了上一年校赛的模板，一波三折，最后强行凑出三道题，难度还不小，直接丢到平台，没人做出来 555</p><p>大概四月中旬，家里人出事情了，心态有点崩，之后算是勉勉强强地在学习吧。</p><p>到了五月份，整个人勤快了，学得挺快。把 Crypto 的基础过了一遍，打下了几场比赛，看了不少paper，收获还是挺大的，可惜没有进到线下。一个队伍，三缺一，加上进线下的种种困难，离目标还是很远啊。</p><p>六月份主要在准备各科的考试，全力复习，毕竟还是想混个奖学金。现在想想，不知不觉，已经在家半年。。。希望快快开学。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>大学已经过去一半，庆幸自己这一年没有浪费，但也很可惜，没有达到自己预期的目标。怎么说呢，自己当初的目标其实已经改变了吧，现实中的变化的太快，而且自己当初的决心似乎也没有那么坚定。走一步看一步吧，毕竟不想浪费这几年宝贵的时间。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>用某人的话：”少说话，多做事。光说不练假把式，要勤奋，勇于实践。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020 已经过半，新年的钟声仿佛仍然萦绕在耳边。时间过得太快，留下的太少。&lt;/p&gt;
&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;p&gt;今年真的很特别啊，二月份的时候还抱着回学校上课的
      
    
    </summary>
    
    
    
      <category term="Personal Development" scheme="https://buki-freak.github.io/tags/Personal-Development/"/>
    
  </entry>
  
  <entry>
    <title>das-CTF&amp;GK-CTF-2020-Writeup</title>
    <link href="https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/"/>
    <id>https://buki-freak.github.io/2020/05/24/das-CTF-GK-CTF-2020-Writeup/</id>
    <published>2020-05-24T01:30:24.000Z</published>
    <updated>2020-08-03T03:26:26.371Z</updated>
    
    <content type="html"><![CDATA[<p>Only writeup in Crypto.</p><h1 id="GKCTF"><a href="#GKCTF" class="headerlink" title="GKCTF"></a>GKCTF</h1><h2 id="小学生的密码学-Solved"><a href="#小学生的密码学-Solved" class="headerlink" title="小学生的密码学(Solved)"></a>小学生的密码学(Solved)</h2><p>Pretty easy affince cipher. Both keys are given.</p><h2 id="babycrypto-Solved"><a href="#babycrypto-Solved" class="headerlink" title="babycrypto(Solved)"></a>babycrypto(Solved)</h2><p>Partial high bits of p is known.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use sage to run the script</span></span><br><span class="line"><span class="comment"># Reference: https://www.jianshu.com/p/1a0e876d5929</span></span><br><span class="line"><span class="keyword">from</span> sage.all <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># All variables are in hex</span></span><br><span class="line">n = <span class="number">0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Padding zeros to p --&gt; p4</span></span><br><span class="line">p4 = <span class="number">0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000</span></span><br><span class="line">cipher = <span class="number">1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361</span></span><br><span class="line">e2 = <span class="number">65537</span></span><br><span class="line">kbits = <span class="number">128</span>  <span class="comment"># kbits represent the loss bits</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))  <span class="comment"># Create a polynomial ring</span></span><br><span class="line">f = x + p4</span><br><span class="line">roots = f.small_roots(X=<span class="number">2</span>^kbits, beta=<span class="number">0.4</span>)</span><br><span class="line"><span class="keyword">if</span> roots:        </span><br><span class="line">    p = p4 + int(roots[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">assert</span> n % p == <span class="number">0</span></span><br><span class="line">    q = n / int(p)</span><br><span class="line">    phin = (p<span class="number">-1</span>)*(q<span class="number">-1</span>)</span><br><span class="line">    d = inverse_mod(e2,phin)</span><br><span class="line">    flag = pow(cipher,d,n)</span><br><span class="line">    <span class="keyword">print</span> long_to_bytes(flag)</span><br></pre></td></tr></table></figure><h2 id="汉字的密码-Solved"><a href="#汉字的密码-Solved" class="headerlink" title="汉字的密码(Solved)"></a>汉字的密码(Solved)</h2><p>当铺密码+Substitution Cipher</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dic = [<span class="number">66</span>, <span class="number">74</span>, <span class="number">62</span>, <span class="number">67</span>, <span class="number">118</span>, <span class="number">83</span>, <span class="number">72</span>, <span class="number">77</span>, <span class="number">86</span>, <span class="number">55</span>, <span class="number">71</span>, <span class="number">57</span>, <span class="number">82</span>, <span class="number">57</span>, <span class="number">64</span>, <span class="number">63</span>, <span class="number">51</span>, <span class="number">107</span>]</span><br><span class="line">delta = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    print(chr(i+delta), end=<span class="string">""</span>)</span><br><span class="line">    delta += <span class="number">1</span></span><br><span class="line"><span class="comment"># FLAG&#123;YOU_ARE_GOOD&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Backdoor-Unsolved"><a href="#Backdoor-Unsolved" class="headerlink" title="Backdoor(Unsolved)"></a>Backdoor(Unsolved)</h2><p>Remain confused</p><h1 id="DASCTF"><a href="#DASCTF" class="headerlink" title="DASCTF"></a>DASCTF</h1><h2 id="bbcrypto-Solved"><a href="#bbcrypto-Solved" class="headerlink" title="bbcrypto(Solved)"></a>bbcrypto(Solved)</h2><p><strong>quiz.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> A,SALT</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m, a, si)</span>:</span></span><br><span class="line">    c=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(m)):</span><br><span class="line">        c+=hex(((ord(m[i])) * a + ord(next(si))) % <span class="number">128</span>)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    m = <span class="string">'flag&#123;********************************&#125;'</span></span><br><span class="line">    a = A</span><br><span class="line">    salt = SALT</span><br><span class="line">    <span class="keyword">assert</span>(len(salt)==<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span>(salt.isalpha())</span><br><span class="line">    si = cycle(salt.lower())</span><br><span class="line">    print(<span class="string">"明文内容为："</span>)</span><br><span class="line">    print(m)</span><br><span class="line">    print(<span class="string">"加密后的密文为："</span>)</span><br><span class="line">    c=encrypt(m, a, si)</span><br><span class="line">    print(c)</span><br><span class="line">    <span class="comment">#加密后的密文为：</span></span><br><span class="line">    <span class="comment">#177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d</span></span><br></pre></td></tr></table></figure><p>The length of salt is 3 and we have already known that the plain starts with “flag{“. Solve linear congruent equations to get the salt.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">"177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d"</span></span><br><span class="line">li_c = [int(c[i:i+<span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(c), <span class="number">2</span>)]</span><br><span class="line"><span class="comment"># print(li_c)</span></span><br><span class="line">m = <span class="string">"flag&#123;"</span></span><br><span class="line">d_c = li_c[<span class="number">3</span>] - li_c[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># print(d_c)</span></span><br><span class="line">d_m = ord(m[<span class="number">3</span>]) - ord(m[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># print(d_m)  # a = 57 mod 128</span></span><br><span class="line">a = <span class="number">57</span></span><br><span class="line"><span class="comment"># print((li_c[0] - a * ord(m[0])) % 128)</span></span><br><span class="line"><span class="comment"># print(chr(97))  y1 = 'a'</span></span><br><span class="line"><span class="comment"># print((li_c[1] - a * ord(m[1])) % 128)</span></span><br><span class="line"><span class="comment"># print(chr(104)) y2 = 'h'</span></span><br><span class="line"><span class="comment"># print((li_c[2] - a * ord(m[2])) % 128)</span></span><br><span class="line"><span class="comment"># print(chr(104))  # y3 = 'h'</span></span><br><span class="line"><span class="comment"># print((li_c[3] - a * ord(m[3])) % 128)</span></span><br><span class="line">m = <span class="string">""</span></span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">inv_a = invert(a, <span class="number">128</span>)</span><br><span class="line">key = itertools.cycle(<span class="string">"ahh"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li_c:</span><br><span class="line">    m += chr(((i - ord(next(key))) * inv_a) % <span class="number">128</span>)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h2 id="encrypt-img-Solved"><a href="#encrypt-img-Solved" class="headerlink" title="encrypt_img(Solved)"></a>encrypt_img(Solved)</h2><p><strong>quiz.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> Key</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line">Plaintext2 = <span class="string">"ThisIsAEasyGame"</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RC4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Key)</span>:</span></span><br><span class="line">        self.S = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]  <span class="comment"># 0 - 255</span></span><br><span class="line">        self.K = [ord(Key[i % len(Key)])*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]   <span class="comment"># KEY * 2(0-255)</span></span><br><span class="line">        self.I, self.J = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        self.KSA()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KSA</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            j = (i+self.K[i]+self.S[i]) % <span class="number">256</span></span><br><span class="line">            self.S[i], self.S[j] = self.S[j], self.S[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.I = (self.I+<span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        self.J = (self.J+self.S[self.I]) % <span class="number">256</span></span><br><span class="line">        self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J]</span><br><span class="line">        tmp = (self.S[self.J] + self.S[self.I]) % <span class="number">256</span></span><br><span class="line">        <span class="keyword">return</span> self.S[tmp]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encrypt</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, plain)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> cnt</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        self.rc4 = RC4(Key)</span><br><span class="line">        self.testRC4(plain)</span><br><span class="line">        flag_file = Image.open(<span class="string">r"flag.png"</span>)</span><br><span class="line">        img = array(flag_file)</span><br><span class="line">        self.enc(img)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testRC4</span><span class="params">(self, plain)</span>:</span></span><br><span class="line">        ciphertext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> plain:</span><br><span class="line">            ciphertext = (ciphertext &lt;&lt; <span class="number">8</span>)+ord(i) ^ self.rc4.next()</span><br><span class="line">        print(<span class="string">"ciphertext&#123;&#125; = &#123;&#125;"</span>.format(cnt, ciphertext))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        a, b, _ = img.shape</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">                pixel = img[x, y]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    pixel[i] = pixel[i] ^ self.rc4.next()</span><br><span class="line">                img[x][y] = pixel</span><br><span class="line">        enc = Image.fromarray(img)</span><br><span class="line">        enc.save(<span class="string">"enc&#123;&#125;.png"</span>.format(cnt))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Encrypt(Plaintext1)</span><br><span class="line">Encrypt(Plaintext2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ciphertext1 = 12078640933356268898100798377710191641</span></span><br><span class="line"><span class="comment"># ciphertext2 = 79124196547094980420644350061749775</span></span><br></pre></td></tr></table></figure><p><strong>enc1.png</strong></p><p><strong>enc2.png</strong></p><p><strong>Stream Cipher Insertion Attack</strong></p><p>Such a pity that I didn’t figure it out at that time. From two groups of plaintexts and ciphertexts we can recover keystream at the start. However, the second keystream has one bit less than the first one, from which we easily can retrieve m0, then k1, after that m1 and so on.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">plaintext1 = "RC4IsInteresting"</span></span><br><span class="line"><span class="string">plaintext2 = "ThisIsAEasyGame"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ciphertext1 = 12078640933356268898100798377710191641</span></span><br><span class="line"><span class="string">ciphertext2 = 79124196547094980420644350061749775</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">key1 = []</span></span><br><span class="line"><span class="string">for i in range(len(plaintext1) - 1, -1, -1):</span></span><br><span class="line"><span class="string">     key1 = [ord(plaintext1[i]) ^ (ciphertext1 &amp; 0xff)] + key1</span></span><br><span class="line"><span class="string">     ciphertext1 &gt;&gt;= 8</span></span><br><span class="line"><span class="string">print(key1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">key2 = []</span></span><br><span class="line"><span class="string">for i in range(len(plaintext2) - 1, -1, -1):</span></span><br><span class="line"><span class="string">     key2 = [ord(plaintext2[i]) ^ (ciphertext2 &amp; 0xff)] + key2</span></span><br><span class="line"><span class="string">     ciphertext2 &gt;&gt;= 8</span></span><br><span class="line"><span class="string">print(key2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106, 126]</span></span><br><span class="line"><span class="string"># [91, 85, 118, 176, 158, 228, 216, 21, 145, 123, 89, 181, 165, 203, 106]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># Suppose the bit length of the flag.png is n bits, key1 and key2 can be written like:</span></span><br><span class="line"><span class="comment"># key1: k1, k2, ..., kn</span></span><br><span class="line"><span class="comment"># key2: k0, k1, ..., k(n-1)</span></span><br><span class="line"><span class="comment"># Above we have already known k0 is 126, which is the last key of plaintext2,</span></span><br><span class="line"><span class="comment"># we can retrieve m0, then k1, after that m1 and so on</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">img1 = array(Image.open(<span class="string">r"./enc1.png"</span>))</span><br><span class="line">img2 = array(Image.open(<span class="string">r"./enc2.png"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recovery_img</span><span class="params">(im1, im2, k)</span>:</span></span><br><span class="line">    x1, y1, z1 = im1.shape</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(x1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(y1):</span><br><span class="line">            pixel1 = im1[i, j]</span><br><span class="line">            pixel2 = im2[i, j]</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                pixel2[_] = pixel2[_] ^ k</span><br><span class="line">                k = pixel1[_] ^ pixel2[_]</span><br><span class="line">    im2 = Image.fromarray(im2)</span><br><span class="line">    im2.save(<span class="string">"dec.png"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">recovery_img(img1, img2, <span class="number">126</span>)</span><br></pre></td></tr></table></figure><h2 id="babyLCG-Solved"><a href="#babyLCG-Solved" class="headerlink" title="babyLCG(Solved)"></a>babyLCG(Solved)</h2><p><strong>quiz.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCG</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = getRandomNBitInteger(<span class="number">32</span>)</span><br><span class="line">        self.b = getRandomNBitInteger(<span class="number">32</span>)</span><br><span class="line">        self.m = getPrime(<span class="number">32</span>)</span><br><span class="line">        self.seed = getRandomNBitInteger(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.seed = (self.a*self.seed+self.b) % self.m</span><br><span class="line">        <span class="keyword">return</span> self.seed &gt;&gt; <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"a = &#123;&#125;\nb = &#123;&#125;\nm = &#123;&#125;"</span>.format(self.a, self.b, self.m))</span><br><span class="line">        print(<span class="string">"state1 = &#123;&#125;"</span>.format(self.next()))</span><br><span class="line">        print(<span class="string">"state2 = &#123;&#125;"</span>.format(self.next()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DH</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lcg = LCG()</span><br><span class="line">        self.lcg.output()</span><br><span class="line">        self.g = getRandomNBitInteger(<span class="number">128</span>)</span><br><span class="line">        self.m = getPrime(<span class="number">256</span>)</span><br><span class="line">        self.A, self.a = self.gen_AB()</span><br><span class="line">        self.B, self.b = self.gen_AB()</span><br><span class="line">        self.key = pow(self.A, self.b, self.m)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            x += <span class="string">'1'</span> <span class="keyword">if</span> self.lcg.next() % <span class="number">2</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">return</span> pow(self.g, int(x, <span class="number">2</span>), self.m), int(x, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DH = DH()</span><br><span class="line">flag = bytes_to_long(flag)</span><br><span class="line">print(<span class="string">"g = &#123;&#125;\nA = &#123;&#125;\nB = &#123;&#125;\nM = &#123;&#125;"</span>.format(DH.g, DH.A, DH.B, DH.m))</span><br><span class="line">print(<span class="string">"Cipher = &#123;&#125;"</span>.format(flag ^ DH.key))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = 3844066521</span></span><br><span class="line"><span class="string">b = 3316005024</span></span><br><span class="line"><span class="string">m = 2249804527</span></span><br><span class="line"><span class="string">state1 = 16269</span></span><br><span class="line"><span class="string">state2 = 4249</span></span><br><span class="line"><span class="string">g = 183096451267674849541594370111199688704</span></span><br><span class="line"><span class="string">A = 102248652770540219619953045171664636108622486775480799200725530949685509093530</span></span><br><span class="line"><span class="string">B = 74913924633988481450801262607456437193056607965094613549273335198280176291445</span></span><br><span class="line"><span class="string">M = 102752586316294557951738800745394456033378966059875498971396396583576430992701</span></span><br><span class="line"><span class="string">Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>LCG+Diffie Hellman Exchange Key</strong></p><p>The seed is too small ,as a result, we use brute-force attack to get the seed and recover the key. When we XOR the cipher with the key, the plain is figured out.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = 3844066521</span></span><br><span class="line"><span class="string">b = 3316005024</span></span><br><span class="line"><span class="string">m = 2249804527</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCG</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a = <span class="number">3844066521</span></span><br><span class="line">        self.b = <span class="number">3316005024</span></span><br><span class="line">        self.m = <span class="number">2249804527</span></span><br><span class="line">        self.seed = <span class="number">714405490</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.seed = (self.a*self.seed+self.b) % self.m</span><br><span class="line">        <span class="keyword">return</span> self.seed &gt;&gt; <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"a = &#123;&#125;\nb = &#123;&#125;\nm = &#123;&#125;"</span>.format(self.a, self.b, self.m))</span><br><span class="line">        print(<span class="string">"state1 = &#123;&#125;"</span>.format(self.next()))</span><br><span class="line">        print(<span class="string">"state2 = &#123;&#125;"</span>.format(self.next()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DH</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lcg = LCG()</span><br><span class="line">        self.lcg.output()</span><br><span class="line">        self.g = <span class="number">183096451267674849541594370111199688704</span></span><br><span class="line">        self.m = <span class="number">102752586316294557951738800745394456033378966059875498971396396583576430992701</span></span><br><span class="line">        self.A, self.a = self.gen_AB()  <span class="comment"># a private key</span></span><br><span class="line">        self.B, self.b = self.gen_AB()  <span class="comment"># b private key</span></span><br><span class="line">        self.key = pow(self.A, self.b, self.m)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">64</span>):</span><br><span class="line">            x += <span class="string">'1'</span> <span class="keyword">if</span> self.lcg.next() % <span class="number">2</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">return</span> pow(self.g, int(x, <span class="number">2</span>), self.m), int(x, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def next(x):</span></span><br><span class="line"><span class="string">    return (x * a + b) % m</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def brute_force():</span></span><br><span class="line"><span class="string">    for i in range(1&lt;&lt;32):</span></span><br><span class="line"><span class="string">        if i % 10000000 == 0:</span></span><br><span class="line"><span class="string">            print("count:", i)</span></span><br><span class="line"><span class="string">        res = next(i)</span></span><br><span class="line"><span class="string">        if (res &gt;&gt; 16) == 16269 and (next(res) &gt;&gt; 16) == 4249:</span></span><br><span class="line"><span class="string">            print(i)</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DH = DH()</span><br><span class="line">cipher = <span class="number">13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703</span></span><br><span class="line">print(<span class="string">"g = &#123;&#125;\nA = &#123;&#125;\nB = &#123;&#125;\nM = &#123;&#125;"</span>.format(DH.g, DH.A, DH.B, DH.m))</span><br><span class="line">print(<span class="string">"flag = &#123;&#125;"</span>.format(cipher ^ DH.key))</span><br><span class="line"><span class="comment"># flag = 13040004482819966666226297285938773653367957972934959074317939536564198335643452104954492541</span></span><br><span class="line"><span class="comment"># flag&#123;4dfe14e0c6c21ffcf5a3b4f0ed1911f6&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">a = 3844066521</span></span><br><span class="line"><span class="string">b = 3316005024</span></span><br><span class="line"><span class="string">m = 2249804527</span></span><br><span class="line"><span class="string">state1 = 16269</span></span><br><span class="line"><span class="string">state2 = 4249</span></span><br><span class="line"><span class="string">g = 183096451267674849541594370111199688704</span></span><br><span class="line"><span class="string">A = 102248652770540219619953045171664636108622486775480799200725530949685509093530</span></span><br><span class="line"><span class="string">B = 74913924633988481450801262607456437193056607965094613549273335198280176291445</span></span><br><span class="line"><span class="string">M = 102752586316294557951738800745394456033378966059875498971396396583576430992701</span></span><br><span class="line"><span class="string">Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="Knapsack-Solved"><a href="#Knapsack-Solved" class="headerlink" title="Knapsack(Solved)"></a>Knapsack(Solved)</h2><p><strong>quiz.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genKey</span><span class="params">(length)</span>:</span></span><br><span class="line">    A, B = getPrime(<span class="number">64</span>), getPrime(<span class="number">1025</span>)</span><br><span class="line"></span><br><span class="line">    Rn = getPrime(<span class="number">1024</span>)</span><br><span class="line">    key1 = [Rn//<span class="number">2</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length+<span class="number">1</span>)]</span><br><span class="line">    key2 = [i*A % B <span class="keyword">for</span> i <span class="keyword">in</span> key1]</span><br><span class="line">    <span class="keyword">return</span> key1,key2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(text,key)</span>:</span></span><br><span class="line">    Sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        Sum+=int(text[i])*key[i]</span><br><span class="line">    <span class="keyword">return</span> Sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(Ciper,Key)</span>:</span></span><br><span class="line">    f1=open(<span class="string">"pub.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Key)):</span><br><span class="line">        f1.write(str(Key[i])+<span class="string">'\n'</span>)</span><br><span class="line">    f2=open(<span class="string">"cip.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">    f2.write(hex(Ciper))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FLAG = bin(bytes_to_long(flag.encode()))[<span class="number">2</span>:]</span><br><span class="line">Key1,Key2 = genKey(len(FLAG))</span><br><span class="line">Ciper = encrypt(FLAG,Key1)</span><br><span class="line">save(Ciper,Key2)</span><br></pre></td></tr></table></figure><p><strong>cip.txt</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">a</span> <span class="keyword">long</span> hex <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p><strong>pub.txt</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1015 </span>public keys</span><br></pre></td></tr></table></figure><p>The last few key in pub.txt is too small, which actually is the original private key. We can use them to recover the original private key.</p><h2 id="backpacker-Unsolved"><a href="#backpacker-Unsolved" class="headerlink" title="backpacker(Unsolved)"></a>backpacker(Unsolved)</h2><p>Remain confused</p><h1 id="What-I-have-done"><a href="#What-I-have-done" class="headerlink" title="What I have done"></a><strong>What I have done</strong></h1><p>Finish learning symmetric cipher and the first chapter of Network Introduction. </p><h1 id="Things-to-Improve"><a href="#Things-to-Improve" class="headerlink" title="Things to Improve"></a>Things to Improve</h1><ul><li>Don’t be panic when encountering a challenge that is never met</li><li>Be more concentrated on study</li><li>LLL algorithm</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Only writeup in Crypto.&lt;/p&gt;
&lt;h1 id=&quot;GKCTF&quot;&gt;&lt;a href=&quot;#GKCTF&quot; class=&quot;headerlink&quot; title=&quot;GKCTF&quot;&gt;&lt;/a&gt;GKCTF&lt;/h1&gt;&lt;h2 id=&quot;小学生的密码学-Solved&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Writeup" scheme="https://buki-freak.github.io/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>Npu-CTF-2020-Review</title>
    <link href="https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/"/>
    <id>https://buki-freak.github.io/2020/05/12/Npu-CTF-2020-Review/</id>
    <published>2020-05-12T13:20:15.000Z</published>
    <updated>2020-08-03T03:26:42.361Z</updated>
    
    <content type="html"><![CDATA[<p>Only review in Crypto.</p><h1 id="What-does-the-tag-mean"><a href="#What-does-the-tag-mean" class="headerlink" title="What does the tag mean"></a>What does the tag mean</h1><div class="table-container"><table><thead><tr><th>Status</th><th>Description</th></tr></thead><tbody><tr><td>Solved</td><td>Solved in the competition</td></tr><tr><td>Unlved</td><td>Unsolved in the competition</td></tr></tbody></table></div><h1 id="Mersenne-Twister-unsolved"><a href="#Mersenne-Twister-unsolved" class="headerlink" title="Mersenne Twister(unsolved)"></a>Mersenne Twister(unsolved)</h1><p>This challenge is related to Mersenne Twister Encryption. However, there are differences between them exactly. Here is the file:</p><p><strong>Mersenne Twiser.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify , unhexlify</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag ,seed</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> len(flag) == <span class="number">26</span></span><br><span class="line"><span class="keyword">assert</span> flag[:<span class="number">7</span>] == <span class="string">'npuctf&#123;'</span></span><br><span class="line"><span class="keyword">assert</span> flag[<span class="number">-1</span>] == <span class="string">'&#125;'</span></span><br><span class="line"></span><br><span class="line">XOR = <span class="keyword">lambda</span> s1 ,s2 : bytes([x1 ^ x2 <span class="keyword">for</span> x1 ,x2 <span class="keyword">in</span> zip(s1 , s2)])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mt73991</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , seed)</span>:</span></span><br><span class="line">        self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.srand()</span><br><span class="line">        self.generate()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">            self.state[i+<span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">            self.state[i+<span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">            y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i+<span class="number">1</span>)%<span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">                temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">            self.state[i] = temp</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getramdanbits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        bits = self.Next(self.state[self.flag]).to_bytes(<span class="number">4</span> , <span class="string">'big'</span>)</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self , tmp)</span>:</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(key , plain)</span>:</span></span><br><span class="line">    tmp = md5(plain).digest()</span><br><span class="line">    <span class="keyword">return</span> hexlify(XOR(tmp , key))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    flag = flag.encode()</span><br><span class="line">    random = mt73991(seed)</span><br><span class="line">    f = open(<span class="string">'./cipher.txt'</span> , <span class="string">'wb'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">        key = <span class="string">b''</span>.join([random.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">        cipher = encrypt(key , chr(i).encode())</span><br><span class="line">        f.write(cipher)</span><br></pre></td></tr></table></figure><p><strong>cipher.txt</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">an</span> <span class="number">832</span> <span class="keyword">bytes</span> <span class="keyword">long</span> hex <span class="keyword">string</span></span><br></pre></td></tr></table></figure><h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>Mersenne Twister is a kind of PRNG, whose derives from the fact that its period length is chosen to be a Mersenne Prime. This Mersenne Twister challenge has a 32-bit length.</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Only a few conditions are given.</p><blockquote><p>the encryption result in cipher.txt</p><p>the period length</p><p>partial flag</p><p>the length of the flag</p><p>encryption function</p></blockquote><h2 id="Details"><a href="#Details" class="headerlink" title="Details"></a>Details</h2><p>Given that the first part of the flag is “npuctf{“, which is a 7 bytes long string, we can retrieve the first 28 generated states with the according cipher in cipher.txt. Since we also know the last byte of the string(“}”) and the length of the string, we can easily retrieve the 100th~103th generated states. </p><p>Then we look into the generate function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">        y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i + <span class="number">1</span>) % <span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">        temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">            temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">        self.state[i] = temp</span><br></pre></td></tr></table></figure><p>Suppose that i equals to 103, we try to write down that situation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">        y = (self.state[<span class="number">103</span>] &amp; <span class="number">0x80000000</span>) | (self.state[(<span class="number">104</span>) % <span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">        temp = y &gt;&gt; <span class="number">1</span>  <span class="comment"># 1</span></span><br><span class="line">        temp ^= self.state[(<span class="number">0</span>) % <span class="number">233</span>]  <span class="comment"># 2</span></span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">            temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">        self.state[<span class="number">103</span>] = temp  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>In this situation, it is possible for us to retrieve the104th initial state, which means that we can get the seed through inversing. There are two possibilities in this situation(state[104] is odd or even). We try to draw a table.</p><div class="table-container"><table><thead><tr><th>possibilites</th><th>hb(1)</th><th>hb(2)</th><th>hb(3)</th></tr></thead><tbody><tr><td>even</td><td>0</td><td>0</td><td>0</td></tr><tr><td>odd</td><td>0</td><td>0</td><td>1</td></tr></tbody></table></div><p>hb in the table above means the highest bit of the value in the line #n. Based on the fact that the true hb(3) is 0, which is the highest bit of the 103th generated state, it is impossible for the 104th initial state to be odd. Therefore, we can retrieve y and the low 31 bits of the 104 initial state. Since the highest bit is unknown, we can guess it (zero or one). Therefore, there are two possible seeds, which can be judged in the end. Because the seed is retrieved, we can decrypt the cipher easily.(Something just like Symmetric Cipher)</p><p>By the way, the md5 function in encrypt function seems to be useless because it only encrypts one character, for which we can correspondingly generate an md5 dictionary of all printable characters and print the corresponding characters.</p><h2 id="Realization"><a href="#Realization" class="headerlink" title="Realization"></a>Realization</h2><p>Here is my realization.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> Cryptodome.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">XOR = <span class="keyword">lambda</span> s1, s2: bytes([x1 ^ x2 <span class="keyword">for</span> x1, x2 <span class="keyword">in</span> zip(s1, s2)])</span><br><span class="line">initial_state = [<span class="number">0</span>] * <span class="number">233</span></span><br><span class="line">initial_state2 = [<span class="number">0</span>] * <span class="number">233</span></span><br><span class="line">cipher = [<span class="string">'cef4876036ee8b55aa59bca043725bf3'</span>,</span><br><span class="line">          <span class="string">'50a5e491debdef7ef7d63e9609a288ca'</span>,</span><br><span class="line">          <span class="string">'1e2c82a7fe566bd8709e73c8d495ea50'</span>,</span><br><span class="line">          <span class="string">'4a486ed11189faf8e6fb35617e47d2d1'</span>,</span><br><span class="line">          <span class="string">'ad5e4783e96afeaae9f7104ec477fb39'</span>,</span><br><span class="line">          <span class="string">'fe4ec619bf58289709e15c4449f03fc5'</span>,</span><br><span class="line">          <span class="string">'1cba918cd0ebfdc12376b41e78154064'</span>,</span><br><span class="line">          <span class="string">'82733b3b200826b6c78d86563edaea94'</span>,</span><br><span class="line">          <span class="string">'dccf459a4291517a4b8367d7b4a53aee'</span>,</span><br><span class="line">          <span class="string">'cd7e0accf661bfc726f5ba62e1c0e041'</span>,</span><br><span class="line">          <span class="string">'00108ad32e7d5711f780185cba5cf31d'</span>,</span><br><span class="line">          <span class="string">'328bee84066be4ab9582cf9d4bfe3c6f'</span>,</span><br><span class="line">          <span class="string">'96a7732e1c37d800c90fd46277147f0a'</span>,</span><br><span class="line">          <span class="string">'26c149dcd5eeb0f2df0c075627bc220b'</span>,</span><br><span class="line">          <span class="string">'e5eefdd67186056ac28c21e155a7f247'</span>,</span><br><span class="line">          <span class="string">'664aaecdb498134de274df10114d1f06'</span>,</span><br><span class="line">          <span class="string">'f84dd21820f150d69c9439d909dec0f5'</span>,</span><br><span class="line">          <span class="string">'ccfeab61b62db2ea91d31bc8163ff16c'</span>,</span><br><span class="line">          <span class="string">'7f458006bd5ac4a5f5bfae2770b23ccf'</span>,</span><br><span class="line">          <span class="string">'b7195b76aa0a9aa146831667a7b9fe08'</span>,</span><br><span class="line">          <span class="string">'c19e691afadccb3ca5169ef3fabaa3da'</span>,</span><br><span class="line">          <span class="string">'d47d536e89ed4cee6f788bc969c3ad31'</span>,</span><br><span class="line">          <span class="string">'37850ebfc46a73af2b0c036c3da4b4a1'</span>,</span><br><span class="line">          <span class="string">'6506f499445c604dd73eeb846a52f881'</span>,</span><br><span class="line">          <span class="string">'515a3ad0ab448b4f9ed3e0ab1fffac60'</span>,</span><br><span class="line">          <span class="string">'b223dde6450ba6198e90e14de107aaf2'</span>]</span><br><span class="line"></span><br><span class="line">starts = <span class="string">"npuctf&#123;"</span></span><br><span class="line">ends = <span class="string">"&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mt73991</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seed)</span>:</span></span><br><span class="line">        self.state = [seed] + [<span class="number">0</span>] * <span class="number">232</span></span><br><span class="line">        self.flag = <span class="number">0</span></span><br><span class="line">        self.srand()</span><br><span class="line">        self.generate()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">srand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">232</span>):</span><br><span class="line">            self.state[i + <span class="number">1</span>] = <span class="number">1812433253</span> * (self.state[i] ^ (self.state[i] &gt;&gt; <span class="number">27</span>)) - i</span><br><span class="line">            self.state[i + <span class="number">1</span>] &amp;= <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">233</span>):</span><br><span class="line">            y = (self.state[i] &amp; <span class="number">0x80000000</span>) | (self.state[(i + <span class="number">1</span>) % <span class="number">233</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">            temp = y &gt;&gt; <span class="number">1</span></span><br><span class="line">            temp ^= self.state[(i + <span class="number">130</span>) % <span class="number">233</span>]</span><br><span class="line">            <span class="keyword">if</span> y &amp; <span class="number">1</span>:</span><br><span class="line">                temp ^= <span class="number">0x9908f23f</span></span><br><span class="line">            self.state[i] = temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getramdanbits</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.flag == <span class="number">233</span>:</span><br><span class="line">            self.generate()</span><br><span class="line">            self.flag = <span class="number">0</span></span><br><span class="line">        bits = self.Next(self.state[self.flag]).to_bytes(<span class="number">4</span>, <span class="string">'big'</span>)</span><br><span class="line">        self.flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Next</span><span class="params">(self, tmp)</span>:</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">11</span>)</span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9ddf4680</span></span><br><span class="line">        tmp ^= (tmp &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc65400</span></span><br><span class="line">        tmp ^= (tmp &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x34adf670</span></span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">USMR</span><span class="params">(x, shift, mask)</span>:</span></span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &gt;&gt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">USML</span><span class="params">(x, shift, mask)</span>:</span></span><br><span class="line">    res = x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        res = x ^ (res &lt;&lt; shift &amp; mask)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_Next</span><span class="params">(x)</span>:</span></span><br><span class="line">    x = USMR(x, <span class="number">18</span>, <span class="number">0x34adf670</span>)</span><br><span class="line">    x = USML(x, <span class="number">15</span>, <span class="number">0xefc65400</span>)</span><br><span class="line">    x = USML(x, <span class="number">7</span>, <span class="number">0x9ddf4680</span>)</span><br><span class="line">    x = USR(x, <span class="number">11</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inv_srand</span><span class="params">(value, index)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        value += i</span><br><span class="line">        value *= inverse(<span class="number">1812433253</span>, <span class="number">0x100000000</span>)</span><br><span class="line">        value = USR(value, <span class="number">27</span>, <span class="number">0xffffffff</span>)</span><br><span class="line">        value &amp;= <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">USR</span><span class="params">(value, shift, mask)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i * shift &lt; <span class="number">32</span>:</span><br><span class="line">        partMask = ((<span class="number">0xffffffff</span> &lt;&lt; (<span class="number">32</span> - shift)) &amp; <span class="number">0xffffffff</span>) &gt;&gt; (shift * i)</span><br><span class="line">        part = value &amp; partMask</span><br><span class="line">        value ^= (part &gt;&gt; shift) &amp; mask</span><br><span class="line">        res |= part</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># hash all known characters</span></span><br><span class="line">hash_starts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> starts:</span><br><span class="line">    hash_starts.append(hashlib.md5(i.encode()).digest())</span><br><span class="line"><span class="comment"># print(hash_starts)</span></span><br><span class="line">hash_ends = hashlib.md5(ends.encode()).digest()</span><br><span class="line"></span><br><span class="line">state = [<span class="number">0</span>] * <span class="number">233</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># first 7 characters</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(starts)):</span><br><span class="line">    key = XOR(hash_starts[i], binascii.unhexlify(cipher[i]))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        tmp = inv_Next(bytes_to_long(key[<span class="number">4</span>*j:<span class="number">4</span>*j+<span class="number">4</span>]))</span><br><span class="line">        state[<span class="number">4</span>*i+j] = tmp</span><br><span class="line"><span class="comment"># print(state[:28])  # check pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(key, cipher)</span>:</span></span><br><span class="line">    cipher = binascii.unhexlify(cipher)</span><br><span class="line">    temp = XOR(key, cipher)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> md5_dic:</span><br><span class="line">        <span class="keyword">if</span> temp == i:</span><br><span class="line">            print(string.printable[md5_dic.index(i)], end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the last character</span></span><br><span class="line">key = XOR(hash_ends, binascii.unhexlify(cipher[<span class="number">-1</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    tmp = inv_Next(bytes_to_long(key[<span class="number">4</span>*i:<span class="number">4</span>*i+<span class="number">4</span>]))</span><br><span class="line">    state[<span class="number">100</span>+i] = tmp</span><br><span class="line"><span class="comment"># print(state[100:104]) # check pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Since it can be simplified, there are only two situations of old_state[104]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># old_state[104] is even</span></span><br><span class="line">y = (state[<span class="number">0</span>] ^ state[<span class="number">103</span>]) &lt;&lt; <span class="number">1</span>  <span class="comment"># recover y</span></span><br><span class="line"><span class="comment"># print(y) # check pass</span></span><br><span class="line">poss_1 = y &amp; <span class="number">0x7fffffff</span></span><br><span class="line">poss_2 = (y &amp; <span class="number">0x7fffffff</span>) | <span class="number">0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(poss_1)</span></span><br><span class="line"><span class="comment"># print(poss_2)</span></span><br><span class="line"><span class="comment"># check pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get the seed of each situation</span></span><br><span class="line">poss_1 = inv_srand(poss_1, <span class="number">104</span>)</span><br><span class="line">poss_2 = inv_srand(poss_2, <span class="number">104</span>)</span><br><span class="line">print(poss_1)</span><br><span class="line">print(poss_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate md5 dictionary</span></span><br><span class="line">md5_dic = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string.printable:</span><br><span class="line">    md5_dic.append(hashlib.md5(i.encode()).digest())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">random_1 = mt73991(poss_1)</span><br><span class="line">random_2 = mt73991(poss_2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># recover the flag from random_1</span></span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    key = <span class="string">b''</span>.join([random_1.getramdanbits() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">4</span>)])</span><br><span class="line">    decrypt(key, cipher[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Since random_1 is the correct one, random_2 can be ignored.</span></span><br></pre></td></tr></table></figure><p>这题一开始出题人搞错了。。。自闭了一下午</p><h1 id="认清形势，建立信心"><a href="#认清形势，建立信心" class="headerlink" title="认清形势，建立信心"></a>认清形势，建立信心</h1><p>After observing the task.py, we can find that this is a classical discrete logarithm problem. Let’s see the file.</p><p><strong>task.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">25</span>)</span><br><span class="line">e = <span class="comment"># Hidden</span></span><br><span class="line">q = getPrime(<span class="number">25</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag.strip(<span class="string">b"npuctf&#123;"</span>).strip(<span class="string">b"&#125;"</span>))</span><br><span class="line"></span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(pow(<span class="number">2</span>, e, n))</span><br><span class="line">print(pow(<span class="number">4</span>, e, n))</span><br><span class="line">print(pow(<span class="number">8</span>, e, n))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">169169912654178</span></span><br><span class="line"><span class="string">128509160179202</span></span><br><span class="line"><span class="string">518818742414340</span></span><br><span class="line"><span class="string">358553002064450</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="Explanation-1"><a href="#Explanation-1" class="headerlink" title="Explanation"></a>Explanation</h2><p>There are many methods to solve discrete logarithm problems, BSGS(Baby Steps Giant Steps), SPH method and so on.</p><h2 id="Condition-1"><a href="#Condition-1" class="headerlink" title="Condition"></a>Condition</h2><p>There are four equations in task.py and the remains of four equations are given. The flag is in the first equations. Here is what we have known.</p><blockquote><p>The length of q and p</p><p>remains of four equations</p></blockquote><p>My idea is that n is possible to be solved and after that we can use the second equation to calculate e, using  discrete logarithm calculation methods.</p><h2 id="Details-1"><a href="#Details-1" class="headerlink" title="Details"></a>Details</h2><p>We can notice that:</p><script type="math/tex; mode=display">n\;|\;gcd(c1^{3}\;-\;c3,\;c1^{2}\;-\;c2)</script><p>From this character and another character that n is the product of two big prime number, we can get n.</p><p>After that, it is really convenient that we can use discrete_log() function in Sage to calculate e. Luckily, e is coprime with n, so the inverse exists. The decryption is the similar with rsa.</p><h2 id="Realization-1"><a href="#Realization-1" class="headerlink" title="Realization"></a>Realization</h2><p>My realization.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">ture<span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">tureture<span class="keyword">return</span> a, <span class="number">0</span></span><br><span class="line">turea, b = gcd(b, a % b)</span><br><span class="line">ture<span class="keyword">return</span> a, b</span><br><span class="line"></span><br><span class="line">c = <span class="number">169169912654178</span></span><br><span class="line">c_1 = <span class="number">128509160179202</span></span><br><span class="line">c_2 = <span class="number">518818742414340</span></span><br><span class="line">c_3 = <span class="number">358553002064450</span></span><br><span class="line"></span><br><span class="line">dc_1 = c_1 ** <span class="number">2</span> - c_2</span><br><span class="line">dc_2 = c_1 ** <span class="number">3</span> - c_3</span><br><span class="line">n = gcd(dc_1, dc_2)[<span class="number">0</span>] / <span class="number">2</span></span><br><span class="line"><span class="comment"># print(n) # check pass</span></span><br><span class="line"></span><br><span class="line">n.factor()</span><br><span class="line">p = <span class="number">18195301</span></span><br><span class="line">q = <span class="number">28977097</span></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">e = discrete_log(Mod(c_1, n), Mod(<span class="number">2</span>, n))</span><br><span class="line"><span class="comment"># print(e)  # check pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(gcd(e, phi)[0])  # check pass</span></span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">m = pow(c, d, n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://en.wikipedia.org/wiki/Mersenne_Twister" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mersenne_Twister</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Only review in Crypto.&lt;/p&gt;
&lt;h1 id=&quot;What-does-the-tag-mean&quot;&gt;&lt;a href=&quot;#What-does-the-tag-mean&quot; class=&quot;headerlink&quot; title=&quot;What does the tag 
      
    
    </summary>
    
    
    
      <category term="Review" scheme="https://buki-freak.github.io/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-03</title>
    <link href="https://buki-freak.github.io/2020/05/03/2020-05-03/"/>
    <id>https://buki-freak.github.io/2020/05/03/2020-05-03/</id>
    <published>2020-05-03T14:44:24.000Z</published>
    <updated>2020-05-03T14:50:02.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h1><p>Sadly, the quiz yesterday is still unsolved. It seems that z3-solver doesn’t work. As a result, I study <strong><em>Correlation Attack</em></strong>  which is a kind of brute-force attack method. The method seems to work now and I am trying to understanding the codes written by others. Daily IELTS exercises have been done. What a day!</p><h1 id="Things-to-Learn-and-Improve"><a href="#Things-to-Learn-and-Improve" class="headerlink" title="Things to Learn and Improve"></a>Things to Learn and Improve</h1><ul><li>Stream Cipher - Correlation Attack Method</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-I-Have-Done&quot;&gt;&lt;a href=&quot;#What-I-Have-Done&quot; class=&quot;headerlink&quot; title=&quot;What I Have Done&quot;&gt;&lt;/a&gt;What I Have Done&lt;/h1&gt;&lt;p&gt;Sadly, the qui
      
    
    </summary>
    
    
    
      <category term="Daily Post" scheme="https://buki-freak.github.io/tags/Daily-Post/"/>
    
  </entry>
  
  <entry>
    <title>2020-05-02</title>
    <link href="https://buki-freak.github.io/2020/05/02/2020-05-02/"/>
    <id>https://buki-freak.github.io/2020/05/02/2020-05-02/</id>
    <published>2020-05-02T13:12:07.000Z</published>
    <updated>2020-05-02T13:22:44.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="What-I-Have-Done"><a href="#What-I-Have-Done" class="headerlink" title="What I Have Done"></a>What I Have Done</h1><p>A competition is held in these days, exciting and also exhausting! I am confident on a quiz about LFSR, which I have lately learned. However, things always does go in the right way, isn’t it? After being trapped for over five hours, I went to sleep… While I did several IELTS reading exercises, oh of course, I have finished <em>The End of the fxxking world Season One</em> just for fun ha ha ha!</p><h1 id="Things-to-Learn-and-Improve"><a href="#Things-to-Learn-and-Improve" class="headerlink" title="Things to Learn and Improve"></a>Things to Learn and Improve</h1><ul><li>z3-solver</li><li>English reading speed</li><li>Be easygoing</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;What-I-Have-Done&quot;&gt;&lt;a href=&quot;#What-I-Have-Done&quot; class=&quot;headerlink&quot; title=&quot;What I Have Done&quot;&gt;&lt;/a&gt;What I Have Done&lt;/h1&gt;&lt;p&gt;A competition 
      
    
    </summary>
    
    
    
      <category term="Daily Post" scheme="https://buki-freak.github.io/tags/Daily-Post/"/>
    
  </entry>
  
  <entry>
    <title>Greeting</title>
    <link href="https://buki-freak.github.io/2020/05/01/Greeting/"/>
    <id>https://buki-freak.github.io/2020/05/01/Greeting/</id>
    <published>2020-05-01T12:33:15.000Z</published>
    <updated>2020-05-01T12:57:56.341Z</updated>
    
    <content type="html"><![CDATA[<p>Today, I have deleted all blogs deployed before. My greeting is below.</p><h1 id="The-Past"><a href="#The-Past" class="headerlink" title="The Past"></a>The Past</h1><p>​    For a so-called loser, it is always mournful to talk about his or her past. Actually, I am one of them, after failing the college entrance examination. What’s more, things go wrong in these university days. It seems that I have have been trapped for such a long time, or have had a nightmare. Families, friends, mates, the environment, …, everything goes in a wrong way. However, Mama usually tells  me to be positive, which merely works at some time I think. Well, as is told, if you don’t like this world, you can just try to leave it and choose your life. It will be alright, since seldom people can live for 100 years. I mean I should do what I really want to do in limited time. Therefore, stop to complain about the past, leave that fxxking world and alter a world that you want.</p><h1 id="Present-Days"><a href="#Present-Days" class="headerlink" title="Present Days"></a>Present Days</h1><p>​    Well, all roads lead to Rome. There are many ways to achieve your ambition and I choose that one that I have lately planned. Once the goal is settled, you only need to:</p><ul><li>Focus</li><li>Focus</li><li>Focus</li></ul><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future is unpredictable, but we should be hopeful. Look at the sky, and you will find how lovely it is to see the past of others. They are shining for you.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Today, I have deleted all blogs deployed before. My greeting is below.&lt;/p&gt;
&lt;h1 id=&quot;The-Past&quot;&gt;&lt;a href=&quot;#The-Past&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
    
      <category term="Personal Development" scheme="https://buki-freak.github.io/tags/Personal-Development/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://buki-freak.github.io/2020/05/01/hello-world/"/>
    <id>https://buki-freak.github.io/2020/05/01/hello-world/</id>
    <published>2020-05-01T12:30:10.251Z</published>
    <updated>2019-08-27T01:03:22.557Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
